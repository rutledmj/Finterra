(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.qmci || (g.qmci = {})).Streamer = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _logging = require("./logging.js");

var _EventSupport = require("./EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

var _streamerEvents = require("./streamer-events.js");

var events = _interopRequireWildcard(_streamerEvents);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Connection = function () {
    function Connection(createTransmitter, openSocket, log) {
        var maxReconnectAttempts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;

        _classCallCheck(this, Connection);

        this.openSocket = openSocket;
        this.createTransmitter = createTransmitter;
        this.log = (0, _logging.asLogger)(log);
        this.events = new _EventSupport2["default"](this);
        this.currentConn = '';
        //Max number of times that the client will try to reopen per loop
        this.maxReconnectAttempts = maxReconnectAttempts;
        //Max number of times client will be able to try to reopen in total. Once this is reached, client will close and no reconnect will be attempted.
        //probably means that an unhandled loop was reached
        this.maxReconnectsTotal = 3;
        this.isFirstConnection = true;
        this.atmoCodes = {
            1000: "Normal closure; the connection successfully completed whatever purpose for which it was created.",
            1001: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.",
            1002: "The endpoint is terminating the connection due to a protocol error.",
            1003: "The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).",
            1004: "The endpoint is terminating the connection because a data frame was received that is too large.",
            1005: "Unknown: no status code was provided even though one was expected.",
            1006: "Connection was closed abnormally (that is, with no close frame being sent)."
        };
    }

    Connection.prototype.open = function open() {
        var _this = this;

        var socketProxy = { // Late binding for socket
            push: function push(message) {
                return _this.socket.push(message);
            }
        };

        //Check to avoid creating unnecessary events and objects
        if (this.isFirstConnection) {
            this.on("reopen", function (e) {
                if (_this.isConnectionUp) {
                    var prevConn = _this.currentConn;
                    _this.currentConn = e.connectionId;
                    _this.events.fire("reconnect", events.event("Reconnection success", {
                        previousConnectionId: prevConn,
                        currentConnectionId: _this.currentConn
                    }));
                } else {
                    _this.events.fire("error", e);
                }
            });
            this.transmitter = this.createTransmitter(socketProxy);
            this.transmitter.on("sequence", function (seq) {
                _this.events.fire("sequence", seq);
            }).on("message", function (message) {
                _this.events.fire("message", message);
            });
        }
        this.socket = this.openSocket(function (request) {
            _this.request = request;
            var url = request.url;

            _this.reconnect = false;
            return {
                onMessage: function onMessage(response) {
                    _this.transmitter.onMessage(response.responseBody);
                },
                onMessagePublished: function onMessagePublished(response) {
                    _this.transmitter.onMessage(response.responseBody);
                },
                onOpen: function onOpen(response) {
                    var code = response.status;
                    if (code !== 200) {
                        _this.reconnect = false;
                    } else {
                        _this.isConnectionUp = true;
                    }
                    var e = events.event("open", {
                        url: url,
                        code: code,
                        transport: response.transport,
                        connectionId: response.request.uuid
                    });
                    _this.log.info(e);
                    _this.events.fire("open", e);
                    if (!_this.isFirstConnection) {
                        _this.maxReconnectsTotal--;
                        _this.events.fire("reopen", e);
                    }
                    _this.currentConn = response.request.uuid;
                },
                onTransportFailure: function onTransportFailure(reason, request) {
                    var e = events.error("Transport failure", {
                        url: url,
                        code: -2,
                        reason: reason,
                        fallback: request.fallbackTransport
                    });
                    _this.log.error(reason);
                    _this.events.fire("error", e);
                    if (_this.isReconnect()) {
                        _this.reconnect = true;
                    }
                },
                onError: function onError(response) {
                    var reason = response.reason || response.reasonPhrase;
                    var code = response.status;
                    if (reason && ("" + reason.stack).includes("Failed to execute 'send' on 'XMLHttpRequest")) {
                        var _url = /Failed to load '(.*?)'/.exec("" + reason.stack)[1]; // The rest of this reason is a huge, useless stack trace.
                        reason = "Failed to send XMLHttpRequest to " + _url;
                        code = 404; // Not exactly right since the server's probably down, but it gives a good indication.
                    }

                    var e = events.error(response.reason, {
                        transport: response.transport,
                        reason: reason,
                        url: url,
                        code: code
                    });
                    _this.log.error(e);
                    _this.events.fire("error", e);
                },
                onClose: function onClose(response) {
                    var code = response.status;
                    var reason = response.reason || response.reasonPhrase;
                    var atmosphereMessage = response.atmoMessage;
                    // For whatever reason, Atmosphere sets to 408 when unsubscribing (e.g., when refreshing the page)
                    if (code === 408 && response.state === "unsubscribe") {
                        code = 200;
                        reason = "Unsubscribed";
                    }
                    //When 501 code is sent it could mean that the server is down, therefore do not continue trying to reconnect
                    if (code === 501 || code === 401 || code === 403 || code === 452) {
                        _this.log.warn("Unable to reconnect with code: " + code + ", reason: " + reason);
                        _this.reconnect = false;
                    }
                    if (atmosphereMessage && atmosphereMessage.code in _this.atmoCodes) {
                        _this.log.error("Unexpected close. Code: " + atmosphereMessage.code + " Reason: " + _this.atmoCodes[atmosphereMessage.code]);
                        _this.events.fire("atmoError", events.error("Atmosphere error", {
                            reason: _this.atmoCodes[atmosphereMessage.code],
                            code: atmosphereMessage.code
                        }));
                        code = 410;
                        reason = "Gone";
                    }
                    var e = events.close({
                        url: url,
                        transport: response.transport,
                        code: code,
                        reason: reason
                    });
                    _this.isConnectionUp = false;
                    //Need to reset this value since it seems to be causing issues with resubscribing
                    response.request.uuid = 0;
                    _this.log.info(e);
                    _this.events.fire("close", e);
                },
                onSlow: function onSlow(response) {
                    var e = events.slow({
                        timesExceeded: response.timesExceeded,
                        maxExceeded: response.maxExceed
                    });
                    _this.reconnect = false;
                    _this.log.warn("Slow connection received, Reconnection will not be attempted.");
                    _this.log.info(e);
                    _this.events.fire("slow", e);
                }
            };
        }, this.currentConn);
    };

    Connection.prototype.close = function close() {
        if (this.socket) {
            try {
                this.socket.close();
                this.socket = null;
                if (this.reconnect) {
                    this.tryReopen();
                }
            } catch (err) {
                this.events.fire("error", events.error("Error closing", {
                    reason: err.message,
                    cause: err,
                    code: -3
                }));
            }
        }
    };

    Connection.prototype.tryReopen = function tryReopen() {
        var _this2 = this;

        if (this.isConnectionUp || this.maxReconnectsTotal <= 0) {
            this.log.error("Connection is already open or max reconnects was reached, won't try to reconnect");
            return;
        }
        this.isFirstConnection = false;
        var currentAttempts = this.maxReconnectAttempts;
        // Recursively run this until a successful open is completed
        var reconnect = function reconnect() {
            if (currentAttempts <= 0) {
                _this2.reconnect = false;
                _this2.log.error("Error while reconnecting. No attempts left.");
                //if maxattempts was reached and no connection was open, exit.
                _this2.maxReconnectAttempts = 0;
                return;
            }
            if (_this2.isConnectionUp || !_this2.reconnect) {
                return;
            }
            _this2.log.info("Attempting reconnect. Attempts left: " + currentAttempts);
            _this2.reopen(currentAttempts);
            currentAttempts--;
            setTimeout(reconnect, 500);
        };
        setTimeout(reconnect, 500);
    };

    Connection.prototype.reopen = function reopen(attempt) {
        try {
            this.open();
        } catch (exception) {
            this.log.warn("There was an error while reopening attempt #" + attempt);
            this.events.fire("error", exception);
        }
    };

    Connection.prototype.send = function send(message) {
        try {
            this.transmitter.send(message);
        } catch (err) {
            this.events.fire("error", events.error("Error sending message", {
                reason: err.message,
                cause: err,
                code: -4
            }));
        }
    };

    Connection.prototype.isReconnect = function isReconnect() {
        return this.request.headers['x-Stream-isReconnect'];
    };

    Connection.prototype.setReconnect = function setReconnect(doReconnect) {
        this.reconnect = doReconnect;
    };

    Connection.prototype.setServer = function setServer(server) {
        this.request.headers['X-Stream-Instance'] = server;
    };

    Connection.prototype.isClosed = function isClosed() {
        return this.socket == null;
    };

    Connection.prototype.on = function on(event, callback) {
        return this.events.on(event, callback);
    };

    return Connection;
}();

exports["default"] = Connection;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/Connection.js","/lib")
},{"./EventSupport.js":2,"./logging.js":16,"./streamer-events.js":109,"_process":131,"buffer":121,"timers":152}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventSupport = function () {
    function EventSupport(source) {
        _classCallCheck(this, EventSupport);

        this.listeners = {};
        this.source = source || this;
    }

    EventSupport.prototype.on = function on(event, listener) {
        this.listeners[event] = this.listeners[event] || [];
        this.listeners[event].push(listener);
        return this.source;
    };

    EventSupport.prototype.fire = function fire(event, data) {
        var listeners = this.listeners[event];
        if (listeners) {
            for (var _iterator = listeners, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var listener = _ref;

                listener(data);
            }
        }
    };

    return EventSupport;
}();

exports["default"] = EventSupport;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/EventSupport.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _LongSequence = require("./LongSequence.js");

var _LongSequence2 = _interopRequireDefault(_LongSequence);

var _streamerApi = require("./streamer-api.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FlowControl = function () {
    function FlowControl(update) {
        _classCallCheck(this, FlowControl);

        this.update = update;
        this.sendsequence = new _LongSequence2["default"]();
        this.checkinterval = null;
        this.lastreceivedsequence = null;
    }

    FlowControl.prototype.next = function next() {
        return this.sendsequence.next();
    };

    FlowControl.prototype.track = function track(sequence) {
        if (this.checkinterval == null) {
            return;
        }

        if (sequence % this.checkinterval == 0) {
            var _update = new _streamerApi.messages.control.FlowMessage();
            _update.sequence = sequence;
            this.update(_update);
        }

        this.lastreceivedsequence = sequence;
    };

    return FlowControl;
}();

exports["default"] = FlowControl;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/FlowControl.js","/lib")
},{"./LongSequence.js":4,"./streamer-api.js":108,"_process":131,"buffer":121,"timers":152}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LongSequence = function () {
    function LongSequence() {
        _classCallCheck(this, LongSequence);

        this.val = LongSequence.MIN_VALUE;
    }

    LongSequence.prototype.next = function next() {
        var _current = this.val;
        if (_current < LongSequence.MAX_VALUE) {
            this.val++;
        } else {
            this.val = LongSequence.MIN_VALUE;
        }
        return _current;
    };

    return LongSequence;
}();

LongSequence.MIN_VALUE = 1;
LongSequence.MAX_VALUE = Number.MAX_SAFE_INTEGER;

exports["default"] = LongSequence;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/LongSequence.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _codec = require("./serialization/v1/codec.js");

var _codec2 = _interopRequireDefault(_codec);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generic payload container with metadata.
 * @constructor
 */
var SMessage = function SMessage() {
  _classCallCheck(this, SMessage);

  /**
   * Message type to distinguish different message types.
   * @type {string}
   */
  this.type = _codec2["default"].TYPE;

  /**
   * Sequence number may be used for flow control.
   * @type {number}
   */
  this.sequencenumber = null;

  /**
   * Timestamp may be used for latency measuring.
   * @type {number}
   */
  this.timestamp = null;

  /**
   * Id may be used for request response matching.
   * @type {number}
   */
  this.id = null;

  /**
   * Encoding of <code>payload</code>.
   * @type {string}
   */
  this.encoding = null;

  /**
   * Mime type of <code>payload</code>.
   * @type {string}
   */
  this.mimetype = null;

  /**
   * Payload encoded with <code>encoding</code> and serialized with <code>mimetype</code>.
   * @type {string}
   */
  this.payload = null;
};

exports["default"] = SMessage;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/SMessage.js","/lib")
},{"./serialization/v1/codec.js":103,"_process":131,"buffer":121,"timers":152}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

require("./polyfills.js");

var _streamerApi = require("./streamer-api.js");

var _streamerUtils = require("./streamer-utils.js");

var _logging = require("./logging.js");

var _utils = require("./utils.js");

var _UShortId = require("./UShortId.js");

var _UShortId2 = _interopRequireDefault(_UShortId);

var _FlowControl = require("./FlowControl.js");

var _FlowControl2 = _interopRequireDefault(_FlowControl);

var _EventSupport = require("./EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

var _formatting = require("./formatting.js");

var _streamerEvents = require("./streamer-events.js");

var events = _interopRequireWildcard(_streamerEvents);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CONSOLIDATED_SYMBOL_ENTITLEMENTS_COEFFICIENT = 14;
var CONSOLIDATED_SYMBOL_SUFFIX = ":CC";

var Stream = function () {
    function Stream(streamingService, format, log) {
        var _this = this;

        _classCallCheck(this, Stream);

        this.events = new _EventSupport2["default"]();
        this.streamingService = streamingService;
        this.format = format;
        this.log = (0, _logging.asLogger)(log);

        this.flowControl = new _FlowControl2["default"](function (update) {
            _this.send(update);
        });

        this.conn = streamingService.createConnection();
        this.conn.on("message", function (msg) {
            _this._handlejsonmsg(msg);
        }).on("sequence", function (seq) {
            _this.flowControl.track(seq);
        }).on("close", function (msg) {
            _this.doClose(msg);
        }).on("error", function (err) {
            if (_this.pendingConnection) {
                _this.pendingConnection(err);
            }
            _this.events.fire("error", err);
        }).on("reconnect", function (msg) {
            _this.reconnectSuccess(msg);
        }).on("atmoError", function (err) {
            _this.events.fire("atmoError", err);
        });

        this.requestid = new _UShortId2["default"]();

        this.pendingsubscriptions = {};
        this.pendingUnsubscriptions = {};
        this.pendingExchangeSubscriptions = {};
        this.pendingExchangeUnsubscriptions = {};
        this.pendingNewsSubscriptions = {};
        this.pendingNewsUnsubscriptions = {};
        this.pendingAlertSubscription = {};
        this.pendingTradeSubscription = {};
        this.pendingTradeUnsubscription = {};

        this.on("error", function (err) {
            _this.log.warn(err);
        });
    }

    Stream.prototype.open = function open(callback) {
        try {
            this.pendingConnection = callback;
            this.conn.open();
        } catch (err) {
            if (callback) {
                callback(err);
            }
        }
    };

    Stream.prototype.reconnectSuccess = function reconnectSuccess(msg) {
        this.events.fire("reconnectSuccess", msg);
        this.log.info("Successfull reconnection. Previous Id: " + msg.previousConnectionId + " Current Id = " + msg.currentConnectionId);
    };

    Stream.prototype.on = function on(event, listener) {
        return this.events.on(event, listener);
    };

    Stream.prototype.subscribe = function subscribe(symbols, types, optsOrCallback, callbackOrNothing) {
        var _this2 = this;

        symbols = (Array.isArray(symbols) ? symbols : [symbols]).map(function (s) {
            return s.toUpperCase();
        });
        types = Array.isArray(types) ? types : [types].map(function (s) {
            return s.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var subscription = {
            ids: [],
            types: types,
            mimetype: this.format,
            callback: callback,
            result: {
                subscribed: [],
                rejected: [],
                unentitled: [],
                invalidSymbols: []
            }
        };

        if (symbols.length === 0 || types.length === 0) {
            callback(null, subscription.result);
            return;
        }

        var requests = this._prepareSubscriptionRequests(symbols, subscription, _streamerApi.messages.control.Action.SUBSCRIBE, opts);
        requests.forEach(function (request) {
            var id = _this2.requestid.next();
            subscription.ids.push(id);
            _this2.pendingsubscriptions[id] = subscription;
            request.id = id;

            _this2.send(request);
        });
    };

    Stream.prototype.subscribeExchange = function subscribeExchange(exchanges, optsOrCallback, callbackOrNothing) {
        var _this3 = this;

        exchanges = (Array.isArray(exchanges) ? exchanges : [exchanges]).map(function (e) {
            return e.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var exchangeSub = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                subscribed: [],
                rejected: []
            }
        };
        //check for empty string
        if (exchanges.length === 0) {
            callback(null, exchangeSub.result);
        }

        var requests = this.prepareExchangeSubscriptionRequest(exchanges, exchangeSub, _streamerApi.messages.control.Action.SUBSCRIBE, opts);

        requests.forEach(function (request) {
            var id = _this3.requestid.next();
            exchangeSub.id.push(id);
            exchangeSub.exchange = request.exchange;
            exchangeSub.conflation = request.conflation;
            _this3.pendingExchangeSubscriptions[id] = exchangeSub;
            request.id = id;
            _this3.send(request);
        });
    };

    Stream.prototype.subscribeNews = function subscribeNews(newsFilters, optsOrCallback, callbackOrNothing) {

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var newsSub = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                newsFilters: [],
                rejectedNewsFilters: [],
                unentitledNewsFilters: []
            }
        };
        //check for empty filters
        if (newsFilters.length === 0) {
            callback(null, newsSub.result);
        }
        var request = this.buildNewsSubscribeRequest(newsFilters, newsSub, _streamerApi.messages.control.Action.SUBSCRIBE, opts);

        var id = this.requestid.next();
        this.pendingNewsSubscriptions[id] = newsSub;

        request.id = id;

        this.send(request);
    };

    Stream.prototype.subUnsubAlerts = function subUnsubAlerts(operation, optsOrCallback, callbackOrNothing) {

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }

        var subscription = {
            id: [],
            mimetype: this.format,
            callback: callback,
            result: {
                operation: ""
            }
        };

        var request = this.buildAlertsSubUnsubRequest(operation, subscription);
        var id = this.requestid.next();
        subscription.id.push(id);
        this.pendingAlertSubscription[id] = subscription;
        request.id = id;

        this.send(request);
    };

    Stream.prototype.subscribeTrade = function subscribeTrade(notificationType, optsOrCallback, callbackOrNothing) {
        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }

        var tradeSub = {
            id: [],
            mimetype: this.format,
            callback: callback,
            result: {
                notificationType: ""
            }
        };

        var request = this.buildTradeSubscribeRequest(notificationType, tradeSub, _streamerApi.messages.control.Action.SUBSCRIBE);
        var id = this.requestid.next();
        tradeSub.id.push(id);
        this.pendingTradeSubscription[id] = tradeSub;
        request.id = id;

        this.send(request);
    };

    Stream.prototype.getSessionStats = function getSessionStats() {
        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }
        var msg = new _streamerApi.messages.control.StatsMessage();
        this.send(msg);
    };

    Stream.prototype.cmdFilterRefreshNews = function cmdFilterRefreshNews(callbackOrNothing) {
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var newsCmdFilterRefresh = {
            callback: callback,
            mimetype: this.format
        };

        var request = this.buildNewsCommandRequest(newsCmdFilterRefresh, 'NEWSCMDFILTERREFRESH');
        this.send(request);
    };

    Stream.prototype.cmdFilterNews = function cmdFilterNews(callbackOrNothing) {
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var newsCmdFilter = {
            callback: callback,
            mimetype: this.format
        };

        var request = this.buildNewsCommandRequest(newsCmdFilter, 'NEWSCMDFILTER');
        this.send(request);
    };

    Stream.prototype.unsubscribe = function unsubscribe(symbols, types, optsOrCallback, callbackOrNothing) {
        var _this4 = this;

        symbols = (Array.isArray(symbols) ? symbols : [symbols]).map(function (s) {
            return s.toUpperCase();
        });
        types = Array.isArray(types) ? types : [types].map(function (s) {
            return s.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var unsubscription = {
            ids: [],
            types: types,
            mimetype: this.format,
            callback: callback,
            result: {
                unsubscribed: []
            }
        };

        if (symbols.length === 0 || types.length === 0) {
            if (callback) {
                callback(null, unsubscription.result);
            }
        }

        var requests = this._prepareSubscriptionRequests(symbols, unsubscription, _streamerApi.messages.control.Action.UNSUBSCRIBE, opts);
        requests.forEach(function (request) {
            var id = _this4.requestid.next();
            unsubscription.ids.push(id);
            _this4.pendingUnsubscriptions[id] = unsubscription;
            request.id = id;

            _this4.send(request);
        });
    };

    Stream.prototype.unsubscribeExchange = function unsubscribeExchange(exchanges, optsOrCallback, callbackOrNothing) {
        var _this5 = this;

        exchanges = (Array.isArray(exchanges) ? exchanges : [exchanges]).map(function (e) {
            return e.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var exchangeSub = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                subscribed: [],
                rejected: []
            }
        };
        //check for empty string
        if (exchanges.length === 0) {
            callback(null, exchangeSub.result);
        }

        var requests = this.prepareExchangeSubscriptionRequest(exchanges, exchangeSub, _streamerApi.messages.control.Action.UNSUBSCRIBE, opts);

        requests.forEach(function (request) {
            var id = _this5.requestid.next();
            exchangeSub.id.push(id);
            exchangeSub.exchange = request.exchange;
            exchangeSub.conflation = request.conflation;
            _this5.pendingExchangeUnsubscriptions[id] = exchangeSub;
            request.id = id;
            _this5.send(request);
        });
    };

    Stream.prototype.unsubscribeNews = function unsubscribeNews(newsFilters, optsOrCallback, callbackOrNothing) {
        newsFilters = Array.isArray(newsFilters) ? newsFilters : [newsFilters];

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var unsubscription = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                unsubscribed: []
            }
        };

        if (newsFilters.length === 0) {
            if (callback) {
                callback(null, unsubscription.result);
            }
        }

        var request = this.buildNewsSubscribeRequest(newsFilters, unsubscription, _streamerApi.messages.control.Action.UNSUBSCRIBE, opts);

        var id = this.requestid.next();
        unsubscription.id.push(id);
        this.pendingNewsUnsubscriptions[id] = unsubscription;
        request.id = id;

        this.send(request);
    };

    Stream.prototype.unsubscribeTrade = function unsubscribeTrade(notificationType, optsOrCallback, callbackOrNothing) {
        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }

        var tradeSub = {
            id: [],
            mimetype: this.format,
            callback: callback,
            result: {
                notificationType: ""
            }
        };

        var request = this.buildTradeSubscribeRequest(notificationType, tradeSub, _streamerApi.messages.control.Action.UNSUBSCRIBE);
        var id = this.requestid.next();
        tradeSub.id.push(id);
        this.pendingTradeUnsubscription[id] = tradeSub;
        request.id = id;

        this.send(request);
    };

    Stream.prototype._handlejsonmsg = function _handlejsonmsg(msg) {
        if ((0, _streamerUtils.iscontrolmessage)(msg)) {
            this.handlectrlmsg(msg);
        } else if ((0, _streamerUtils.isdatamessage)(msg)) {
            this._handledatamsg(msg);
        } else {
            this.events.fire("error", msg);
        }
    };

    Stream.prototype._prepareSubscriptionRequests = function _prepareSubscriptionRequests(symbols, subscription, action, opts) {
        var currentApproximateNumberOfEntitlements = 0;
        var lastAddedSymbolIndex = -1;
        var numberOfSymbols = symbols.length;
        var isOrderbookSubscription = subscription.types.includes("ORDERBOOK");
        var requests = [];
        for (var i = 0; i < numberOfSymbols; i++) {
            currentApproximateNumberOfEntitlements = this._getUpdatedNumberOfEntitlements(subscription.types.length, currentApproximateNumberOfEntitlements, symbols[i], isOrderbookSubscription);
            if (currentApproximateNumberOfEntitlements >= this.maxEntitlementsPerSubscription || i === numberOfSymbols - 1) {
                requests.push(this._buildRequest(symbols.slice(lastAddedSymbolIndex + 1, i + 1), subscription, action, opts));
                lastAddedSymbolIndex = i;
                currentApproximateNumberOfEntitlements = 0;
            }
        }
        return requests;
    };

    Stream.prototype._buildRequest = function _buildRequest(symbols, sub, action, opts) {
        var msg = new _streamerApi.messages.control.SubscribeMessage();
        msg.action = action;
        msg.symbols = symbols;
        msg.types = sub.types;
        msg.mimetype = sub.mimetype;
        if (opts && opts.skipHeavyInitialLoad) {
            msg.skipHeavyInitialLoad = true;
        }
        if (opts) {
            msg.conflation = opts.conflation;
            msg.intervalPeriod = opts.intervalPeriod;
        }
        return msg;
    };

    Stream.prototype.prepareExchangeSubscriptionRequest = function prepareExchangeSubscriptionRequest(exchanges, exchangeSub, action, opts) {
        var requests = [];
        var numberOfExchanges = exchanges.length;
        for (var i = 0; i < numberOfExchanges; i++) {
            requests.push(this.buildExchangeRequest(exchanges[i], exchangeSub, action, opts));
        }
        return requests;
    };

    Stream.prototype.buildExchangeRequest = function buildExchangeRequest(exchange, sub, action, opts) {
        var msg = new _streamerApi.messages.control.ExchangeSubscribeMessage();
        msg.action = action;
        msg.exchange = exchange;
        msg.mimetype = sub.mimetype;
        if (opts) {
            msg.conflation = opts.conflation;
        }
        return msg;
    };

    Stream.prototype.buildNewsSubscribeRequest = function buildNewsSubscribeRequest(newsFilters, sub, action, opts) {
        var msg = new _streamerApi.messages.control.NewsSubscribeMessage();
        msg.action = action;
        msg.newsFilters = newsFilters;
        msg.mimetype = sub.mimetype;
        if (opts && opts.skipHeavyInitialLoad) {
            msg.skipHeavyInitialLoad = opts.skipHeavyInitialLoad;
        }
        return msg;
    };

    Stream.prototype.buildAlertsSubUnsubRequest = function buildAlertsSubUnsubRequest(opr, subscription) {
        var msg = new _streamerApi.messages.control.AlertsSubUnsubMessage();
        msg.operation = opr;
        msg.mimetype = subscription.mimetype;
        return msg;
    };

    Stream.prototype.buildTradeSubscribeRequest = function buildTradeSubscribeRequest(notificationType, sub, action) {
        var msg = new _streamerApi.messages.control.TradeSubscribeMessage();
        msg.action = action;
        msg.notificationType = notificationType;
        msg.mimetype = sub.mimetype;
        return msg;
    };

    Stream.prototype.buildNewsCommandRequest = function buildNewsCommandRequest(sub, newsAction) {
        var msg = new _streamerApi.messages.control.NewsCommandMessage();
        msg.newsAction = newsAction;
        msg.mimetype = sub.mimetype;
        return msg;
    };

    Stream.prototype._getUpdatedNumberOfEntitlements = function _getUpdatedNumberOfEntitlements(numberOfSubscriptionTypes, currentApproximateNumberOfEntitlements, symbol, isSubscribeToOrderbook) {
        var result = currentApproximateNumberOfEntitlements;
        if (isSubscribeToOrderbook && symbol.endsWith(CONSOLIDATED_SYMBOL_SUFFIX)) {
            result += CONSOLIDATED_SYMBOL_ENTITLEMENTS_COEFFICIENT * numberOfSubscriptionTypes;
        } else {
            result += numberOfSubscriptionTypes;
        }
        return result;
    };

    Stream.prototype.handlectrlmsg = function handlectrlmsg(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        var _type = (0, _streamerUtils.messagetype)(msg);
        switch (_type) {
            case _streamerApi.messages.MessageTypeNames.ctrl.HEARTBEAT:
                this.onHeartbeat(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.SUBSCRIBE_RESPONSE:
                this.onSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_RESPONSE:
                this.onExchangeSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_SUBSCRIBE_RESPONSE:
                this.onNewsSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.ALERTS_SUBUNSUB_RESPONSE:
                this.onAlertsSubUnsubResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.TRADE_SUBSCRIBE_RESPONSE:
                this.onTradeSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.UNSUBSCRIBE_RESPONSE:
                this.onUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_UNSUBSCRIBE_RESPONSE:
                this.onExchangeUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_UNSUBSCRIBE_RESPONSE:
                this.onNewsUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_CMD_FILTER_REFRESH_RESPONSE:
                this.onNewsCmdFilterRefreshResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_CMD_FILTER_RESPONSE:
                this.onNewsCmdFilterResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.TRADE_UNSUBSCRIBE_RESPONSE:
                this.onTradeUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.CONNECT_RESPONSE:
                this.onConnectResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.CONNECTION_CLOSE:
                this.onConnectionClose(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.SLOW_CONNECTION:
                this.onSlowConnection(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.STATS_RESPONSE:
                this.onStatsResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.INITIAL_DATA_SENT:
                this.onInitialDataSent(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.RESUBSCRIBE_MESSAGE:
                this.onResubscribeMessage(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.RECONNECT_RESPONSE:
                this.onReconnectMessage(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.MISSED_DATA_SENT:
                this.onMissedDataSent(msg);
                break;
        }
    };

    Stream.prototype.onHeartbeat = function onHeartbeat(msg) {};

    Stream.prototype.onSubscribeResponse = function onSubscribeResponse(msg) {
        var subscription = this.pendingsubscriptions[msg.__id];
        var callback = subscription.callback;

        (0, _utils.removeFromArray)(subscription.ids, msg.__id);
        delete this.pendingsubscriptions[msg.__id];

        if (msg.code != 200 && !subscription.failed) {
            subscription.failed = true;
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                subscription.callback(event);
            }
            return;
        }

        var result = subscription.result;

        if (msg.entitlements) {
            for (var _iterator = msg.entitlements, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var key = _ref;
                var _key = key,
                    symbol = _key.symbol,
                    marketdatatype = _key.marketdatatype,
                    entitlement = _key.entitlement;

                key = { symbol: symbol, type: marketdatatype };
                if (entitlement !== 'NA') {
                    this.log.debug('SUBSCRIBED <' + symbol + ', ' + marketdatatype + '>');
                    key.entitlement = entitlement;
                    result.subscribed.push(key);
                } else {
                    this.log.warn('NOT ENTITLED <' + symbol + ',' + marketdatatype + '>');
                    result.unentitled.push(key);
                }
            }
        }
        if (msg.rejectedSymbols) {
            for (var _iterator2 = msg.rejectedSymbols, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                var symbol = _ref2;

                this.log.warn('REJECTED ' + symbol);
                result.rejected.push(symbol);
            }
        }
        if (msg.invalidSymbols) {
            for (var _iterator3 = msg.invalidSymbols, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                var _result$invalidSymbol;

                var _ref3;

                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref3 = _i3.value;
                }

                var _symbol2 = _ref3;

                this.log.warn('INVALID SYMBOL ' + _symbol2);
                (_result$invalidSymbol = result.invalidSymbols).push.apply(_result$invalidSymbol, msg.invalidSymbols);
            }
        }

        if (subscription.ids.length === 0 && !subscription.failed) {
            if (callback) {
                callback(null, subscription.result);
            }
        }
    };

    Stream.prototype.onExchangeSubscribeResponse = function onExchangeSubscribeResponse(msg) {
        var exchangeSub = this.pendingExchangeSubscriptions[msg.__id];
        var callback = exchangeSub.callback;

        (0, _utils.removeFromArray)(exchangeSub.id, msg.__id);
        delete this.pendingExchangeSubscriptions[msg.__id];

        console.log(msg);
        if (msg.code != 200) {
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                exchangeSub.callback(event);
            }
            return;
        }
        if (exchangeSub.id.length === 0) {
            if (callback) {
                callback(null, exchangeSub);
            }
        }
    };

    Stream.prototype.onNewsSubscribeResponse = function onNewsSubscribeResponse(msg) {
        var newsSub = this.pendingNewsSubscriptions[msg.__id];
        var callback = newsSub.callback;

        (0, _utils.removeFromArray)(newsSub.id, msg.__id);
        delete this.pendingNewsSubscriptions[msg.__id];

        var result = newsSub.result;

        console.log(msg);
        if (msg.code != 200) {
            var event = events.error("Error subscribing to news", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                newsSub.callback(event);
            }
            return;
        }
        if (msg.newsFilters) {
            for (var _iterator4 = msg.newsFilters, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                var _ref4;

                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done) break;
                    _ref4 = _i4.value;
                }

                var newsFilter = _ref4;

                result.newsFilters.push(newsFilter);
            }
        }
        if (msg.rejectedNewsFilters) {
            for (var _iterator5 = msg.rejectedNewsFilters, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                var _ref5;

                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    _i5 = _iterator5.next();
                    if (_i5.done) break;
                    _ref5 = _i5.value;
                }

                var rejectedFilter = _ref5;

                result.rejectedNewsFilters.push(rejectedFilter);
            }
        }
        if (msg.unentitledNewsFilters) {
            for (var _iterator6 = msg.unentitledNewsFilters, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                var _ref6;

                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    _i6 = _iterator6.next();
                    if (_i6.done) break;
                    _ref6 = _i6.value;
                }

                var unentitledFilter = _ref6;

                result.unentitledNewsFilters.push(unentitledFilter);
            }
        }

        if (newsSub.id.length === 0) {
            if (callback) {
                callback(null, newsSub.result);
            }
        }
    };

    Stream.prototype.onAlertsSubUnsubResponse = function onAlertsSubUnsubResponse(msg) {
        var alertsSub = this.pendingAlertSubscription[msg.__id];
        var callback = alertsSub.callback;

        (0, _utils.removeFromArray)(alertsSub.id, msg.__id);
        delete this.pendingAlertSubscription[msg.__id];

        console.log(msg);
        if (msg.code != 200 && !alertsSub.failed) {
            alertsSub.failed = true;
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                alertsSub.callback(event);
            }
            return;
        }

        var result = alertsSub.result;

        if (msg.operation) {
            this.log.debug('Alerts ' + msg.operation);
            result.operation = msg.operation;
        }

        if (alertsSub.id.length === 0) {
            if (callback) {
                callback(null, alertsSub.result);
            }
        }
    };

    Stream.prototype.onTradeSubscribeResponse = function onTradeSubscribeResponse(msg) {
        var tradeSub = this.pendingTradeSubscription[msg.__id];
        var callback = tradeSub.callback;

        (0, _utils.removeFromArray)(tradeSub.id, msg.__id);
        delete this.pendingTradeSubscription[msg.__id];

        console.log(msg);
        if (msg.code != 200 && !tradeSub.failed) {
            tradeSub.failed = true;
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                tradeSub.callback(event);
            }
            return;
        }

        var result = tradeSub.result;

        if (msg.notificationType) {
            this.log.debug('Trade ' + msg.notificationType);
            result.notificationType = msg.notificationType;
        }

        if (tradeSub.id.length === 0) {
            if (callback) {
                callback(null, tradeSub.result);
            }
        }
    };

    Stream.prototype.onNewsUnsubscribeResponse = function onNewsUnsubscribeResponse(msg) {
        var newsUnsub = this.pendingNewsUnsubscriptions[msg.__id];
        var callback = newsUnsub.callback;

        (0, _utils.removeFromArray)(newsUnsub.id, msg.__id);
        delete this.pendingNewsUnsubscriptions[msg.__id];

        console.log("msg", msg);
        var result = newsUnsub.result;

        if (msg.code != 200 && !newsUnsub.failed) {
            newsUnsub.failed = true;
            var event = events.error("Error unsubscribing to news", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                newsUnsub.callback(event);
            }
            return;
        }

        if (msg.newsFilters) {
            for (var _iterator7 = msg.newsFilters, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
                var _ref7;

                if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    _i7 = _iterator7.next();
                    if (_i7.done) break;
                    _ref7 = _i7.value;
                }

                var newsFilter = _ref7;

                result.unsubscribed.push(newsFilter);
            }
        }

        if (newsUnsub.id.length === 0) {
            if (callback) {
                callback(null, newsUnsub.result);
            }
        }
    };

    Stream.prototype.onTradeUnsubscribeResponse = function onTradeUnsubscribeResponse(msg) {
        var tradeSub = this.pendingTradeUnsubscription[msg.__id];
        var callback = tradeSub.callback;

        (0, _utils.removeFromArray)(tradeSub.id, msg.__id);
        delete this.pendingTradeUnsubscription[msg.__id];

        console.log(msg);
        if (msg.code != 200 && !tradeSub.failed) {
            tradeSub.failed = true;
            var event = events.error("Error unsubscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                tradeSub.callback(event);
            }
            return;
        }

        var result = tradeSub.result;

        if (msg.notificationType) {
            this.log.debug('Trade ' + msg.notificationType);
            result.notificationType = msg.notificationType;
        }

        if (tradeSub.id.length === 0) {
            if (callback) {
                callback(null, tradeSub.result);
            }
        }
    };

    Stream.prototype.onNewsCmdFilterRefreshResponse = function onNewsCmdFilterRefreshResponse(msg) {
        console.log("msg", msg);
        if (msg.code != 200) {
            var event = events.error("Error Refreshing News Filters", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            return;
        }

        this.events.fire("msg", msg);
    };

    Stream.prototype.onNewsCmdFilterResponse = function onNewsCmdFilterResponse(msg) {
        console.log("msg", msg);
        if (msg.code != 200) {
            var event = events.error("Error Getting News Filters Status", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            return;
        }

        this.events.fire("filter status", msg);
    };

    Stream.prototype.onUnsubscribeResponse = function onUnsubscribeResponse(msg) {
        var unsubscription = this.pendingUnsubscriptions[msg.__id];
        var callback = unsubscription.callback;

        (0, _utils.removeFromArray)(unsubscription.ids, msg.__id);
        delete this.pendingUnsubscriptions[msg.__id];

        if (msg.code != 200 && !unsubscription.failed) {
            unsubscription.failed = true;
            var event = events.error("Error unsubscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        for (var index = 0; index < msg.unsubscribed.length; ++index) {
            var result = unsubscription.result;

            var unsubscribe = msg.unsubscribed[index];
            var _symbol = unsubscribe.symbol;
            var _datatype = unsubscribe.marketdatatype;
            this.log.debug('UNSUBSCRIBED <' + _symbol + ', ' + _datatype + '>');
            result.unsubscribed.push({ symbol: _symbol, type: _datatype });
        }

        if (unsubscription.ids.length === 0 && !unsubscription.failed) {
            if (callback) {
                callback(null, unsubscription.result);
            }
        }
    };

    Stream.prototype.onExchangeUnsubscribeResponse = function onExchangeUnsubscribeResponse(msg) {
        var exchangeSub = this.pendingExchangeUnsubscriptions[msg.__id];
        var callback = exchangeSub.callback;

        (0, _utils.removeFromArray)(exchangeSub.id, msg.__id);
        delete this.pendingExchangeUnsubscriptions[msg.__id];

        console.log(msg);
        if (msg.code != 200) {
            var event = events.error("Error unsubscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                exchangeSub.callback(event);
            }
            return;
        }
        if (exchangeSub.id.length === 0) {
            if (callback) {
                callback(null, exchangeSub);
            }
        }
    };

    Stream.prototype.onReconnectMessage = function onReconnectMessage(msg) {
        if (msg.code === 450) {
            this.events.fire("slow", "Reconnection recieved a slow code: " + msg.code);
            this._isSlowConnection = true;
            this.conn.setReconnect = false;
        }
        this.events.fire("reconnectMessage", msg);
        console.log(msg);
    };

    Stream.prototype.onConnectResponse = function onConnectResponse(msg) {
        if (msg.code !== 200) {
            var event = events.error("Connection failed", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (this.pendingConnection) {
                this.pendingConnection(event);
            }
            this.doClose(event);
            return;
        }

        this._serverversion = msg.version;
        this.flowControl.checkinterval = msg.flowControlCheckInterval;
        this.maxEntitlementsPerSubscription = msg.maxEntitlementsPerSubscription;
        if (this.isClosed()) {
            var _event = events.error("Connection was already closed", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", _event);
            if (this.pendingConnection) {
                this.pendingConnection(_event);
            }
            return;
        }
        this.conn.setServer(msg.serverInstance);
        if (this.pendingConnection) {
            this.pendingConnection(null, this);
        }
    };

    Stream.prototype.onConnectionClose = function onConnectionClose(msg) {
        this.doClose(events.close({
            reason: msg.reason,
            code: msg.code
        }));
    };

    Stream.prototype.onSlowConnection = function onSlowConnection(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("slow", msg);
    };

    Stream.prototype.onStatsResponse = function onStatsResponse(msg) {
        if (msg.code != 200) {
            var event = events.error("Error getting stats", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            return;
        }
        ;
        this.events.fire("stats", msg);
    };

    Stream.prototype.onInitialDataSent = function onInitialDataSent(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("initialDataSent", msg);
    };

    Stream.prototype.onResubscribeMessage = function onResubscribeMessage(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("resubscribeMessage", msg);
    };

    Stream.prototype.onMissedDataSent = function onMissedDataSent(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("missedDataSent", msg);
    };

    Stream.prototype._handledatamsg = function _handledatamsg(msg) {
        this.events.fire("message", msg);
    };

    Stream.prototype.send = function send(msg) {
        if (this.conn) {
            msg.sequenceNumber = this.flowControl.next();
            this.conn.send(msg);
        }
    };

    Stream.prototype.doClose = function doClose(msg) {
        if (!this.isClosed()) {
            var conn = this.conn;
            this.conn = null;
            conn.close();
            this.events.fire("close", msg);
            if (conn.isReconnect()) {
                //Will need to reset the events since they duplicate each time it reconnects.
                this.events = new _EventSupport2["default"]();
                this.conn = conn;
            }
        }
    };

    Stream.prototype.performReconnect = function performReconnect(callback) {
        if (this.conn != null && this.conn.isReconnect()) {
            if (this.conn.isConnectionUp) {
                this.log.warn("Connection is not closed and won't try reconnect.");
                return;
            }
            this.conn.setReconnect(true);
            this.conn.tryReopen();
            if (callback) {
                callback();
            }
        } else {
            this.log.warn("Reconnect flag is set to false");
        }
    };

    Stream.prototype.close = function close(callback) {
        this.doClose(events.close({
            reason: "Manually closed",
            code: 200
        }));
        if (callback) {
            callback();
        }
    };

    Stream.prototype.isClosed = function isClosed() {
        return this.conn == null;
    };

    return Stream;
}();

exports["default"] = Stream;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/Stream.js","/lib")
},{"./EventSupport.js":2,"./FlowControl.js":3,"./UShortId.js":9,"./formatting.js":13,"./logging.js":16,"./polyfills.js":18,"./streamer-api.js":108,"./streamer-events.js":109,"./streamer-utils.js":110,"./utils.js":115,"_process":131,"buffer":121,"timers":152}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _atmosphere = require("./atmosphere.js/lib/atmosphere.js");

var _atmosphere2 = _interopRequireDefault(_atmosphere);

var _http = require("./http.js");

var _http2 = _interopRequireDefault(_http);

var _AuthService = require("./auth/AuthService.js");

var _logging = require("./logging.js");

var _EnduserAuthService = require("./auth/EnduserAuthService.js");

var _EnduserAuthService2 = _interopRequireDefault(_EnduserAuthService);

require("./polyfills.js");

var _StreamingService = require("./StreamingService.js");

var _StreamingService2 = _interopRequireDefault(_StreamingService);

var _StompStreamingService = require("./stomp/StompStreamingService.js");

var _StompStreamingService2 = _interopRequireDefault(_StompStreamingService);

var _stomp = require("./stomp.js/lib/stomp.js");

var _stomp2 = _interopRequireDefault(_stomp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Streamer = {};

var logger = void 0;

function initLogger() {
    if (!logger) {
        logger = (0, _logging.asLogger)(Streamer.logger);

        _atmosphere2["default"].util.log = function (level, args) {
            logger.log.apply(logger, [level].concat(Array.from(args)));
        };
    }
}

Object.assign(Streamer, {
    login: function login(config, callback) {
        var authService = new _EnduserAuthService2["default"](_http2["default"], config);
        authService.login(callback);
    },

    open: function open(_config, callback) {
        initLogger();

        var credentials = void 0;
        try {
            credentials = (0, _AuthService.asCredentials)(_config.credentials);
        } catch (e) {
            callback(e);
            return;
        }

        var config = Object.assign({}, _config);
        config.credentials = credentials;
        // Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
        config.format = config.format || "application/json";

        new _StreamingService2["default"](_http2["default"], _atmosphere2["default"], logger, config).openStream(callback);
    },

    openStomp: function openStomp(_config, callback) {
        initLogger();

        var credentials = void 0;
        try {
            credentials = (0, _AuthService.asCredentials)(_config.credentials);
        } catch (e) {
            callback(e);
            return;
        }

        var hostProtocol = _config.host.split('//');
        var wsProtocol = hostProtocol[0] === "http:" ? "ws://" : "wss://";
        var config = Object.assign({}, _config);
        config.credentials = credentials;
        config.format = config.format || "application/json";
        config.url = wsProtocol + hostProtocol[1];

        new _StompStreamingService2["default"](_http2["default"], _stomp2["default"], logger, config).openStompStream(callback);
    },

    ping: function ping(host, callback) {
        new _StreamingService2["default"](_http2["default"], _atmosphere2["default"], logger, { host: host }).ping(callback);
    },

    getServerVersion: function getServerVersion(host, callback) {
        new _StreamingService2["default"](_http2["default"], _atmosphere2["default"], logger, { host: host }).getVersion(callback);
    }
});

exports["default"] = Streamer;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/Streamer.js","/lib")
},{"./StreamingService.js":8,"./atmosphere.js/lib/atmosphere.js":10,"./auth/AuthService.js":11,"./auth/EnduserAuthService.js":12,"./http.js":14,"./logging.js":16,"./polyfills.js":18,"./stomp.js/lib/stomp.js":104,"./stomp/StompStreamingService.js":107,"_process":131,"buffer":121,"timers":152}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

require("./polyfills.js");

var _logging = require("./logging.js");

var _streamerApi = require("./streamer-api.js");

var _message = require("./message.js");

var _SMessageDecoder = require("./serialization/SMessageDecoder.js");

var _SMessageDecoder2 = _interopRequireDefault(_SMessageDecoder);

var _SMessageEncoder = require("./serialization/SMessageEncoder.js");

var _SMessageEncoder2 = _interopRequireDefault(_SMessageEncoder);

var _SMessageTransmitter = require("./transmission/SMessageTransmitter.js");

var _SMessageTransmitter2 = _interopRequireDefault(_SMessageTransmitter);

var _JsonTransmitter = require("./transmission/JsonTransmitter.js");

var _JsonTransmitter2 = _interopRequireDefault(_JsonTransmitter);

var _Connection = require("./Connection.js");

var _Connection2 = _interopRequireDefault(_Connection);

var _Stream = require("./Stream.js");

var _Stream2 = _interopRequireDefault(_Stream);

var _QitchTransmitter = require("./transmission/QitchTransmitter.js");

var _QitchTransmitter2 = _interopRequireDefault(_QitchTransmitter);

var _QitchEncoder = require("./qitch/encoder/QitchEncoder");

var _QitchEncoder2 = _interopRequireDefault(_QitchEncoder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var STREAMURLS = {
    "ping": "/ping/v1",
    "version": "/version/v1",
    "stream": "/stream/v1"
};

var StreamingService = function () {
    function StreamingService(http, atmosphere, log, config) {
        var _this = this;

        _classCallCheck(this, StreamingService);

        this.http = http;
        this.atmo = atmosphere;
        this.log = (0, _logging.asLogger)(log);
        this.config = config || {};
        this.maxReconnectAttempts = this.config.maxReconnectAttempts;

        this.format = this.config.format;
        if (this.config.format === 'application/json') {
            this.createTransmitter = function (socket) {
                return new _JsonTransmitter2["default"](socket, _this.log);
            };
        } else if (this.config.format === 'application/qitch') {
            // Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
            var encoder = new _QitchEncoder2["default"]();
            this.createTransmitter = function (socket) {
                return new _QitchTransmitter2["default"](socket, encoder, _this.log);
            };
            this.format = _message.MimeTypes.QITCH;
        } else {
            var _encoder = new _SMessageEncoder2["default"]();
            var decoder = new _SMessageDecoder2["default"]();
            this.createTransmitter = function (socket) {
                return new _SMessageTransmitter2["default"](socket, _encoder, decoder, _this.log);
            };
            if (this.config.format === "application/json/legacy") {
                this.format = _message.MimeTypes.JSON;
            }
        }
    }

    StreamingService.prototype.openSocket = function openSocket(handlers, connectionId) {
        var headers = {
            'X-Stream-Version': _streamerApi.VERSION,
            'X-Stream-Lib': _streamerApi.LIBRARY_NAME
        };

        var _conflation = this.config.conflation;
        if (_conflation != null && _conflation !== '') {
            headers['X-Stream-Conflation'] = _conflation;
        }

        var _intervalPeriod = this.config.intervalPeriod;
        if (_intervalPeriod != null && _intervalPeriod !== '') {
            headers['X-Stream-Interval-Period'] = _intervalPeriod;
        }

        if (connectionId != null && connectionId !== '') {
            headers['X-Stream-Previous-Connection-Id'] = connectionId;
        }
        var _rejectExcessiveConnection = this.config.rejectExcessiveConnection;
        if (_rejectExcessiveConnection != null && _rejectExcessiveConnection !== '') {
            headers['X-Stream-Reject'] = _rejectExcessiveConnection;
        }

        if (this.config.format === 'application/json' || this.config.format === _message.MimeTypes.QITCH) {
            headers['X-Stream-Format'] = this.format;
        }

        if (this.format === _message.MimeTypes.QITCH) {
            headers["X-Atmosphere-Binary"] = true;
            headers["X-atmo-protocol"] = false;
        }

        if (this.config.updatesOnly === 'true') {
            headers['X-Stream-UpdatesOnly'] = true;
        }

        var _isReconnect = this.config.isReconnect;
        if (_isReconnect != null && _isReconnect !== '') {
            headers['x-Stream-isReconnect'] = _isReconnect;
        }

        var _alwaysReconnect = this.config.alwaysReconnect;
        if (_alwaysReconnect != null && _alwaysReconnect !== '') {
            headers['x-Stream-isAlwaysReopen'] = _alwaysReconnect;
        }

        if (this.config.isMissedData === 'ALL') {
            headers['X-Stream-isReceiveAllMissedData'] = true;
        } else if (this.config.isMissedData === 'LATEST') {
            headers['X-Stream-isReceiveLatestMissedData'] = true;
        }

        var _connectionFrom = this.config.connectionFrom;
        if (_connectionFrom != null) {
            headers['X-Stream-connectionFrom'] = _connectionFrom;
        }

        Object.assign(headers, this.config.credentials.getHeaders());

        var request = {
            url: this.config.host + STREAMURLS.stream,
            transport: this.config.transport || "websocket",
            fallbackTransport: this.config.fallbackTransport || "streaming",
            enableXDR: this.config.cors === true,
            trackMessageLength: !headers["X-Atmosphere-Binary"],
            headers: headers,
            maxReconnectOnClose: 1,
            reconnectInterval: 1000,
            closeAsync: true,
            connectTimeout: 60000
        };
        Object.assign(request, handlers(request));
        var subscription = this.atmo.subscribe(request);
        return {
            push: function push(msg) {
                subscription.push(msg);
            },
            close: function close() {
                subscription.close();
            }
        };
    };

    StreamingService.prototype.createConnection = function createConnection() {
        var _this2 = this;

        return new _Connection2["default"](function (socket) {
            return _this2.createTransmitter(socket);
        }, function (handlers, connectionId) {
            return _this2.openSocket(handlers, connectionId);
        }, this.log, this.maxReconnectAttempts);
    };

    StreamingService.prototype.openStream = function openStream(callback) {
        var stream = new _Stream2["default"](this, this.format, this.log);
        stream.open(callback);
    };

    StreamingService.prototype.ping = function ping(callback) {
        this.http({
            url: this.config.host + STREAMURLS.ping,
            success: function success(result) {
                return callback(null, result);
            },
            type: "GET",
            failure: callback
        });
    };

    StreamingService.prototype.getVersion = function getVersion(callback) {
        this.http({
            url: this.config.host + STREAMURLS.version,
            success: function success(result) {
                return callback(null, result);
            },
            type: 'GET',
            failure: callback
        });
    };

    return StreamingService;
}();

exports["default"] = StreamingService;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/StreamingService.js","/lib")
},{"./Connection.js":1,"./Stream.js":6,"./logging.js":16,"./message.js":17,"./polyfills.js":18,"./qitch/encoder/QitchEncoder":76,"./serialization/SMessageDecoder.js":99,"./serialization/SMessageEncoder.js":100,"./streamer-api.js":108,"./transmission/JsonTransmitter.js":112,"./transmission/QitchTransmitter.js":113,"./transmission/SMessageTransmitter.js":114,"_process":131,"buffer":121,"timers":152}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UShortId = function () {
    function UShortId() {
        _classCallCheck(this, UShortId);

        this.val = UShortId.MIN_VALUE;
    }

    UShortId.prototype.next = function next() {
        var _current = this.val;
        if (_current < UShortId.MAX_VALUE) {
            this.val++;
        } else {
            this.val = UShortId.MIN_VALUE;
        }
        return _current;
    };

    return UShortId;
}();

UShortId.NULL = 0;
UShortId.MIN_VALUE = 1;
UShortId.MAX_VALUE = 65535; // 2^16-1

exports["default"] = UShortId;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/UShortId.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 * Copyright 2015 Async-IO.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Added binary message processing that reads from the blob.
 * Tweaked implementation to support binary messages with streaming protocol:
 * - edited message calculation logic to support multiple messages that could be read from stream at once
 * without message size being pre-appended;
 * - override mimetype to be able to retrieve original byte array;
 * - don't trim string representation of binary messages.
 */
/**
 * Atmosphere.js
 * https://github.com/Atmosphere/atmosphere-javascript
 *
 * API reference
 * https://github.com/Atmosphere/atmosphere/wiki/jQuery.atmosphere.js-API
 *
 * Highly inspired by
 * - Portal by Donghwan Kim http://flowersinthesand.github.io/portal/
 */
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD
        define(factory);
    } else if (typeof exports !== 'undefined') {
        // CommonJS
        module.exports = factory();
    } else {
        // Browser globals, Window
        root.atmosphere = factory();
    }
})(undefined, function () {

    "use strict";

    var atmosphere = {},
        guid,
        _offline = false,
        requests = [],
        callbacks = [],
        uuid = 0,
        hasOwn = Object.prototype.hasOwnProperty;

    atmosphere = {
        version: "2.3.3-javascript",
        onError: function onError(response) {},
        onClose: function onClose(response) {},
        onOpen: function onOpen(response) {},
        onReopen: function onReopen(response) {},
        onMessage: function onMessage(response) {},
        onReconnect: function onReconnect(request, response) {},
        onMessagePublished: function onMessagePublished(response) {},
        onTransportFailure: function onTransportFailure(errorMessage, _request) {},
        onLocalMessage: function onLocalMessage(response) {},
        onFailureToReconnect: function onFailureToReconnect(request, response) {},
        onClientTimeout: function onClientTimeout(request) {},
        onOpenAfterResume: function onOpenAfterResume(request) {},

        /**
         * Creates an object based on an atmosphere subscription that exposes functions defined by the Websocket interface.
         *
         * @class WebsocketApiAdapter
         * @param {Object} request the request object to build the underlying subscription
         * @constructor
         */
        WebsocketApiAdapter: function WebsocketApiAdapter(request) {
            var _socket, _adapter;

            /**
             * Overrides the onMessage callback in given request.
             *
             * @method onMessage
             * @param {Object} e the event object
             */
            request.onMessage = function (e) {
                _adapter.onmessage({ data: e.responseBody });
            };

            /**
             * Overrides the onMessagePublished callback in given request.
             *
             * @method onMessagePublished
             * @param {Object} e the event object
             */
            request.onMessagePublished = function (e) {
                _adapter.onmessage({ data: e.responseBody });
            };

            /**
             * Overrides the onOpen callback in given request to proxy the event to the adapter.
             *
             * @method onOpen
             * @param {Object} e the event object
             */
            request.onOpen = function (e) {
                _adapter.onopen(e);
            };

            _adapter = {
                close: function close() {
                    _socket.close();
                },

                send: function send(data) {
                    _socket.push(data);
                },

                onmessage: function onmessage(e) {},

                onopen: function onopen(e) {},

                onclose: function onclose(e) {},

                onerror: function onerror(e) {}
            };
            _socket = new atmosphere.subscribe(request);

            return _adapter;
        },

        AtmosphereRequest: function AtmosphereRequest(options) {

            /**
             * {Object} Request parameters.
             *
             * @private
             */
            var _request = {
                timeout: 300000,
                method: 'GET',
                headers: {},
                contentType: '',
                callback: null,
                url: '',
                data: '',
                suspend: true,
                maxRequest: -1,
                reconnect: true,
                maxStreamingLength: 10000000,
                lastIndex: 0,
                logLevel: 'info',
                requestCount: 0,
                fallbackMethod: 'GET',
                fallbackTransport: 'streaming',
                transport: 'long-polling',
                webSocketImpl: null,
                webSocketBinaryType: null,
                dispatchUrl: null,
                webSocketPathDelimiter: "@@",
                enableXDR: false,
                rewriteURL: false,
                attachHeadersAsQueryString: true,
                executeCallbackBeforeReconnect: false,
                readyState: 0,
                withCredentials: true,
                trackMessageLength: false,
                messageDelimiter: '|',
                connectTimeout: -1,
                reconnectInterval: 0,
                dropHeaders: true,
                uuid: 0,
                async: true,
                shared: false,
                readResponsesHeaders: false,
                maxReconnectOnClose: 5,
                enableProtocol: true,
                disableDisconnect: false,
                pollingInterval: 0,
                heartbeat: {
                    client: null,
                    server: null
                },
                ackInterval: 0,
                closeAsync: false,
                reconnectOnServerError: true,
                handleOnlineOffline: true,
                onError: function onError(response) {},
                onClose: function onClose(response) {},
                onOpen: function onOpen(response) {},
                onMessage: function onMessage(response) {},
                onReopen: function onReopen(request, response) {},
                onReconnect: function onReconnect(request, response) {},
                onMessagePublished: function onMessagePublished(response) {},
                onTransportFailure: function onTransportFailure(reason, request) {},
                onLocalMessage: function onLocalMessage(request) {},
                onFailureToReconnect: function onFailureToReconnect(request, response) {},
                onClientTimeout: function onClientTimeout(request) {},
                onOpenAfterResume: function onOpenAfterResume(request) {}
            };

            /**
             * {Object} Request's last response.
             *
             * @private
             */
            var _response = {
                status: 200,
                reasonPhrase: "OK",
                responseBody: '',
                messages: [],
                headers: [],
                state: "messageReceived",
                transport: "polling",
                error: null,
                request: null,
                partialMessage: "",
                errorHandled: false,
                closedByClientTimeout: false,
                ffTryingReconnect: false
            };

            /**
             * {websocket} Opened web socket.
             *
             * @private
             */
            var _websocket = null;

            /**
             * {SSE} Opened SSE.
             *
             * @private
             */
            var _sse = null;

            /**
             * {XMLHttpRequest, ActiveXObject} Opened ajax request (in case of http-streaming or long-polling)
             *
             * @private
             */
            var _activeRequest = null;

            /**
             * {Object} Object use for streaming with IE.
             *
             * @private
             */
            var _ieStream = null;

            /**
             * {Object} Object use for jsonp transport.
             *
             * @private
             */
            var _jqxhr = null;

            /**
             * {boolean} If request has been subscribed or not.
             *
             * @private
             */
            var _subscribed = true;

            /**
             * {number} Number of test reconnection.
             *
             * @private
             */
            var _requestCount = 0;

            /**
             * The Heartbeat interval send by the server.
             * @type {int}
             * @private
             */
            var _heartbeatInterval = 0;

            /**
             * The Heartbeat bytes send by the server.
             * @type {string}
             * @private
             */
            var _heartbeatPadding = 'X';

            /**
             * {boolean} If request is currently aborted.
             *
             * @private
             */
            var _abortingConnection = false;

            /**
             * A local "channel' of communication.
             *
             * @private
             */
            var _localSocketF = null;

            /**
             * The storage used.
             *
             * @private
             */
            var _storageService;

            /**
             * Local communication
             *
             * @private
             */
            var _localStorageService = null;

            /**
             * A Unique ID
             *
             * @private
             */
            var guid = atmosphere.util.now();

            /** Trace time */
            var _traceTimer;

            /** Key for connection sharing */
            var _sharingKey;

            /**
             * {boolean} If window beforeUnload event has been called.
             * Flag will be reset after 5000 ms
             *
             * @private
             */
            var _beforeUnloadState = false;

            // Automatic call to subscribe
            _subscribe(options);

            /**
             * Initialize atmosphere request object.
             *
             * @private
             */
            function _init() {
                _subscribed = true;
                _abortingConnection = false;
                _requestCount = 0;

                _websocket = null;
                _sse = null;
                _activeRequest = null;
                _ieStream = null;
            }

            /**
             * Re-initialize atmosphere object.
             *
             * @private
             */
            function _reinit() {
                _clearState();
                _init();
            }

            /**
             * Returns true if the given level is equal or above the configured log level.
             *
             * @private
             */
            function _canLog(level) {
                if (level == 'debug') {
                    return _request.logLevel === 'debug';
                } else if (level == 'info') {
                    return _request.logLevel === 'info' || _request.logLevel === 'debug';
                } else if (level == 'warn') {
                    return _request.logLevel === 'warn' || _request.logLevel === 'info' || _request.logLevel === 'debug';
                } else if (level == 'error') {
                    return _request.logLevel === 'error' || _request.logLevel === 'warn' || _request.logLevel === 'info' || _request.logLevel === 'debug';
                } else {
                    return false;
                }
            }

            function _debug(msg) {
                if (_canLog('debug')) {
                    atmosphere.util.debug(new Date() + " Atmosphere: " + msg);
                }
            }

            /**
             *
             * @private
             */
            function _verifyStreamingLength(ajaxRequest, rq) {
                // Wait to be sure we have the full message before closing.
                if (_response.partialMessage === "" && rq.transport === 'streaming' && ajaxRequest.responseText.length > rq.maxStreamingLength) {
                    return true;
                }
                return false;
            }

            /**
             * Disconnect
             *
             * @private
             */
            function _disconnect() {
                if (_request.enableProtocol && !_request.disableDisconnect && !_request.firstMessage) {
                    var query = "X-Atmosphere-Transport=close&X-Atmosphere-tracking-id=" + _request.uuid;

                    atmosphere.util.each(_request.headers, function (name, value) {
                        var h = atmosphere.util.isFunction(value) ? value.call(this, _request, _request, _response) : value;
                        if (h != null) {
                            query += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                        }
                    });

                    var url = _request.url.replace(/([?&])_=[^&]*/, query);
                    url = url + (url === _request.url ? (/\?/.test(_request.url) ? "&" : "?") + query : "");

                    var rq = {
                        connected: false
                    };
                    var closeR = new atmosphere.AtmosphereRequest(rq);
                    closeR.connectTimeout = _request.connectTimeout;
                    closeR.attachHeadersAsQueryString = false;
                    closeR.dropHeaders = true;
                    closeR.url = url;
                    closeR.contentType = "text/plain";
                    closeR.transport = 'polling';
                    closeR.method = 'GET';
                    closeR.data = '';
                    closeR.heartbeat = null;
                    if (_request.enableXDR) {
                        closeR.enableXDR = _request.enableXDR;
                    }
                    closeR.async = _request.closeAsync;
                    _pushOnClose("", closeR);
                }
            }

            /**
             * Close request.
             *
             * @private
             */
            function _close() {
                _debug("Closing (AtmosphereRequest._close() called)");

                _abortingConnection = true;
                if (_request.reconnectId) {
                    clearTimeout(_request.reconnectId);
                    delete _request.reconnectId;
                }

                if (_request.heartbeatTimer) {
                    clearTimeout(_request.heartbeatTimer);
                }

                _request.reconnect = false;
                _response.request = _request;
                _response.state = 'unsubscribe';
                _response.responseBody = "";
                _response.status = 408;
                _response.partialMessage = "";
                _invokeCallback();
                _disconnect();
                _clearState();
            }

            function _clearState() {
                _response.partialMessage = "";
                if (_request.id) {
                    clearTimeout(_request.id);
                }

                if (_request.heartbeatTimer) {
                    clearTimeout(_request.heartbeatTimer);
                }

                // https://github.com/Atmosphere/atmosphere/issues/1860#issuecomment-74707226
                if (_request.reconnectId) {
                    clearTimeout(_request.reconnectId);
                    delete _request.reconnectId;
                }

                if (_ieStream != null) {
                    _ieStream.close();
                    _ieStream = null;
                }
                if (_jqxhr != null) {
                    _jqxhr.abort();
                    _jqxhr = null;
                }
                if (_activeRequest != null) {
                    _activeRequest.abort();
                    _activeRequest = null;
                }
                if (_websocket != null) {
                    if (_websocket.canSendMessage) {
                        _debug("invoking .close() on WebSocket object");
                        _websocket.close();
                    }
                    _websocket = null;
                }
                if (_sse != null) {
                    _sse.close();
                    _sse = null;
                }
                _clearStorage();
            }

            function _clearStorage() {
                // Stop sharing a connection
                if (_storageService != null) {
                    // Clears trace timer
                    clearInterval(_traceTimer);
                    // Removes the trace
                    document.cookie = _sharingKey + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
                    // The heir is the parent unless unloading
                    _storageService.signal("close", {
                        reason: "",
                        heir: !_abortingConnection ? guid : (_storageService.get("children") || [])[0]
                    });
                    _storageService.close();
                }
                if (_localStorageService != null) {
                    _localStorageService.close();
                }
            }

            /**
             * Subscribe request using request transport. <br>
             * If request is currently opened, this one will be closed.
             *
             * @param {Object} Request parameters.
             * @private
             */
            function _subscribe(options) {
                _reinit();

                _request = atmosphere.util.extend(_request, options);
                // Allow at least 1 request
                _request.mrequest = _request.reconnect;
                if (!_request.reconnect) {
                    _request.reconnect = true;
                }
            }

            /**
             * Check if web socket is supported (check for custom implementation provided by request object or browser implementation).
             *
             * @returns {boolean} True if web socket is supported, false otherwise.
             * @private
             */
            function _supportWebsocket() {
                return _request.webSocketImpl != null || window.WebSocket || window.MozWebSocket;
            }

            /**
             * Check if server side events (SSE) is supported (check for custom implementation provided by request object or browser implementation).
             *
             * @returns {boolean} True if web socket is supported, false otherwise.
             * @private
             */
            function _supportSSE() {
                // Origin parts
                var url = atmosphere.util.getAbsoluteURL(_request.url.toLowerCase());
                var parts = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/.exec(url);
                var crossOrigin = !!(parts && (
                // protocol
                parts[1] != window.location.protocol ||
                // hostname
                parts[2] != window.location.hostname ||
                // port
                (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (window.location.port || (window.location.protocol === "http:" ? 80 : 443))));
                return window.EventSource && (!crossOrigin || !atmosphere.util.browser.safari || atmosphere.util.browser.vmajor >= 7);
            }

            /**
             * Open request using request transport. <br>
             * If request transport is 'websocket' but websocket can't be opened, request will automatically reconnect using fallback transport.
             *
             * @private
             */
            function _execute() {
                // Shared across multiple tabs/windows.
                if (_request.shared) {
                    _localStorageService = _local(_request);
                    if (_localStorageService != null) {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Storage service available. All communication will be local");
                        }

                        if (_localStorageService.open(_request)) {
                            // Local connection.
                            return;
                        }
                    }

                    if (_canLog('debug')) {
                        atmosphere.util.debug("No Storage service available.");
                    }
                    // Wasn't local or an error occurred
                    _localStorageService = null;
                }

                // Protocol
                _request.firstMessage = uuid == 0 ? true : false;
                _request.isOpen = false;
                _request.ctime = atmosphere.util.now();

                // We carry any UUID set by the user or from a previous connection.
                if (_request.uuid === 0) {
                    _request.uuid = uuid;
                }
                _response.closedByClientTimeout = false;

                if (_request.transport !== 'websocket' && _request.transport !== 'sse') {
                    _executeRequest(_request);
                } else if (_request.transport === 'websocket') {
                    if (!_supportWebsocket()) {
                        _reconnectWithFallbackTransport("Websocket is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")");
                    } else {
                        _executeWebSocket(false);
                    }
                } else if (_request.transport === 'sse') {
                    if (!_supportSSE()) {
                        _reconnectWithFallbackTransport("Server Side Events(SSE) is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")");
                    } else {
                        _executeSSE(false);
                    }
                }
            }

            function _local(request) {
                var trace,
                    connector,
                    orphan,
                    name = "atmosphere-" + request.url,
                    connectors = {
                    storage: function storage() {
                        function onstorage(event) {
                            if (event.key === name && event.newValue) {
                                listener(event.newValue);
                            }
                        }

                        if (!atmosphere.util.storage) {
                            return;
                        }

                        var storage = window.localStorage,
                            get = function get(key) {
                            var item = storage.getItem(name + "-" + key);
                            return item === null ? [] : atmosphere.util.parseJSON(item);
                        },
                            set = function set(key, value) {
                            storage.setItem(name + "-" + key, atmosphere.util.stringifyJSON(value));
                        };

                        return {
                            init: function init() {
                                set("children", get("children").concat([guid]));
                                atmosphere.util.on(window, "storage", onstorage);
                                return get("opened");
                            },
                            signal: function signal(type, data) {
                                storage.setItem(name, atmosphere.util.stringifyJSON({
                                    target: "p",
                                    type: type,
                                    data: data
                                }));
                            },
                            close: function close() {
                                var children = get("children");

                                atmosphere.util.off(window, "storage", onstorage);
                                if (children) {
                                    if (removeFromArray(children, request.id)) {
                                        set("children", children);
                                    }
                                }
                            }
                        };
                    },
                    windowref: function windowref() {
                        var win = window.open("", name.replace(/\W/g, ""));

                        if (!win || win.closed || !win.callbacks) {
                            return;
                        }

                        return {
                            init: function init() {
                                win.callbacks.push(listener);
                                win.children.push(guid);
                                return win.opened;
                            },
                            signal: function signal(type, data) {
                                if (!win.closed && win.fire) {
                                    win.fire(atmosphere.util.stringifyJSON({
                                        target: "p",
                                        type: type,
                                        data: data
                                    }));
                                }
                            },
                            close: function close() {
                                // Removes traces only if the parent is alive
                                if (!orphan) {
                                    removeFromArray(win.callbacks, listener);
                                    removeFromArray(win.children, guid);
                                }
                            }

                        };
                    }
                };

                function removeFromArray(array, val) {
                    var i,
                        length = array.length;

                    for (i = 0; i < length; i++) {
                        if (array[i] === val) {
                            array.splice(i, 1);
                        }
                    }

                    return length !== array.length;
                }

                // Receives open, close and message command from the parent
                function listener(string) {
                    var command = atmosphere.util.parseJSON(string),
                        data = command.data;

                    if (command.target === "c") {
                        switch (command.type) {
                            case "open":
                                _open("opening", 'local', _request);
                                break;
                            case "close":
                                if (!orphan) {
                                    orphan = true;
                                    if (data.reason === "aborted") {
                                        _close();
                                    } else {
                                        // Gives the heir some time to reconnect
                                        if (data.heir === guid) {
                                            _execute();
                                        } else {
                                            setTimeout(function () {
                                                _execute();
                                            }, 100);
                                        }
                                    }
                                }
                                break;
                            case "message":
                                _prepareCallback(data, "messageReceived", 200, request.transport);
                                break;
                            case "localMessage":
                                _localMessage(data);
                                break;
                        }
                    }
                }

                function findTrace() {
                    var matcher = new RegExp("(?:^|; )(" + encodeURIComponent(name) + ")=([^;]*)").exec(document.cookie);
                    if (matcher) {
                        return atmosphere.util.parseJSON(decodeURIComponent(matcher[2]));
                    }
                }

                // Finds and validates the parent socket's trace from the cookie
                trace = findTrace();
                if (!trace || atmosphere.util.now() - trace.ts > 1000) {
                    return;
                }

                // Chooses a connector
                connector = connectors.storage() || connectors.windowref();
                if (!connector) {
                    return;
                }

                return {
                    open: function open() {
                        var parentOpened;

                        // Checks the shared one is alive
                        _traceTimer = setInterval(function () {
                            var oldTrace = trace;
                            trace = findTrace();
                            if (!trace || oldTrace.ts === trace.ts) {
                                // Simulates a close signal
                                listener(atmosphere.util.stringifyJSON({
                                    target: "c",
                                    type: "close",
                                    data: {
                                        reason: "error",
                                        heir: oldTrace.heir
                                    }
                                }));
                            }
                        }, 1000);

                        parentOpened = connector.init();
                        if (parentOpened) {
                            // Firing the open event without delay robs the user of the opportunity to bind connecting event handlers
                            setTimeout(function () {
                                _open("opening", 'local', request);
                            }, 50);
                        }
                        return parentOpened;
                    },
                    send: function send(event) {
                        connector.signal("send", event);
                    },
                    localSend: function localSend(event) {
                        connector.signal("localSend", atmosphere.util.stringifyJSON({
                            id: guid,
                            event: event
                        }));
                    },
                    close: function close() {
                        // Do not signal the parent if this method is executed by the unload event handler
                        if (!_abortingConnection) {
                            clearInterval(_traceTimer);
                            connector.signal("close");
                            connector.close();
                        }
                    }
                };
            }

            function share() {
                var storageService,
                    name = "atmosphere-" + _request.url,
                    servers = {
                    // Powered by the storage event and the localStorage
                    // http://www.w3.org/TR/webstorage/#event-storage
                    storage: function storage() {
                        function onstorage(event) {
                            // When a deletion, newValue initialized to null
                            if (event.key === name && event.newValue) {
                                listener(event.newValue);
                            }
                        }

                        if (!atmosphere.util.storage) {
                            return;
                        }

                        var storage = window.localStorage;

                        return {
                            init: function init() {
                                // Handles the storage event
                                atmosphere.util.on(window, "storage", onstorage);
                            },
                            signal: function signal(type, data) {
                                storage.setItem(name, atmosphere.util.stringifyJSON({
                                    target: "c",
                                    type: type,
                                    data: data
                                }));
                            },
                            get: function get(key) {
                                return atmosphere.util.parseJSON(storage.getItem(name + "-" + key));
                            },
                            set: function set(key, value) {
                                storage.setItem(name + "-" + key, atmosphere.util.stringifyJSON(value));
                            },
                            close: function close() {
                                atmosphere.util.off(window, "storage", onstorage);
                                storage.removeItem(name);
                                storage.removeItem(name + "-opened");
                                storage.removeItem(name + "-children");
                            }

                        };
                    },
                    // Powered by the window.open method
                    // https://developer.mozilla.org/en/DOM/window.open
                    windowref: function windowref() {
                        // Internet Explorer raises an invalid argument error
                        // when calling the window.open method with the name containing non-word characters
                        var neim = name.replace(/\W/g, ""),
                            container = document.getElementById(neim),
                            win;

                        if (!container) {
                            container = document.createElement("div");
                            container.id = neim;
                            container.style.display = "none";
                            container.innerHTML = '<iframe name="' + neim + '" />';
                            document.body.appendChild(container);
                        }

                        win = container.firstChild.contentWindow;

                        return {
                            init: function init() {
                                // Callbacks from different windows
                                win.callbacks = [listener];
                                // In IE 8 and less, only string argument can be safely passed to the function in other window
                                win.fire = function (string) {
                                    var i;

                                    for (i = 0; i < win.callbacks.length; i++) {
                                        win.callbacks[i](string);
                                    }
                                };
                            },
                            signal: function signal(type, data) {
                                if (!win.closed && win.fire) {
                                    win.fire(atmosphere.util.stringifyJSON({
                                        target: "c",
                                        type: type,
                                        data: data
                                    }));
                                }
                            },
                            get: function get(key) {
                                return !win.closed ? win[key] : null;
                            },
                            set: function set(key, value) {
                                if (!win.closed) {
                                    win[key] = value;
                                }
                            },
                            close: function close() {}
                        };
                    }
                };

                // Receives send and close command from the children
                function listener(string) {
                    var command = atmosphere.util.parseJSON(string),
                        data = command.data;

                    if (command.target === "p") {
                        switch (command.type) {
                            case "send":
                                _push(data);
                                break;
                            case "localSend":
                                _localMessage(data);
                                break;
                            case "close":
                                _close();
                                break;
                        }
                    }
                }

                _localSocketF = function propagateMessageEvent(context) {
                    storageService.signal("message", context);
                };

                function leaveTrace() {
                    document.cookie = _sharingKey + "=" +
                    // Opera's JSON implementation ignores a number whose a last digit of 0 strangely
                    // but has no problem with a number whose a last digit of 9 + 1
                    encodeURIComponent(atmosphere.util.stringifyJSON({
                        ts: atmosphere.util.now() + 1,
                        heir: (storageService.get("children") || [])[0]
                    })) + "; path=/";
                }

                // Chooses a storageService
                storageService = servers.storage() || servers.windowref();
                storageService.init();

                if (_canLog('debug')) {
                    atmosphere.util.debug("Installed StorageService " + storageService);
                }

                // List of children sockets
                storageService.set("children", []);

                if (storageService.get("opened") != null && !storageService.get("opened")) {
                    // Flag indicating the parent socket is opened
                    storageService.set("opened", false);
                }
                // Leaves traces
                _sharingKey = encodeURIComponent(name);
                leaveTrace();
                _traceTimer = setInterval(leaveTrace, 1000);

                _storageService = storageService;
            }

            /**
             * @private
             */
            function _open(state, transport, request) {
                if (_request.shared && transport !== 'local') {
                    share();
                }

                if (_storageService != null) {
                    _storageService.set("opened", true);
                }

                request.close = function () {
                    _close();
                };

                if (_requestCount > 0 && state === 're-connecting') {
                    request.isReopen = true;
                    _tryingToReconnect(_response);
                } else if (_response.error == null) {
                    _response.request = request;
                    var prevState = _response.state;
                    _response.state = state;
                    var prevTransport = _response.transport;
                    _response.transport = transport;

                    var _body = _response.responseBody;
                    _invokeCallback();
                    _response.responseBody = _body;

                    _response.state = prevState;
                    _response.transport = prevTransport;
                }
            }

            /**
             * Execute request using jsonp transport.
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             * @private
             */
            function _jsonp(request) {
                // When CORS is enabled, make sure we force the proper transport.
                request.transport = "jsonp";

                var rq = _request,
                    script;
                if (request != null && typeof request !== 'undefined') {
                    rq = request;
                }

                _jqxhr = {
                    open: function open() {
                        var callback = "atmosphere" + ++guid;

                        function _reconnectOnFailure() {
                            rq.lastIndex = 0;

                            if (rq.openId) {
                                clearTimeout(rq.openId);
                            }

                            if (rq.heartbeatTimer) {
                                clearTimeout(rq.heartbeatTimer);
                            }

                            if (rq.reconnect && _requestCount++ < rq.maxReconnectOnClose) {
                                _open('re-connecting', rq.transport, rq);
                                _reconnect(_jqxhr, rq, request.reconnectInterval);
                                rq.openId = setTimeout(function () {
                                    _triggerOpen(rq);
                                }, rq.reconnectInterval + 1000);
                            } else {
                                _onError(0, "maxReconnectOnClose reached");
                            }
                        }

                        function poll() {
                            var url = rq.url;
                            if (rq.dispatchUrl != null) {
                                url += rq.dispatchUrl;
                            }

                            var data = rq.data;
                            if (rq.attachHeadersAsQueryString) {
                                url = _attachHeaders(rq);
                                if (data !== '') {
                                    url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(data);
                                }
                                data = '';
                            }

                            var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

                            script = document.createElement("script");
                            script.src = url + "&jsonpTransport=" + callback;
                            //script.async = rq.async;
                            script.clean = function () {
                                script.clean = script.onerror = script.onload = script.onreadystatechange = null;
                                if (script.parentNode) {
                                    script.parentNode.removeChild(script);
                                }

                                if (++request.scriptCount === 2) {
                                    request.scriptCount = 1;
                                    _reconnectOnFailure();
                                }
                            };
                            script.onload = script.onreadystatechange = function () {
                                _debug("jsonp.onload");
                                if (!script.readyState || /loaded|complete/.test(script.readyState)) {
                                    script.clean();
                                }
                            };

                            script.onerror = function () {
                                _debug("jsonp.onerror");
                                request.scriptCount = 1;
                                script.clean();
                            };

                            head.insertBefore(script, head.firstChild);
                        }

                        // Attaches callback
                        window[callback] = function (msg) {
                            _debug("jsonp.window");
                            request.scriptCount = 0;
                            if (rq.reconnect && rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest) {

                                // _readHeaders(_jqxhr, rq);
                                if (!rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }

                                if (msg != null && typeof msg !== 'string') {
                                    try {
                                        msg = msg.message;
                                    } catch (err) {
                                        // The message was partial
                                    }
                                }
                                var skipCallbackInvocation = _trackMessageSize(msg, rq, _response);
                                if (!skipCallbackInvocation) {
                                    _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                                }

                                if (rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }
                                _timeout(rq);
                            } else {
                                atmosphere.util.log(_request.logLevel, ["JSONP reconnect maximum try reached " + _request.requestCount]);
                                _onError(0, "maxRequest reached");
                            }
                        };
                        setTimeout(function () {
                            poll();
                        }, 50);
                    },
                    abort: function abort() {
                        if (script && script.clean) {
                            script.clean();
                        }
                    }
                };
                _jqxhr.open();
            }

            /**
             * Build websocket object.
             *
             * @param location {string} Web socket url.
             * @returns {websocket} Web socket object.
             * @private
             */
            function _getWebSocket(location) {
                if (_request.webSocketImpl != null) {
                    return _request.webSocketImpl;
                } else {
                    var ws;
                    if (window.WebSocket) {
                        ws = new WebSocket(location);
                    } else {
                        ws = new MozWebSocket(location);
                    }
                    return ws;
                }
            }

            /**
             * Build web socket url from request url.
             *
             * @return {string} Web socket url (start with "ws" or "wss" for secure web socket).
             * @private
             */
            function _buildWebSocketUrl() {
                return _attachHeaders(_request, atmosphere.util.getAbsoluteURL(_request.webSocketUrl || _request.url)).replace(/^http/, "ws");
            }

            /**
             * Build SSE url from request url.
             *
             * @return a url with Atmosphere's headers
             * @private
             */
            function _buildSSEUrl() {
                var url = _attachHeaders(_request);
                return url;
            }

            /**
             * Open SSE. <br>
             * Automatically use fallback transport if SSE can't be opened.
             *
             * @private
             */
            function _executeSSE(sseOpened) {

                _response.transport = "sse";

                var location = _buildSSEUrl();

                if (_canLog('debug')) {
                    atmosphere.util.debug("Invoking executeSSE");
                    atmosphere.util.debug("Using URL: " + location);
                }

                if (sseOpened && !_request.reconnect) {
                    if (_sse != null) {
                        _clearState();
                    }
                    return;
                }

                try {
                    _sse = new EventSource(location, {
                        withCredentials: _request.withCredentials
                    });
                } catch (e) {
                    _onError(0, e);
                    _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
                    return;
                }

                if (_request.connectTimeout > 0) {
                    _request.id = setTimeout(function () {
                        if (!sseOpened) {
                            _clearState();
                        }
                    }, _request.connectTimeout);
                }

                _sse.onopen = function (event) {
                    _debug("sse.onopen");
                    _timeout(_request);
                    if (_canLog('debug')) {
                        atmosphere.util.debug("SSE successfully opened");
                    }

                    if (!_request.enableProtocol) {
                        if (!sseOpened) {
                            _open('opening', "sse", _request);
                        } else {
                            _open('re-opening', "sse", _request);
                        }
                    } else if (_request.isReopen) {
                        _request.isReopen = false;
                        _open('re-opening', _request.transport, _request);
                    }

                    sseOpened = true;

                    if (_request.method === 'POST') {
                        _response.state = "messageReceived";
                        _sse.send(_request.data);
                    }
                };

                _sse.onmessage = function (message) {
                    _debug("sse.onmessage");
                    _timeout(_request);

                    if (!_request.enableXDR && window.location.host && message.origin && message.origin !== window.location.protocol + "//" + window.location.host) {
                        atmosphere.util.log(_request.logLevel, ["Origin was not " + window.location.protocol + "//" + window.location.host]);
                        return;
                    }

                    _response.state = 'messageReceived';
                    _response.status = 200;

                    message = message.data;
                    var skipCallbackInvocation = _trackMessageSize(message, _request, _response);

                    // https://github.com/remy/polyfills/blob/master/EventSource.js
                    // Since we polling.
                    /* if (_sse.URL) {
                     _sse.interval = 100;
                     _sse.URL = _buildSSEUrl();
                     } */

                    if (!skipCallbackInvocation) {
                        _invokeCallback();
                        _response.responseBody = '';
                        _response.messages = [];
                    }
                };

                _sse.onerror = function (message) {
                    _debug("sse.onerror");
                    clearTimeout(_request.id);

                    if (_request.heartbeatTimer) {
                        clearTimeout(_request.heartbeatTimer);
                    }

                    if (_response.closedByClientTimeout) {
                        return;
                    }

                    _invokeClose(sseOpened);
                    _clearState();

                    if (_abortingConnection) {
                        atmosphere.util.log(_request.logLevel, ["SSE closed normally"]);
                    } else if (!sseOpened) {
                        _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
                    } else if (_request.reconnect && _response.transport === 'sse') {
                        if (_requestCount++ < _request.maxReconnectOnClose) {
                            _open('re-connecting', _request.transport, _request);
                            if (_request.reconnectInterval > 0) {
                                _request.reconnectId = setTimeout(function () {
                                    _executeSSE(true);
                                }, _request.reconnectInterval);
                            } else {
                                _executeSSE(true);
                            }
                            _response.responseBody = "";
                            _response.messages = [];
                        } else {
                            atmosphere.util.log(_request.logLevel, ["SSE reconnect maximum try reached " + _requestCount]);
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };
            }

            /**
             * Open web socket. <br>
             * Automatically use fallback transport if web socket can't be opened.
             *
             * @private
             */
            function _executeWebSocket(webSocketOpened) {

                _response.transport = "websocket";

                var location = _buildWebSocketUrl(_request.url);
                if (_canLog('debug')) {
                    atmosphere.util.debug("Invoking executeWebSocket, using URL: " + location);
                }

                if (webSocketOpened && !_request.reconnect) {
                    if (_websocket != null) {
                        _clearState();
                    }
                    return;
                }

                _websocket = _getWebSocket(location);
                if (_request.webSocketBinaryType != null) {
                    _websocket.binaryType = _request.webSocketBinaryType;
                }

                if (_request.connectTimeout > 0) {
                    _request.id = setTimeout(function () {
                        if (!webSocketOpened) {
                            var _message = {
                                code: 1002,
                                reason: "",
                                wasClean: false
                            };
                            _websocket.onclose(_message);
                            // Close it anyway
                            try {
                                _clearState();
                            } catch (e) {}
                            return;
                        }
                    }, _request.connectTimeout);
                }

                _websocket.onopen = function (message) {
                    _debug("websocket.onopen");
                    _timeout(_request);
                    _offline = false;

                    if (_canLog('debug')) {
                        atmosphere.util.debug("Websocket successfully opened");
                    }

                    var reopening = webSocketOpened;

                    if (_websocket != null) {
                        _websocket.canSendMessage = true;
                    }

                    if (!_request.enableProtocol) {
                        webSocketOpened = true;
                        if (reopening) {
                            _open('re-opening', "websocket", _request);
                        } else {
                            _open('opening', "websocket", _request);
                        }
                    }

                    if (_websocket != null) {
                        if (_request.method === 'POST') {
                            _response.state = "messageReceived";
                            _websocket.send(_request.data);
                        }
                    }
                };

                _websocket.onmessage = function (message) {
                    _debug("websocket.onmessage");
                    _timeout(_request);

                    // We only consider it opened if we get the handshake data
                    // https://github.com/Atmosphere/atmosphere-javascript/issues/74
                    if (_request.enableProtocol) {
                        webSocketOpened = true;
                    }

                    _response.state = 'messageReceived';
                    _response.status = 200;

                    message = message.data;
                    var isString = typeof message === 'string';
                    if (isString) {
                        var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
                        if (!skipCallbackInvocation) {
                            _invokeCallback();
                            _response.responseBody = '';
                            _response.messages = [];
                        }
                    } else {
                        if (_request.firstMessage) {
                            _handleProtocolAsync(_request, message, function (message) {
                                if (message === "") return;

                                _response.responseBody = message;
                                _invokeCallback();
                                _response.responseBody = null;
                            });
                        } else {
                            _handleBinaryMessage(message, function (message) {
                                _response.responseBody = message;
                                _invokeCallback();
                                _response.responseBody = null;
                            });
                        }
                    }
                };

                _websocket.onerror = function (message) {
                    _debug("websocket.onerror");
                    clearTimeout(_request.id);

                    if (_request.heartbeatTimer) {
                        clearTimeout(_request.heartbeatTimer);
                    }

                    // Patched by QuoteMedia
                    _onError(460, "Websocket error");
                };

                _websocket.onclose = function (message) {
                    _debug("websocket.onclose");
                    clearTimeout(_request.id);
                    if (_response.state === 'closed') return;

                    var reason = message.reason;
                    if (reason === "") {
                        switch (message.code) {
                            case 1000:
                                reason = "Normal closure; the connection successfully completed whatever purpose for which it was created.";
                                break;
                            case 1001:
                                reason = "The endpoint is going away, either because of a server failure or because the " + "browser is navigating away from the page that opened the connection.";
                                break;
                            case 1002:
                                reason = "The endpoint is terminating the connection due to a protocol error.";
                                break;
                            case 1003:
                                reason = "The connection is being terminated because the endpoint received data of a type it " + "cannot accept (for example, a text-only endpoint received binary data).";
                                break;
                            case 1004:
                                reason = "The endpoint is terminating the connection because a data frame was received that is too large.";
                                break;
                            case 1005:
                                reason = "Unknown: no status code was provided even though one was expected.";
                                break;
                            case 1006:
                                reason = "Connection was closed abnormally (that is, with no close frame being sent).";
                                break;
                        }
                    }

                    if (_canLog('warn')) {
                        atmosphere.util.warn("Websocket closed, reason: " + reason + ' - wasClean: ' + message.wasClean);
                    }

                    if (_response.closedByClientTimeout || _request.handleOnlineOffline && _offline) {
                        // IFF online/offline events are handled and we happen to be offline, we stop all reconnect attempts and
                        // resume them in the "online" event (if we get here in that case, something else went wrong as the
                        // offline handler should stop any reconnect attempt).
                        //
                        // On the other hand, if we DO NOT handle online/offline events, we continue as before with reconnecting
                        // even if we are offline. Failing to do so would stop all reconnect attemps forever.
                        if (_request.reconnectId) {
                            clearTimeout(_request.reconnectId);
                            delete _request.reconnectId;
                        }
                        return;
                    }

                    //Patched by Quotemedia
                    _invokeClose(webSocketOpened, message);

                    _response.state = 'closed';

                    if (_abortingConnection) {
                        atmosphere.util.log(_request.logLevel, ["Websocket closed normally"]);
                    } else if (!webSocketOpened) {
                        _reconnectWithFallbackTransport("Websocket failed on first connection attempt. Downgrading to " + _request.fallbackTransport + " and resending");
                    } else if (_request.reconnect && _response.transport === 'websocket') {
                        _clearState();
                        if (_requestCount++ < _request.maxReconnectOnClose) {
                            _open('re-connecting', _request.transport, _request);
                            if (_request.reconnectInterval > 0) {
                                _request.reconnectId = setTimeout(function () {
                                    _response.responseBody = "";
                                    _response.messages = [];
                                    _executeWebSocket(true);
                                }, _request.reconnectInterval);
                            } else {
                                _response.responseBody = "";
                                _response.messages = [];
                                _executeWebSocket(true);
                            }
                        } else {
                            atmosphere.util.log(_request.logLevel, ["Websocket reconnect maximum try reached " + _requestCount]);
                            if (_canLog('warn')) {
                                atmosphere.util.warn("Websocket error, reason: " + message.reason);
                            }
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };

                var ua = navigator.userAgent.toLowerCase();
                var isAndroid = ua.indexOf("android") > -1;
                if (isAndroid && _websocket.url === undefined) {
                    // Android 4.1 does not really support websockets and fails silently
                    _websocket.onclose({
                        reason: "Android 4.1 does not support websockets.",
                        wasClean: false
                    });
                }
            }

            function _handleBinaryMessage(message, callback) {
                var reader = new FileReader();
                reader.addEventListener("loadend", function (e) {
                    if (callback) {
                        callback(e.target.result);
                    }
                });
                reader.readAsArrayBuffer(message);
            }

            function _handleProtocolAsync(request, message, callback) {
                if (message instanceof Blob) {
                    var wasFirstMessage = request.firstMessage;
                    request.firstMessage = false;
                    var reader = new FileReader();
                    reader.addEventListener("loadend", function (e) {
                        if (callback) {
                            var resultingMessage = _handleProtocol(request, e.target.result);
                            if (!wasFirstMessage) {
                                callback(resultingMessage);
                            }
                        }
                    });
                    reader.readAsText(message);
                } else {
                    if (callback) {
                        callback(_handleProtocol(request, message));
                    }
                }
            }

            function _handleProtocol(request, message) {

                var nMessage = message;
                if (request.transport === 'polling') return nMessage;

                if (request.enableProtocol && request.firstMessage && atmosphere.util.trim(message).length !== 0) {
                    var pos = request.trackMessageLength ? 1 : 0;
                    var messages = message.split(request.messageDelimiter);

                    if (messages.length <= pos + 1) {
                        // Something went wrong, normally with IE or when a message is written before the
                        // handshake has been received.
                        return nMessage;
                    }

                    request.firstMessage = false;
                    request.uuid = atmosphere.util.trim(messages[pos]);

                    if (messages.length <= pos + 2) {
                        atmosphere.util.log('error', ["Protocol data not sent by the server. " + "If you enable protocol on client side, be sure to install JavascriptProtocol interceptor on server side." + "Also note that atmosphere-runtime 2.2+ should be used."]);
                    }

                    _heartbeatInterval = parseInt(atmosphere.util.trim(messages[pos + 1]), 10);
                    _heartbeatPadding = messages[pos + 2];

                    if (request.transport !== 'long-polling') {
                        _triggerOpen(request);
                    }
                    uuid = request.uuid;
                    nMessage = "";

                    // We have trailing messages
                    pos = request.trackMessageLength ? 4 : 3;
                    // pos + 1 condition assumed that there is message size written before the message even if request.trackMessageLength is false
                    if (messages.length > pos) {
                        for (var i = pos; i < messages.length; i++) {
                            nMessage += messages[i];
                            if (i + 1 !== messages.length) {
                                nMessage += request.messageDelimiter;
                            }
                        }
                    }

                    if (request.ackInterval !== 0) {
                        setTimeout(function () {
                            _push("...ACK...");
                        }, request.ackInterval);
                    }
                } else if (request.enableProtocol && request.firstMessage && atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
                    // In case we are getting some junk from IE
                    atmosphere.util.log(_request.logLevel, ["Receiving unexpected data from IE"]);
                } else {
                    _triggerOpen(request);
                }
                return nMessage;
            }

            function _timeout(_request) {
                clearTimeout(_request.id);
                if (_request.timeout > 0 && _request.transport !== 'polling') {
                    _request.id = setTimeout(function () {
                        _onClientTimeout(_request);
                        _disconnect();
                        _clearState();
                    }, _request.timeout);
                }
            }

            function _onClientTimeout(_request) {
                _response.closedByClientTimeout = true;
                _response.state = 'closedByClient';
                _response.responseBody = "";
                _response.status = 408;
                _response.messages = [];
                _invokeCallback();
            }

            function _onError(code, reason) {
                _clearState();
                clearTimeout(_request.id);
                _response.state = 'error';
                _response.reasonPhrase = reason;
                _response.responseBody = "";
                _response.status = code;
                _response.messages = [];
                _invokeCallback();
            }

            /**
             * Track received message and make sure callbacks/functions are only invoked when the complete message has been received.
             *
             * @param message
             * @param request
             * @param response
             */
            function _trackMessageSize(message, request, response) {
                // skip message tracking for binary messages
                if (message instanceof Blob) {
                    return false;
                }
                message = _handleProtocol(request, message);
                if (message.length === 0) return true;

                response.responseBody = message;

                if (request.trackMessageLength) {
                    // prepend partialMessage if any
                    message = response.partialMessage + message;

                    var messages = [];
                    var messageStart = message.indexOf(request.messageDelimiter);
                    if (messageStart != -1) {
                        while (messageStart !== -1) {
                            var str = message.substring(0, messageStart);
                            var messageLength = +str;
                            if (isNaN(messageLength)) {
                                // Discard partial message, otherwise it would never recover from this condition
                                response.partialMessage = '';
                                throw new Error('message length "' + str + '" is not a number');
                            }
                            messageStart += request.messageDelimiter.length;
                            if (messageStart + messageLength > message.length) {
                                // message not complete, so there is no trailing messageDelimiter
                                messageStart = -1;
                            } else {
                                // message complete, so add it
                                messages.push(message.substring(messageStart, messageStart + messageLength));
                                // remove consumed characters
                                message = message.substring(messageStart + messageLength, message.length);
                                messageStart = message.indexOf(request.messageDelimiter);
                            }
                        }

                        /* keep any remaining data */
                        response.partialMessage = message;

                        if (messages.length !== 0) {
                            response.responseBody = messages.join(request.messageDelimiter);
                            response.messages = messages;
                            return false;
                        } else {
                            response.responseBody = "";
                            response.messages = [];
                            return true;
                        }
                    }
                }
                response.responseBody = message;
                response.messages = [message];
                return false;
            }

            /**
             * Reconnect request with fallback transport. <br>
             * Used in case websocket can't be opened.
             *
             * @private
             */
            function _reconnectWithFallbackTransport(errorMessage) {
                atmosphere.util.log(_request.logLevel, [errorMessage]);

                if (typeof _request.onTransportFailure !== 'undefined') {
                    _request.onTransportFailure(errorMessage, _request);
                } else if (typeof atmosphere.util.onTransportFailure !== 'undefined') {
                    atmosphere.util.onTransportFailure(errorMessage, _request);
                }

                _request.transport = _request.fallbackTransport;
                var reconnectInterval = _request.connectTimeout === -1 ? 0 : _request.connectTimeout;
                if (_request.reconnect && _request.transport !== 'none' || _request.transport == null) {
                    _request.method = _request.fallbackMethod;
                    _response.transport = _request.fallbackTransport;
                    _request.fallbackTransport = 'none';
                    if (reconnectInterval > 0) {
                        _request.reconnectId = setTimeout(function () {
                            _execute();
                        }, reconnectInterval);
                    } else {
                        _execute();
                    }
                } else {
                    _onError(500, "Unable to reconnect with fallback transport");
                }
            }

            /**
             * Get url from request and attach headers to it.
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             *
             * @returns {Object} Request object, if undefined, _request object will be used.
             * @private
             */
            function _attachHeaders(request, url) {
                var rq = _request;
                if (request != null && typeof request !== 'undefined') {
                    rq = request;
                }

                if (url == null) {
                    url = rq.url;
                }

                // If not enabled
                if (!rq.attachHeadersAsQueryString) return url;

                // If already added
                if (url.indexOf("X-Atmosphere-Framework") !== -1) {
                    return url;
                }

                url += url.indexOf('?') !== -1 ? '&' : '?';
                url += "X-Atmosphere-tracking-id=" + rq.uuid;
                url += "&X-Atmosphere-Framework=" + atmosphere.version;
                url += "&X-Atmosphere-Transport=" + rq.transport;

                if (rq.trackMessageLength) {
                    url += "&X-Atmosphere-TrackMessageSize=" + "true";
                }

                if (rq.heartbeat !== null && rq.heartbeat.server !== null) {
                    url += "&X-Heartbeat-Server=" + rq.heartbeat.server;
                }

                if (rq.contentType !== '') {
                    //Eurk!
                    url += "&Content-Type=" + (rq.transport === 'websocket' ? rq.contentType : encodeURIComponent(rq.contentType));
                }

                if (rq.enableProtocol) {
                    url += "&X-atmo-protocol=true";
                }

                atmosphere.util.each(rq.headers, function (name, value) {
                    var h = atmosphere.util.isFunction(value) ? value.call(this, rq, request, _response) : value;
                    if (h != null) {
                        url += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                    }
                });

                return url;
            }

            function _triggerOpen(rq) {
                if (!rq.isOpen) {
                    rq.isOpen = true;
                    _open('opening', rq.transport, rq);
                } else if (rq.isReopen) {
                    rq.isReopen = false;
                    _open('re-opening', rq.transport, rq);
                } else if (_response.state === 'messageReceived' && (rq.transport === 'jsonp' || rq.transport === 'long-polling')) {
                    _openAfterResume(_response);
                } else {
                    return;
                }

                _startHeartbeat(rq);
            }

            function _startHeartbeat(rq) {
                if (rq.heartbeatTimer != null) {
                    clearTimeout(rq.heartbeatTimer);
                }

                if (!isNaN(_heartbeatInterval) && _heartbeatInterval > 0) {
                    var _pushHeartbeat = function _pushHeartbeat() {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Sending heartbeat");
                        }
                        _push(_heartbeatPadding);
                        rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
                    };
                    rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
                }
            }

            /**
             * Execute ajax request. <br>
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             * @private
             */
            function _executeRequest(request) {
                var rq = _request;
                if (request != null || typeof request !== 'undefined') {
                    rq = request;
                }

                rq.lastIndex = 0;
                rq.readyState = 0;

                // CORS fake using JSONP
                if (rq.transport === 'jsonp' || rq.enableXDR && atmosphere.util.checkCORSSupport()) {
                    _jsonp(rq);
                    return;
                }

                if (atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
                    if (rq.transport === 'streaming') {
                        if (rq.enableXDR && window.XDomainRequest) {
                            _ieXDR(rq);
                        } else {
                            _ieStreaming(rq);
                        }
                        return;
                    }

                    if (rq.enableXDR && window.XDomainRequest) {
                        _ieXDR(rq);
                        return;
                    }
                }

                var reconnectFExec = function reconnectFExec(force) {
                    rq.lastIndex = 0;
                    _requestCount++; // Increase also when forcing reconnect as _open checks _requestCount
                    if (force || rq.reconnect && _requestCount <= rq.maxReconnectOnClose) {
                        var delay = force ? 0 : request.reconnectInterval; // Reconnect immediately if the server resumed the connection (timeout)
                        _response.ffTryingReconnect = true;
                        _open('re-connecting', request.transport, request);
                        _reconnect(ajaxRequest, rq, delay);
                    } else {
                        _onError(0, "maxReconnectOnClose reached");
                    }
                };

                var reconnectF = function reconnectF(force) {
                    if (atmosphere._beforeUnloadState) {
                        // ATMOSPHERE-JAVASCRIPT-143: Delay reconnect to avoid reconnect attempts before an actual unload (we don't know if an unload will happen, yet)
                        atmosphere.util.debug(new Date() + " Atmosphere: reconnectF: execution delayed due to _beforeUnloadState flag");
                        setTimeout(function () {
                            reconnectFExec(force);
                        }, 5000);
                    } else {
                        reconnectFExec(force);
                    }
                };

                var disconnected = function disconnected() {
                    // Prevent onerror callback to be called
                    _response.errorHandled = true;
                    _clearState();
                    reconnectF(false);
                };

                if (rq.force || rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest)) {
                    rq.force = false;

                    var ajaxRequest = atmosphere.util.xhr();
                    ajaxRequest.hasData = false;

                    _doRequest(ajaxRequest, rq, true);

                    if (rq.suspend) {
                        _activeRequest = ajaxRequest;
                    }

                    if (rq.transport !== 'polling') {
                        _response.transport = rq.transport;

                        ajaxRequest.onabort = function () {
                            _debug("ajaxrequest.onabort");
                            _invokeClose(true);
                        };

                        ajaxRequest.onerror = function () {
                            _debug("ajaxrequest.onerror");
                            _response.error = true;
                            _response.ffTryingReconnect = true;
                            try {
                                _response.status = XMLHttpRequest.status;
                            } catch (e) {
                                _response.status = 500;
                            }

                            if (!_response.status) {
                                _response.status = 500;
                            }
                            if (!_response.errorHandled) {
                                _clearState();
                                reconnectF(false);
                            }
                        };
                    }

                    ajaxRequest.onreadystatechange = function () {
                        _debug("ajaxRequest.onreadystatechange, new state: " + ajaxRequest.readyState);
                        if (_abortingConnection) {
                            _debug("onreadystatechange has been ignored due to _abortingConnection flag");
                            return;
                        }

                        _response.error = null;
                        var skipCallbackInvocation = false;
                        var update = false;

                        if (rq.transport === 'streaming' && rq.readyState > 2 && ajaxRequest.readyState === 4) {
                            _clearState();
                            reconnectF(false);
                            return;
                        }

                        rq.readyState = ajaxRequest.readyState;

                        if (rq.transport === 'streaming' && ajaxRequest.readyState >= 3) {
                            update = true;
                        } else if (rq.transport === 'long-polling' && ajaxRequest.readyState === 4) {
                            update = true;
                        }
                        _timeout(_request);

                        if (rq.transport !== 'polling') {
                            // MSIE 9 and lower status can be higher than 1000, Chrome can be 0
                            var status = 200;
                            if (ajaxRequest.readyState === 4) {
                                status = ajaxRequest.status > 1000 ? 0 : ajaxRequest.status;
                            }

                            if (!rq.reconnectOnServerError && status >= 300 && status < 600) {
                                _onError(status, ajaxRequest.statusText);
                                return;
                            }

                            if (status >= 300 || status === 0) {
                                disconnected();
                                return;
                            }

                            // Firefox incorrectly send statechange 0->2 when a reconnect attempt fails. The above checks ensure that onopen is not called for these
                            if ((!rq.enableProtocol || !request.firstMessage) && ajaxRequest.readyState === 2) {
                                // Firefox incorrectly send statechange 0->2 when a reconnect attempt fails. The above checks ensure that onopen is not called for these
                                // In that case, ajaxRequest.onerror will be called just after onreadystatechange is called, so we delay the trigger until we are
                                // guarantee the connection is well established.
                                if (atmosphere.util.browser.mozilla && _response.ffTryingReconnect) {
                                    _response.ffTryingReconnect = false;
                                    setTimeout(function () {
                                        if (!_response.ffTryingReconnect) {
                                            _triggerOpen(rq);
                                        }
                                    }, 500);
                                } else {
                                    _triggerOpen(rq);
                                }
                            }
                        } else if (ajaxRequest.readyState === 4) {
                            update = true;
                        }

                        if (update) {
                            var responseText = ajaxRequest.responseText;
                            _response.errorHandled = false;

                            // IE behave the same way when resuming long-polling or when the server goes down.
                            if (rq.transport === 'long-polling' && atmosphere.util.trim(responseText).length === 0) {
                                // For browser that aren't support onabort
                                if (!ajaxRequest.hasData) {
                                    reconnectF(true);
                                } else {
                                    ajaxRequest.hasData = false;
                                }
                                return;
                            }
                            ajaxRequest.hasData = true;

                            _readHeaders(ajaxRequest, _request);

                            if (rq.transport === 'streaming') {
                                if (!atmosphere.util.browser.opera) {
                                    var message = responseText.substring(rq.lastIndex, responseText.length);
                                    skipCallbackInvocation = _trackMessageSize(message, rq, _response);

                                    rq.lastIndex = responseText.length;
                                    if (skipCallbackInvocation) {
                                        return;
                                    }
                                } else {
                                    atmosphere.util.iterate(function () {
                                        if (_response.status !== 500 && ajaxRequest.responseText.length > rq.lastIndex) {
                                            try {
                                                _response.status = ajaxRequest.status;
                                                _response.headers = atmosphere.util.parseHeaders(ajaxRequest.getAllResponseHeaders());

                                                _readHeaders(ajaxRequest, _request);
                                            } catch (e) {
                                                _response.status = 404;
                                            }
                                            _timeout(_request);

                                            _response.state = "messageReceived";
                                            var message = ajaxRequest.responseText.substring(rq.lastIndex);
                                            rq.lastIndex = ajaxRequest.responseText.length;

                                            skipCallbackInvocation = _trackMessageSize(message, rq, _response);
                                            if (!skipCallbackInvocation) {
                                                _invokeCallback();
                                            }

                                            if (_verifyStreamingLength(ajaxRequest, rq)) {
                                                _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                                                return;
                                            }
                                        } else if (_response.status > 400) {
                                            // Prevent replaying the last message.
                                            rq.lastIndex = ajaxRequest.responseText.length;
                                            return false;
                                        }
                                    }, 0);
                                }
                            } else {
                                skipCallbackInvocation = _trackMessageSize(responseText, rq, _response);
                            }
                            var closeStream = _verifyStreamingLength(ajaxRequest, rq);

                            try {
                                _response.status = ajaxRequest.status;
                                _response.headers = atmosphere.util.parseHeaders(ajaxRequest.getAllResponseHeaders());

                                _readHeaders(ajaxRequest, rq);
                            } catch (e) {
                                _response.status = 404;
                            }

                            if (rq.suspend) {
                                _response.state = _response.status === 0 ? "closed" : "messageReceived";
                            } else {
                                _response.state = "messagePublished";
                            }

                            var isAllowedToReconnect = !closeStream && request.transport !== 'streaming' && request.transport !== 'polling';
                            if (isAllowedToReconnect && !rq.executeCallbackBeforeReconnect) {
                                _reconnect(ajaxRequest, rq, rq.pollingInterval);
                            }

                            if (_response.responseBody.length !== 0 && !skipCallbackInvocation) _invokeCallback();

                            if (isAllowedToReconnect && rq.executeCallbackBeforeReconnect) {
                                _reconnect(ajaxRequest, rq, rq.pollingInterval);
                            }

                            if (closeStream) {
                                _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                            }
                        }
                    };

                    try {
                        // XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]
                        // This tells the browser not to parse it, and to let the bytes pass through unprocessed.
                        if (rq.transport === 'streaming' && rq.headers["X-Atmosphere-Binary"]) {
                            ajaxRequest.overrideMimeType('text\/plain; charset=x-user-defined');
                        }
                        ajaxRequest.send(rq.data);
                        _subscribed = true;
                    } catch (e) {
                        atmosphere.util.log(rq.logLevel, ["Unable to connect to " + rq.url]);
                        _onError(0, e);
                    }
                } else {
                    if (rq.logLevel === 'debug') {
                        atmosphere.util.log(rq.logLevel, ["Max re-connection reached."]);
                    }
                    _onError(0, "maxRequest reached");
                }
            }

            function _reconnectOnMaxStreamingLength(ajaxRequest, rq) {
                _response.messages = [];
                rq.isReopen = true;
                _close();
                _abortingConnection = false;
                _reconnect(ajaxRequest, rq, 500);
            }

            /**
             * Do ajax request.
             *
             * @param ajaxRequest Ajax request.
             * @param request Request parameters.
             * @param create If ajax request has to be open.
             */
            function _doRequest(ajaxRequest, request, create) {
                // Prevent Android to cache request
                var url = request.url;
                if (request.dispatchUrl != null && request.method === 'POST') {
                    url += request.dispatchUrl;
                }
                url = _attachHeaders(request, url);
                url = atmosphere.util.prepareURL(url);

                if (create) {
                    ajaxRequest.open(request.method, url, request.async);
                    if (request.connectTimeout > 0) {
                        request.id = setTimeout(function () {
                            if (request.requestCount === 0) {
                                _clearState();
                                _prepareCallback("Connect timeout", "closed", 200, request.transport);
                            }
                        }, request.connectTimeout);
                    }
                }

                if (_request.withCredentials && _request.transport !== 'websocket') {
                    if ("withCredentials" in ajaxRequest) {
                        ajaxRequest.withCredentials = true;
                    }
                }

                if (!_request.dropHeaders) {
                    ajaxRequest.setRequestHeader("X-Atmosphere-Framework", atmosphere.version);
                    ajaxRequest.setRequestHeader("X-Atmosphere-Transport", request.transport);

                    if (request.heartbeat !== null && request.heartbeat.server !== null) {
                        ajaxRequest.setRequestHeader("X-Heartbeat-Server", ajaxRequest.heartbeat.server);
                    }

                    if (request.trackMessageLength) {
                        ajaxRequest.setRequestHeader("X-Atmosphere-TrackMessageSize", "true");
                    }
                    ajaxRequest.setRequestHeader("X-Atmosphere-tracking-id", request.uuid);

                    atmosphere.util.each(request.headers, function (name, value) {
                        var h = atmosphere.util.isFunction(value) ? value.call(this, ajaxRequest, request, create, _response) : value;
                        if (h != null) {
                            ajaxRequest.setRequestHeader(name, h);
                        }
                    });
                }

                if (request.contentType !== '') {
                    ajaxRequest.setRequestHeader("Content-Type", request.contentType);
                }
            }

            function _reconnect(ajaxRequest, request, delay) {

                if (_response.closedByClientTimeout) {
                    return;
                }

                if (request.reconnect || request.suspend && _subscribed) {
                    var status = 0;
                    if (ajaxRequest && ajaxRequest.readyState > 1) {
                        status = ajaxRequest.status > 1000 ? 0 : ajaxRequest.status;
                    }
                    _response.status = status === 0 ? 204 : status;
                    _response.reason = status === 0 ? "Server resumed the connection or down." : "OK";

                    clearTimeout(request.id);
                    if (request.reconnectId) {
                        clearTimeout(request.reconnectId);
                        delete request.reconnectId;
                    }

                    if (delay > 0) {
                        // For whatever reason, never cancel a reconnect timeout as it is mandatory to reconnect.
                        _request.reconnectId = setTimeout(function () {
                            _executeRequest(request);
                        }, delay);
                    } else {
                        _executeRequest(request);
                    }
                }
            }

            function _tryingToReconnect(response) {
                response.state = 're-connecting';
                _invokeFunction(response);
            }

            function _openAfterResume(response) {
                response.state = 'openAfterResume';
                _invokeFunction(response);
                response.state = 'messageReceived';
            }

            function _ieXDR(request) {
                if (request.transport !== "polling") {
                    _ieStream = _configureXDR(request);
                    _ieStream.open();
                } else {
                    _configureXDR(request).open();
                }
            }

            function _configureXDR(request) {
                var rq = _request;
                if (request != null && typeof request !== 'undefined') {
                    rq = request;
                }

                var transport = rq.transport;
                var lastIndex = 0;
                var xdr = new window.XDomainRequest();
                var reconnect = function reconnect() {
                    if (rq.transport === "long-polling" && rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest)) {
                        xdr.status = 200;
                        _ieXDR(rq);
                    }
                };

                var rewriteURL = rq.rewriteURL || function (url) {
                    // Maintaining session by rewriting URL
                    // http://stackoverflow.com/questions/6453779/maintaining-session-by-rewriting-url
                    var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/.exec(document.cookie);

                    switch (match && match[1]) {
                        case "JSESSIONID":
                            return url.replace(/;jsessionid=[^\?]*|(\?)|$/, ";jsessionid=" + match[2] + "$1");
                        case "PHPSESSID":
                            return url.replace(/\?PHPSESSID=[^&]*&?|\?|$/, "?PHPSESSID=" + match[2] + "&").replace(/&$/, "");
                    }
                    return url;
                };

                // Handles open and message event
                xdr.onprogress = function () {
                    handle(xdr);
                };
                // Handles error event
                xdr.onerror = function () {
                    // If the server doesn't send anything back to XDR will fail with polling
                    if (rq.transport !== 'polling') {
                        _clearState();
                        if (_requestCount++ < rq.maxReconnectOnClose) {
                            if (rq.reconnectInterval > 0) {
                                rq.reconnectId = setTimeout(function () {
                                    _open('re-connecting', request.transport, request);
                                    _ieXDR(rq);
                                }, rq.reconnectInterval);
                            } else {
                                _open('re-connecting', request.transport, request);
                                _ieXDR(rq);
                            }
                        } else {
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };

                // Handles close event
                xdr.onload = function () {};

                var handle = function handle(xdr) {
                    clearTimeout(rq.id);
                    var message = xdr.responseText;

                    message = message.substring(lastIndex);
                    lastIndex += message.length;

                    if (transport !== 'polling') {
                        _timeout(rq);

                        var skipCallbackInvocation = _trackMessageSize(message, rq, _response);

                        if (transport === 'long-polling' && atmosphere.util.trim(message).length === 0) return;

                        if (rq.executeCallbackBeforeReconnect) {
                            reconnect();
                        }

                        if (!skipCallbackInvocation) {
                            _prepareCallback(_response.responseBody, "messageReceived", 200, transport);
                        }

                        if (!rq.executeCallbackBeforeReconnect) {
                            reconnect();
                        }
                    }
                };

                return {
                    open: function open() {
                        var url = rq.url;
                        if (rq.dispatchUrl != null) {
                            url += rq.dispatchUrl;
                        }
                        url = _attachHeaders(rq, url);
                        xdr.open(rq.method, rewriteURL(url));
                        if (rq.method === 'GET') {
                            xdr.send();
                        } else {
                            xdr.send(rq.data);
                        }

                        if (rq.connectTimeout > 0) {
                            rq.id = setTimeout(function () {
                                if (rq.requestCount === 0) {
                                    _clearState();
                                    _prepareCallback("Connect timeout", "closed", 200, rq.transport);
                                }
                            }, rq.connectTimeout);
                        }
                    },
                    close: function close() {
                        xdr.abort();
                    }
                };
            }

            function _ieStreaming(request) {
                _ieStream = _configureIE(request);
                _ieStream.open();
            }

            function _configureIE(request) {
                var rq = _request;
                if (request != null && typeof request !== 'undefined') {
                    rq = request;
                }

                var stop;
                var doc = new window.ActiveXObject("htmlfile");

                doc.open();
                doc.close();

                var url = rq.url;
                if (rq.dispatchUrl != null) {
                    url += rq.dispatchUrl;
                }

                if (rq.transport !== 'polling') {
                    _response.transport = rq.transport;
                }

                return {
                    open: function open() {
                        var iframe = doc.createElement("iframe");

                        url = _attachHeaders(rq);
                        if (rq.data !== '') {
                            url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(rq.data);
                        }

                        // Finally attach a timestamp to prevent Android and IE caching.
                        url = atmosphere.util.prepareURL(url);

                        iframe.src = url;
                        doc.body.appendChild(iframe);

                        // For the server to respond in a consistent format regardless of user agent, we polls response text
                        var cdoc = iframe.contentDocument || iframe.contentWindow.document;

                        stop = atmosphere.util.iterate(function () {
                            try {
                                if (!cdoc.firstChild) {
                                    return;
                                }

                                var res = cdoc.body ? cdoc.body.lastChild : cdoc;
                                if (res.omgThisIsBroken) {
                                    // Cause an exception when res is null, to trigger a reconnect...
                                }
                                var readResponse = function readResponse() {
                                    // Clones the element not to disturb the original one
                                    var clone = res.cloneNode(true);

                                    // If the last character is a carriage return or a line feed, IE ignores it in the innerText property
                                    // therefore, we add another non-newline character to preserve it
                                    clone.appendChild(cdoc.createTextNode("."));

                                    var text = clone.innerText;

                                    text = text.substring(0, text.length - 1);
                                    return text;
                                };

                                // To support text/html content type
                                if (!cdoc.body || !cdoc.body.firstChild || cdoc.body.firstChild.nodeName.toLowerCase() !== "pre") {
                                    // Injects a plaintext element which renders text without interpreting the HTML and cannot be stopped
                                    // it is deprecated in HTML5, but still works
                                    var head = cdoc.head || cdoc.getElementsByTagName("head")[0] || cdoc.documentElement || cdoc;
                                    var script = cdoc.createElement("script");

                                    script.text = "document.write('<plaintext>')";

                                    head.insertBefore(script, head.firstChild);
                                    head.removeChild(script);

                                    // The plaintext element will be the response container
                                    res = cdoc.body.lastChild;
                                }

                                if (rq.closed) {
                                    rq.isReopen = true;
                                }

                                // Handles message and close event
                                stop = atmosphere.util.iterate(function () {
                                    var text = readResponse();
                                    if (text.length > rq.lastIndex) {
                                        _timeout(_request);

                                        _response.status = 200;
                                        _response.error = null;

                                        // Empties response every time that it is handled
                                        res.innerText = "";
                                        var skipCallbackInvocation = _trackMessageSize(text, rq, _response);
                                        if (skipCallbackInvocation) {
                                            return "";
                                        }

                                        _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                                    }

                                    rq.lastIndex = 0;

                                    if (cdoc.readyState === "complete") {
                                        _invokeClose(true);
                                        _open('re-connecting', rq.transport, rq);
                                        if (rq.reconnectInterval > 0) {
                                            rq.reconnectId = setTimeout(function () {
                                                _ieStreaming(rq);
                                            }, rq.reconnectInterval);
                                        } else {
                                            _ieStreaming(rq);
                                        }
                                        return false;
                                    }
                                }, null);

                                return false;
                            } catch (err) {
                                _response.error = true;
                                _open('re-connecting', rq.transport, rq);
                                if (_requestCount++ < rq.maxReconnectOnClose) {
                                    if (rq.reconnectInterval > 0) {
                                        rq.reconnectId = setTimeout(function () {
                                            _ieStreaming(rq);
                                        }, rq.reconnectInterval);
                                    } else {
                                        _ieStreaming(rq);
                                    }
                                } else {
                                    _onError(0, "maxReconnectOnClose reached");
                                }
                                doc.execCommand("Stop");
                                doc.close();
                                return false;
                            }
                        });
                    },

                    close: function close() {
                        if (stop) {
                            stop();
                        }

                        doc.execCommand("Stop");
                        _invokeClose(true);
                    }
                };
            }

            /**
             * Send message. <br>
             * Will be automatically dispatch to other connected.
             *
             * @param {Object, string} Message to send.
             * @private
             */
            function _push(message) {

                if (_localStorageService != null) {
                    _pushLocal(message);
                } else if (_activeRequest != null || _sse != null) {
                    _pushAjaxMessage(message);
                } else if (_ieStream != null) {
                    _pushIE(message);
                } else if (_jqxhr != null) {
                    _pushJsonp(message);
                } else if (_websocket != null) {
                    _pushWebSocket(message);
                } else {
                    _onError(0, "No suspended connection available");
                    atmosphere.util.error("No suspended connection available. Make sure atmosphere.subscribe has been called and request.onOpen invoked before trying to push data");
                }
            }

            function _pushOnClose(message, rq) {
                if (!rq) {
                    rq = _getPushRequest(message);
                }
                rq.transport = "polling";
                rq.method = "GET";
                rq.withCredentials = false;
                rq.reconnect = false;
                rq.force = true;
                rq.suspend = false;
                rq.timeout = 1000;
                _executeRequest(rq);
            }

            function _pushLocal(message) {
                _localStorageService.send(message);
            }

            function _intraPush(message) {
                // IE 9 will crash if not.
                if (message.length === 0) return;

                try {
                    if (_localStorageService) {
                        _localStorageService.localSend(message);
                    } else if (_storageService) {
                        _storageService.signal("localMessage", atmosphere.util.stringifyJSON({
                            id: guid,
                            event: message
                        }));
                    }
                } catch (err) {
                    atmosphere.util.error(err);
                }
            }

            /**
             * Send a message using currently opened ajax request (using http-streaming or long-polling). <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushAjaxMessage(message) {
                var rq = _getPushRequest(message);
                _executeRequest(rq);
            }

            /**
             * Send a message using currently opened ie streaming (using http-streaming or long-polling). <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushIE(message) {
                if (_request.enableXDR && atmosphere.util.checkCORSSupport()) {
                    var rq = _getPushRequest(message);
                    // Do not reconnect since we are pushing.
                    rq.reconnect = false;
                    _jsonp(rq);
                } else {
                    _pushAjaxMessage(message);
                }
            }

            /**
             * Send a message using jsonp transport. <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushJsonp(message) {
                _pushAjaxMessage(message);
            }

            function _getStringMessage(message) {
                var msg = message;
                if ((typeof msg === "undefined" ? "undefined" : _typeof(msg)) === 'object') {
                    msg = message.data;
                }
                return msg;
            }

            /**
             * Build request use to push message using method 'POST' <br>. Transport is defined as 'polling' and 'suspend' is set to false.
             *
             * @return {Object} Request object use to push message.
             * @private
             */
            function _getPushRequest(message) {
                var msg = _getStringMessage(message);

                var rq = {
                    connected: false,
                    timeout: 60000,
                    method: 'POST',
                    url: _request.url,
                    contentType: _request.contentType,
                    headers: _request.headers,
                    reconnect: true,
                    callback: null,
                    data: msg,
                    suspend: false,
                    maxRequest: -1,
                    logLevel: 'info',
                    requestCount: 0,
                    withCredentials: _request.withCredentials,
                    async: _request.async,
                    transport: 'polling',
                    isOpen: true,
                    attachHeadersAsQueryString: true,
                    enableXDR: _request.enableXDR,
                    uuid: _request.uuid,
                    dispatchUrl: _request.dispatchUrl,
                    enableProtocol: false,
                    messageDelimiter: '|',
                    trackMessageLength: _request.trackMessageLength,
                    maxReconnectOnClose: _request.maxReconnectOnClose,
                    heartbeatTimer: _request.heartbeatTimer,
                    heartbeat: _request.heartbeat
                };

                if ((typeof message === "undefined" ? "undefined" : _typeof(message)) === 'object') {
                    rq = atmosphere.util.extend(rq, message);
                }

                return rq;
            }

            /**
             * Send a message using currently opened websocket. <br>
             *
             */
            function _pushWebSocket(message) {
                var msg = atmosphere.util.isBinary(message) ? message : _getStringMessage(message);
                var data;
                try {
                    if (_request.dispatchUrl != null) {
                        data = _request.webSocketPathDelimiter + _request.dispatchUrl + _request.webSocketPathDelimiter + msg;
                    } else {
                        data = msg;
                    }

                    if (!_websocket.canSendMessage) {
                        atmosphere.util.error("WebSocket not connected.");
                        return;
                    }

                    _websocket.send(data);
                } catch (e) {
                    _websocket.onclose = function (message) {};
                    _clearState();

                    _reconnectWithFallbackTransport("Websocket failed. Downgrading to " + _request.fallbackTransport + " and resending " + message);
                    _pushAjaxMessage(message);
                }
            }

            function _localMessage(message) {
                var m = atmosphere.util.parseJSON(message);
                if (m.id !== guid) {
                    if (typeof _request.onLocalMessage !== 'undefined') {
                        _request.onLocalMessage(m.event);
                    } else if (typeof atmosphere.util.onLocalMessage !== 'undefined') {
                        atmosphere.util.onLocalMessage(m.event);
                    }
                }
            }

            function _prepareCallback(messageBody, state, errorCode, transport) {

                _response.responseBody = messageBody;
                _response.transport = transport;
                _response.status = errorCode;
                _response.state = state;

                _invokeCallback();
            }

            function _readHeaders(xdr, request) {
                if (!request.readResponsesHeaders) {
                    if (!request.enableProtocol) {
                        request.uuid = guid;
                    }
                } else {
                    try {

                        var tempUUID = xdr.getResponseHeader('X-Atmosphere-tracking-id');
                        if (tempUUID && tempUUID != null) {
                            request.uuid = tempUUID.split(" ").pop();
                        }
                    } catch (e) {}
                }
            }

            function _invokeFunction(response) {
                _f(response, _request);
                // Global
                _f(response, atmosphere.util);
            }

            function _f(response, f) {
                switch (response.state) {
                    case "messageReceived":
                        _debug("Firing onMessage");
                        _requestCount = 0;
                        if (typeof f.onMessage !== 'undefined') f.onMessage(response);

                        if (typeof f.onmessage !== 'undefined') f.onmessage(response);
                        break;
                    case "error":
                        var dbgReasonPhrase = typeof response.reasonPhrase != 'undefined' ? response.reasonPhrase : 'n/a';
                        _debug("Firing onError, reasonPhrase: " + dbgReasonPhrase);
                        if (typeof f.onError !== 'undefined') f.onError(response);

                        if (typeof f.onerror !== 'undefined') f.onerror(response);
                        break;
                    case "opening":
                        delete _request.closed;
                        _debug("Firing onOpen");
                        if (typeof f.onOpen !== 'undefined') f.onOpen(response);

                        if (typeof f.onopen !== 'undefined') f.onopen(response);
                        break;
                    case "messagePublished":
                        _debug("Firing messagePublished");
                        if (typeof f.onMessagePublished !== 'undefined') f.onMessagePublished(response);
                        break;
                    case "re-connecting":
                        _debug("Firing onReconnect");
                        if (typeof f.onReconnect !== 'undefined') f.onReconnect(_request, response);
                        break;
                    case "closedByClient":
                        _debug("Firing closedByClient");
                        if (typeof f.onClientTimeout !== 'undefined') f.onClientTimeout(_request);
                        break;
                    case "re-opening":
                        delete _request.closed;
                        _debug("Firing onReopen");
                        if (typeof f.onReopen !== 'undefined') f.onReopen(_request, response);
                        break;
                    case "fail-to-reconnect":
                        _debug("Firing onFailureToReconnect");
                        if (typeof f.onFailureToReconnect !== 'undefined') f.onFailureToReconnect(_request, response);
                        break;
                    case "unsubscribe":
                    case "closed":
                        var closed = typeof _request.closed !== 'undefined' ? _request.closed : false;

                        if (!closed) {
                            _debug("Firing onClose (" + response.state + " case)");
                            if (typeof f.onClose !== 'undefined') {
                                f.onClose(response);
                            }

                            if (typeof f.onclose !== 'undefined') {
                                f.onclose(response);
                            }
                        } else {
                            _debug("Request already closed, not firing onClose (" + response.state + " case)");
                        }
                        _request.closed = true;
                        break;
                    case "openAfterResume":
                        if (typeof f.onOpenAfterResume !== 'undefined') f.onOpenAfterResume(_request);
                        break;
                }
            }

            //Patched by Quotemedia
            function _invokeClose(wasOpen, message) {
                if (_response.state !== 'closed') {
                    _response.state = 'closed';
                    _response.responseBody = "";
                    _response.messages = [];
                    _response.atmoMessage = message;
                    _response.status = !wasOpen ? 501 : 200;
                    _invokeCallback();
                }
            }

            /**
             * Invoke request callbacks.
             *
             * @private
             */
            function _invokeCallback() {
                var call = function call(index, func) {
                    func(_response);
                };

                if (_localStorageService == null && _localSocketF != null) {
                    _localSocketF(_response.responseBody);
                }

                _request.reconnect = _request.mrequest;

                var isString = typeof _response.responseBody === 'string';
                var messages = isString && _request.trackMessageLength ? _response.messages.length > 0 ? _response.messages : [''] : new Array(_response.responseBody);
                for (var i = 0; i < messages.length; i++) {

                    if (messages.length > 1 && messages[i].length === 0) {
                        continue;
                    }
                    _response.responseBody = isString && !(_request.transport === 'streaming' && _request.headers["X-Atmosphere-Binary"] && !_request.firstMessage) ? atmosphere.util.trim(messages[i]) : messages[i];

                    if (_localStorageService == null && _localSocketF != null) {
                        _localSocketF(_response.responseBody);
                    }

                    if ((_response.responseBody.length === 0 || isString && _heartbeatPadding === _response.responseBody) && _response.state === "messageReceived") {
                        continue;
                    }

                    _invokeFunction(_response);

                    // Invoke global callbacks
                    if (callbacks.length > 0) {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Invoking " + callbacks.length + " global callbacks: " + _response.state);
                        }
                        try {
                            atmosphere.util.each(callbacks, call);
                        } catch (e) {
                            atmosphere.util.log(_request.logLevel, ["Callback exception" + e]);
                        }
                    }

                    // Invoke request callback
                    if (typeof _request.callback === 'function') {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Invoking request callbacks");
                        }
                        try {
                            _request.callback(_response);
                        } catch (e) {
                            atmosphere.util.log(_request.logLevel, ["Callback exception" + e]);
                        }
                    }
                }
            }

            this.subscribe = function (options) {
                _subscribe(options);
                _execute();
            };

            this.execute = function () {
                _execute();
            };

            this.close = function () {
                _close();
            };

            this.disconnect = function () {
                _disconnect();
            };

            this.getUrl = function () {
                return _request.url;
            };

            this.push = function (message, dispatchUrl) {
                if (dispatchUrl != null) {
                    var originalDispatchUrl = _request.dispatchUrl;
                    _request.dispatchUrl = dispatchUrl;
                    _push(message);
                    _request.dispatchUrl = originalDispatchUrl;
                } else {
                    _push(message);
                }
            };

            this.getUUID = function () {
                return _request.uuid;
            };

            this.pushLocal = function (message) {
                _intraPush(message);
            };

            this.enableProtocol = function (message) {
                return _request.enableProtocol;
            };

            this.init = function () {
                _init();
            };

            this.request = _request;
            this.response = _response;
        }
    };

    atmosphere.subscribe = function (url, callback, request) {
        if (typeof callback === 'function') {
            atmosphere.addCallback(callback);
        }

        if (typeof url !== "string") {
            request = url;
        } else {
            request.url = url;
        }

        // https://github.com/Atmosphere/atmosphere-javascript/issues/58
        uuid = typeof request !== 'undefined' && typeof request.uuid !== 'undefined' ? request.uuid : 0;

        var rq = new atmosphere.AtmosphereRequest(request);
        rq.execute();

        requests[requests.length] = rq;
        return rq;
    };

    atmosphere.unsubscribe = function () {
        if (requests.length > 0) {
            var requestsClone = [].concat(requests);
            for (var i = 0; i < requestsClone.length; i++) {
                var rq = requestsClone[i];
                rq.close();
                clearTimeout(rq.response.request.id);

                if (rq.heartbeatTimer) {
                    clearTimeout(rq.heartbeatTimer);
                }
            }
        }
        requests = [];
        callbacks = [];
    };

    atmosphere.unsubscribeUrl = function (url) {
        var idx = -1;
        if (requests.length > 0) {
            for (var i = 0; i < requests.length; i++) {
                var rq = requests[i];

                // Suppose you can subscribe once to an url
                if (rq.getUrl() === url) {
                    rq.close();
                    clearTimeout(rq.response.request.id);

                    if (rq.heartbeatTimer) {
                        clearTimeout(rq.heartbeatTimer);
                    }

                    idx = i;
                    break;
                }
            }
        }
        if (idx >= 0) {
            requests.splice(idx, 1);
        }
    };

    atmosphere.addCallback = function (func) {
        if (atmosphere.util.inArray(func, callbacks) === -1) {
            callbacks.push(func);
        }
    };

    atmosphere.removeCallback = function (func) {
        var index = atmosphere.util.inArray(func, callbacks);
        if (index !== -1) {
            callbacks.splice(index, 1);
        }
    };

    atmosphere.util = {
        browser: {},

        parseHeaders: function parseHeaders(headerString) {
            var match,
                rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
                headers = {};
            while (match = rheaders.exec(headerString)) {
                headers[match[1]] = match[2];
            }
            return headers;
        },

        now: function now() {
            return new Date().getTime();
        },

        isArray: function isArray(array) {
            return Object.prototype.toString.call(array) === "[object Array]";
        },

        inArray: function inArray(elem, array) {
            if (!Array.prototype.indexOf) {
                var len = array.length;
                for (var i = 0; i < len; ++i) {
                    if (array[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }
            return array.indexOf(elem);
        },

        isBinary: function isBinary(data) {
            // True if data is an instance of Blob, ArrayBuffer or ArrayBufferView
            return (/^\[object\s(?:Blob|ArrayBuffer|.+Array)\]$/.test(Object.prototype.toString.call(data))
            );
        },

        isFunction: function isFunction(fn) {
            return Object.prototype.toString.call(fn) === "[object Function]";
        },

        getAbsoluteURL: function getAbsoluteURL(url) {
            if (typeof document.createElement === 'undefined') {
                // assuming the url to be already absolute when DOM is not supported
                return url;
            }
            var div = document.createElement("div");

            // Uses an innerHTML property to obtain an absolute URL
            div.innerHTML = '<a href="' + url + '"/>';

            // encodeURI and decodeURI are needed to normalize URL between IE and non-IE,
            // since IE doesn't encode the href property value and return it - http://jsfiddle.net/Yq9M8/1/
            return encodeURI(decodeURI(div.firstChild.href));
        },

        prepareURL: function prepareURL(url) {
            // Attaches a time stamp to prevent caching
            var ts = atmosphere.util.now();
            var ret = url.replace(/([?&])_=[^&]*/, "$1_=" + ts);

            return ret + (ret === url ? (/\?/.test(url) ? "&" : "?") + "_=" + ts : "");
        },

        trim: function trim(str) {
            if (!String.prototype.trim) {
                return str.toString().replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, "").replace(/\s+/g, " ");
            } else {
                return str.toString().trim();
            }
        },

        param: function param(params) {
            var prefix,
                s = [];

            function add(key, value) {
                value = atmosphere.util.isFunction(value) ? value() : value == null ? "" : value;
                s.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
            }

            function buildParams(prefix, obj) {
                var name;

                if (atmosphere.util.isArray(obj)) {
                    atmosphere.util.each(obj, function (i, v) {
                        if (/\[\]$/.test(prefix)) {
                            add(prefix, v);
                        } else {
                            buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" ? i : "") + "]", v);
                        }
                    });
                } else if (Object.prototype.toString.call(obj) === "[object Object]") {
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name]);
                    }
                } else {
                    add(prefix, obj);
                }
            }

            for (prefix in params) {
                buildParams(prefix, params[prefix]);
            }

            return s.join("&").replace(/%20/g, "+");
        },

        storage: function storage() {
            try {
                return !!(window.localStorage && window.StorageEvent);
            } catch (e) {
                //Firefox throws an exception here, see
                //https://bugzilla.mozilla.org/show_bug.cgi?id=748620
                return false;
            }
        },

        iterate: function iterate(fn, interval) {
            var timeoutId;

            // Though the interval is 0 for real-time application, there is a delay between setTimeout calls
            // For detail, see https://developer.mozilla.org/en/window.setTimeout#Minimum_delay_and_timeout_nesting
            interval = interval || 0;

            (function loop() {
                timeoutId = setTimeout(function () {
                    if (fn() === false) {
                        return;
                    }

                    loop();
                }, interval);
            })();

            return function () {
                clearTimeout(timeoutId);
            };
        },

        each: function each(obj, callback, args) {
            if (!obj) return;
            var value,
                i = 0,
                length = obj.length,
                isArray = atmosphere.util.isArray(obj);

            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        extend: function extend(target) {
            var i, options, name;

            for (i = 1; i < arguments.length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        target[name] = options[name];
                    }
                }
            }

            return target;
        },
        on: function on(elem, type, fn) {
            if (elem.addEventListener) {
                elem.addEventListener(type, fn, false);
            } else if (elem.attachEvent) {
                elem.attachEvent("on" + type, fn);
            }
        },
        off: function off(elem, type, fn) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, fn, false);
            } else if (elem.detachEvent) {
                elem.detachEvent("on" + type, fn);
            }
        },

        log: function log(level, args) {
            if (window.console) {
                var logger = window.console[level];
                if (typeof logger === 'function') {
                    logger.apply(window.console, args);
                }
            }
        },

        warn: function warn() {
            atmosphere.util.log('warn', arguments);
        },

        info: function info() {
            atmosphere.util.log('info', arguments);
        },

        debug: function debug() {
            atmosphere.util.log('debug', arguments);
        },

        error: function error() {
            atmosphere.util.log('error', arguments);
        },
        xhr: function xhr() {
            try {
                return new window.XMLHttpRequest();
            } catch (e1) {
                try {
                    return new window.ActiveXObject("Microsoft.XMLHTTP");
                } catch (e2) {}
            }
        },
        parseJSON: function parseJSON(data) {
            return !data ? null : window.JSON && window.JSON.parse ? window.JSON.parse(data) : new Function("return " + data)();
        },
        // http://github.com/flowersinthesand/stringifyJSON
        stringifyJSON: function stringifyJSON(value) {
            var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                meta = {
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"': '\\"',
                '\\': '\\\\'
            };

            function quote(string) {
                return '"' + string.replace(escapable, function (a) {
                    var c = meta[a];
                    return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                }) + '"';
            }

            function f(n) {
                return n < 10 ? "0" + n : n;
            }

            return window.JSON && window.JSON.stringify ? window.JSON.stringify(value) : function str(key, holder) {
                var i,
                    v,
                    len,
                    partial,
                    value = holder[key],
                    type = typeof value === "undefined" ? "undefined" : _typeof(value);

                if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && typeof value.toJSON === "function") {
                    value = value.toJSON(key);
                    type = typeof value === "undefined" ? "undefined" : _typeof(value);
                }

                switch (type) {
                    case "string":
                        return quote(value);
                    case "number":
                        return isFinite(value) ? String(value) : "null";
                    case "boolean":
                        return String(value);
                    case "object":
                        if (!value) {
                            return "null";
                        }

                        switch (Object.prototype.toString.call(value)) {
                            case "[object Date]":
                                return isFinite(value.valueOf()) ? '"' + value.getUTCFullYear() + "-" + f(value.getUTCMonth() + 1) + "-" + f(value.getUTCDate()) + "T" + f(value.getUTCHours()) + ":" + f(value.getUTCMinutes()) + ":" + f(value.getUTCSeconds()) + "Z" + '"' : "null";
                            case "[object Array]":
                                len = value.length;
                                partial = [];
                                for (i = 0; i < len; i++) {
                                    partial.push(str(i, value) || "null");
                                }

                                return "[" + partial.join(",") + "]";
                            default:
                                partial = [];
                                for (i in value) {
                                    if (hasOwn.call(value, i)) {
                                        v = str(i, value);
                                        if (v) {
                                            partial.push(quote(i) + ":" + v);
                                        }
                                    }
                                }

                                return "{" + partial.join(",") + "}";
                        }
                }
            }("", {
                "": value
            });
        },

        checkCORSSupport: function checkCORSSupport() {
            if (atmosphere.util.browser.msie && !window.XDomainRequest && +atmosphere.util.browser.version.split(".")[0] < 11) {
                return true;
            } else if (atmosphere.util.browser.opera && +atmosphere.util.browser.version.split(".") < 12.0) {
                return true;
            }

            // KreaTV 4.1 -> 4.4
            else if (atmosphere.util.trim(navigator.userAgent).slice(0, 16) === "KreaTVWebKit/531") {
                    return true;
                }
                // KreaTV 3.8
                else if (atmosphere.util.trim(navigator.userAgent).slice(-7).toLowerCase() === "kreatel") {
                        return true;
                    }

            // Force older Android versions to use CORS as some version like 2.2.3 fail otherwise
            var ua = navigator.userAgent.toLowerCase();
            var androidVersionMatches = ua.match(/.+android ([0-9]{1,2})/i),
                majorVersion = parseInt(androidVersionMatches && androidVersionMatches[0] || -1, 10);
            if (!isNaN(majorVersion) && majorVersion > -1 && majorVersion < 3) {
                return true;
            }
            return false;
        }
    };

    guid = atmosphere.util.now();

    // Browser sniffing
    (function () {
        var ua = navigator.userAgent.toLowerCase(),
            match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) || ua.indexOf("android") < 0 && /version\/(.+) (safari)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];

        // Swaps variables
        if (match[2] === "safari") {
            match[2] = match[1];
            match[1] = "safari";
        }
        atmosphere.util.browser[match[1] || ""] = true;
        atmosphere.util.browser.version = match[2] || "0";
        atmosphere.util.browser.vmajor = atmosphere.util.browser.version.split(".")[0];

        // Trident is the layout engine of the Internet Explorer
        // IE 11 has no "MSIE: 11.0" token
        if (atmosphere.util.browser.trident) {
            atmosphere.util.browser.msie = true;
        }

        // The storage event of Internet Explorer and Firefox 3 works strangely
        if (atmosphere.util.browser.msie || atmosphere.util.browser.mozilla && +atmosphere.util.browser.version.split(".")[0] === 1) {
            atmosphere.util.storage = false;
        }
    })();

    atmosphere.callbacks = {
        unload: function unload() {
            atmosphere.util.debug(new Date() + " Atmosphere: " + "unload event");
            atmosphere.unsubscribe();
        },
        beforeUnload: function beforeUnload() {
            atmosphere.util.debug(new Date() + " Atmosphere: " + "beforeunload event");

            // ATMOSPHERE-JAVASCRIPT-143: Delay reconnect to avoid reconnect attempts before an actual unload (we don't know if an unload will happen, yet)
            atmosphere._beforeUnloadState = true;
            setTimeout(function () {
                atmosphere.util.debug(new Date() + " Atmosphere: " + "beforeunload event timeout reached. Reset _beforeUnloadState flag");
                atmosphere._beforeUnloadState = false;
            }, 5000);
        },
        offline: function offline() {
            atmosphere.util.debug(new Date() + " Atmosphere: offline event");
            _offline = true;
            if (requests.length > 0) {
                var requestsClone = [].concat(requests);
                for (var i = 0; i < requestsClone.length; i++) {
                    var rq = requestsClone[i];
                    if (rq.request.handleOnlineOffline) {
                        rq.close();
                        clearTimeout(rq.response.request.id);

                        if (rq.heartbeatTimer) {
                            clearTimeout(rq.heartbeatTimer);
                        }
                    }
                }
            }
        },
        online: function online() {
            atmosphere.util.debug(new Date() + " Atmosphere: online event");
            if (requests.length > 0) {
                for (var i = 0; i < requests.length; i++) {
                    if (requests[i].request.handleOnlineOffline) {
                        requests[i].init();
                        requests[i].execute();
                    }
                }
            }
            _offline = false;
        }
    };

    atmosphere.bindEvents = function () {
        atmosphere.util.on(window, "unload", atmosphere.callbacks.unload);
        atmosphere.util.on(window, "beforeunload", atmosphere.callbacks.beforeUnload);
        atmosphere.util.on(window, "offline", atmosphere.callbacks.offline);
        atmosphere.util.on(window, "online", atmosphere.callbacks.online);
    };

    atmosphere.unbindEvents = function () {
        atmosphere.util.off(window, "unload", atmosphere.callbacks.unload);
        atmosphere.util.off(window, "beforeunload", atmosphere.callbacks.beforeUnload);
        atmosphere.util.off(window, "offline", atmosphere.callbacks.offline);
        atmosphere.util.off(window, "online", atmosphere.callbacks.online);
    };

    atmosphere.bindEvents();

    return atmosphere;
});
/* jshint eqnull:true, noarg:true, noempty:true, eqeqeq:true, evil:true, laxbreak:true, undef:true, browser:true, indent:false, maxerr:50 */
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/atmosphere.js/lib/atmosphere.js","/lib/atmosphere.js/lib")
},{"_process":131,"buffer":121,"timers":152}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.asCredentials = asCredentials;

var _EnduserAuthService = require("./EnduserAuthService.js");

var _EnduserAuthService2 = _interopRequireDefault(_EnduserAuthService);

var _arrayEqual = require("array-equal");

var _arrayEqual2 = _interopRequireDefault(_arrayEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SidCredentials = function () {
    function SidCredentials(sid) {
        _classCallCheck(this, SidCredentials);

        this.sid = sid;
    }

    SidCredentials.prototype.getHeaders = function getHeaders() {
        return {
            "X-Stream-Sid": this.sid
        };
    };

    return SidCredentials;
}();

var WebmasterIpCredentials = function () {
    function WebmasterIpCredentials(wmid) {
        _classCallCheck(this, WebmasterIpCredentials);

        this.wmid = wmid;
    }

    WebmasterIpCredentials.prototype.getHeaders = function getHeaders() {
        return {
            "X-Stream-Wmid": this.wmid
        };
    };

    return WebmasterIpCredentials;
}();

var EnterpriseTokenCredentials = function () {
    function EnterpriseTokenCredentials(wmid, token) {
        _classCallCheck(this, EnterpriseTokenCredentials);

        this.wmid = wmid;
        this.token = token;
    }

    EnterpriseTokenCredentials.prototype.getHeaders = function getHeaders() {
        return {
            "X-Stream-Wmid": this.wmid,
            "Authorization": this.token
        };
    };

    return EnterpriseTokenCredentials;
}();

var DataToolCredentials = function () {
    function DataToolCredentials(token) {
        _classCallCheck(this, DataToolCredentials);

        this.data_token = token;
    }

    DataToolCredentials.prototype.getHeaders = function getHeaders() {
        return {
            "X-Stream-DataTool-Token": this.data_token
        };
    };

    return DataToolCredentials;
}();

function asCredentials(credentials) {
    var keys = Object.keys(credentials);
    if ((0, _arrayEqual2["default"])(keys, ["sid"])) {
        return new SidCredentials(credentials.sid);
    } else if ((0, _arrayEqual2["default"])(keys, ["wmid", "token"])) {
        return new EnterpriseTokenCredentials(credentials.wmid, credentials.token);
    } else if ((0, _arrayEqual2["default"])(keys, ["wmid"])) {
        return new WebmasterIpCredentials(credentials.wmid);
    } else if ((0, _arrayEqual2["default"])(keys, ["data_token"])) {
        return new DataToolCredentials(credentials.data_token);
    } else {
        throw new Error("Misconfigured credentials, should be one of {sid}, {wmid,token}, or {wmid}");
    }
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/auth/AuthService.js","/lib/auth")
},{"./EnduserAuthService.js":12,"_process":131,"array-equal":116,"buffer":121,"timers":152}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AUTHSERVICEURLS = {
    "ping": "/g/ping",
    "authenticate_post": "/p/authenticate/v0/?legacy=false"
};

var EnduserAuthService = function () {
    function EnduserAuthService(http, config) {
        _classCallCheck(this, EnduserAuthService);

        if (http == null) {
            throw new Error("AJAX cannot be null.");
        }

        var credentials = config.credentials;
        if (!credentials.wmid || !credentials.username || !credentials.password) {
            throw new Error('Cannot login if any of sid, username or password is empty.');
        }

        this.http = http;
        this.host = config.host || "app.quotemedia.com";
        this.credentials = credentials;
        this.application = config.application;
        this.method = "POST";
    }

    EnduserAuthService.prototype.login = function login(callback) {
        this.login_POST(callback);
    };

    EnduserAuthService.prototype.login_POST = function login_POST(callback) {
        var url = this.host + AUTHSERVICEURLS.authenticate_post + (this.application ? "&application=" + this.application : "");
        var req = {
            wmId: this.credentials.wmid,
            username: this.credentials.username,
            password: this.credentials.password
        };
        this.http({
            url: url,
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify(req),
            dataType: "json",
            success: this.handleSuccess(callback),
            failure: this.handleFailure(callback)
        });
    };

    EnduserAuthService.prototype.handleSuccess = function handleSuccess(callback) {
        return function (r) {
            if (r.code && r.code.name === 'Ok') {
                callback(null, r.sid);
            } else {
                callback(new Error("Login failed: " + r.code + ", " + r.message));
            }
        };
    };

    EnduserAuthService.prototype.handleFailure = function handleFailure(callback) {
        return function () {
            callback(new Error("Auth HTTP error"));
        };
    };

    return EnduserAuthService;
}();

exports["default"] = EnduserAuthService;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/auth/EnduserAuthService.js","/lib/auth")
},{"_process":131,"buffer":121,"timers":152}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

var _streamerApi = require("./streamer-api.js");

var _streamerUtils = require("./streamer-utils.js");

var utils = _interopRequireWildcard(_streamerUtils);

var _jsbi = require("jsbi");

var _jsbi2 = _interopRequireDefault(_jsbi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

/*
    Note: Usage of formatters can cause a potential performance penalty
*/

/* Keep synchronized with com.quotemedia.streamer.client.fmt.FmtMessage */

var fmt = {};

/**
 * Creates a new message formatter.
 * @constructor
 */
fmt.Formatter = function () {
    /**
     * Formatters by message type.
     */
    this.formatters = {};
    this.formatters[fmt.Formatter._UNKOWNTYPE] = this._fmtunknown;
    //
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.HEARTBEAT] = this._fmtheartbeat;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.SUBSCRIBE] = this._fmtsubscribe;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.SUBSCRIBE_RESPONSE] = this._fmtsubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.UNSUBSCRIBE_RESPONSE] = this._fmtunsubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.CONNECT_RESPONSE] = this._fmtconnectresponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.CONNECTION_CLOSE] = this._fmtconnectionclose;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.FLOW] = this._fmtflowmessage;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.OPEN_FLOW] = this._fmtopenflowmessage;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.SLOW_CONNECTION] = this._fmtslowconnection;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.STATS] = this._fmtstats;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.STATS_RESPONSE] = this._fmtstatsresponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.INITIAL_DATA_SENT] = this._fmtinitialdatasent;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.RESUBSCRIBE_MESSAGE] = this._fmtresubscribeMessage;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_SUBSCRIBE] = this._fmtexchangesubscribe;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_RESPONSE] = this._fmtexchangesubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_UNSUBSCRIBE_RESPONSE] = this._fmtexchangeunsubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.ALERTS_SUBUNSUB] = this._fmtalertsubunsub;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.ALERTS_SUBUNSUB_RESPONSE] = this._fmtalertsubunsubresponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.NEWS_SUBSCRIBE] = this._fmtnewssubscribe;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.NEWS_SUBSCRIBE_RESPONSE] = this._fmtnewssubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.TRADE_SUBSCRIBE] = this._fmttradesubscribe;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.TRADE_SUBSCRIBE_RESPONSE] = this._fmttradesubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.NEWS_UNSUBSCRIBE_RESPONSE] = this._fmtnewsunsubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.NEWS_CMD_FILTER_REFRESH_RESPONSE] = this._fmtnewscmdfilterrefreshresponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.NEWS_CMD_FILTER_RESPONSE] = this._fmtnewscmdfilterresponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.TRADE_UNSUBSCRIBE_RESPONSE] = this._fmttradeunsubscriberesponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.RECONNECT_RESPONSE] = this._fmtreconnectresponse;
    this.formatters[_streamerApi.messages.MessageTypeNames.ctrl.MISSED_DATA_SENT] = this._fmtmisseddatasent;

    //
    this.formatters[_streamerApi.messages.MessageTypeNames.data.QUOTE] = this._fmtquote;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.PRICEDATA] = this._fmtpricedata;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.TRADE] = this._fmttrade;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.INTERVAL] = this._fmtinterval;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.NETHOUSEPOSITION] = this._fmtnethouseposition;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.MMQUOTE] = this._fmtmmquote;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.BOOKORDER] = this._fmtbookorder;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.PURGEBOOK] = this._fmtpurgebook;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.BOOKDELETE] = this._fmtbookdelete;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.SYMBOLINFO] = this._fmtsymbolinfo;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.SYMBOLSTATUS] = this._fmtsymbolstatus;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.DERIVATIVEINFO] = this._fmtderivativeinfo;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.LASTSALE] = this._fmtlastsale;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.LIMITUPLIMITDOWN] = this._fmtlimituplimitdown;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.IVGREEKS] = this._fmtivgreeks;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.IMBALANCESTATUS] = this._fmtimbalancestatus;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.ALERT] = this._fmtalert;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.NEWS] = this._fmtnews;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.TRADENOTIFICATION] = this._fmttradeNotification;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.NEWSCMDFILTER] = this._fmtnewscmdfilter;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.NEWSERROR] = this._fmtnewserror;
    this.formatters[_streamerApi.messages.MessageTypeNames.data.DIVIDEND] = this._fmtdividend;
};

fmt.Formatter._UNKOWNTYPE = '__UNKNOWN__';

fmt.Formatter.prototype.fmt = function (val) {
    var _type = utils.messagetype(val);
    if (_type == null) {
        _type = fmt.Formatter._UNKOWNTYPE;
    }
    var _fmt = this.formatters[_type];
    if (_fmt == null) {
        _fmt = fmt.Formatter._UNKOWNTYPE;
    }
    return _fmt.call(this, val);
};

fmt.Formatter.prototype._fmtunknown = function (val) {
    if (val == null) {
        return "null";
    } else if (val["@T"]) {
        return utils.getMessageName(val);
    } else {
        return val.toString();
    }
};

fmt.Formatter.prototype._fmtquote = function (val) {
    var s = new fmt.StringBuilder();
    s.append('Q');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.indicator);
    s.sep();
    s.append(val.sharesPerSizeUnit);
    s.sep();
    s.append(val.bidPrice);
    s.sep();
    s.append(val.bidSize);
    s.sep();
    s.append(val.bidExcode);
    s.sep();
    s.append(val.bidCondition);
    s.sep();
    s.append(val.askPrice);
    s.sep();
    s.append(val.askSize);
    s.sep();
    s.append(val.askExcode);
    s.sep();
    s.append(val.askCondition);

    return s.toString();
};

fmt.Formatter.prototype._fmtpricedata = function (val) {
    var s = new fmt.StringBuilder();
    s.append('P');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.last);
    s.sep();
    s.append(val.lastTradeSize);
    s.sep();
    s.append(val.change);
    s.sep();
    s.append(val.percentChange);
    s.sep();
    s.append(val.tick);
    s.sep();
    s.append(val.tradeCount);
    s.sep();
    s.append(val.close);
    s.sep();
    s.append(val.previousClose);
    s.sep();
    s.append(val.open);
    s.sep();
    s.append(val.high);
    s.sep();
    s.append(val.annualHigh);
    s.sep();
    s.append(val.low);
    s.sep();
    s.append(val.annualLow);
    s.sep();
    s.datetime(val.lastTradeTime);
    s.sep();
    s.append(val.accumulatedPrice);
    s.sep();
    s.append(val.accumulatedVolume);
    s.sep();
    s.append(val.accumulatedTradeValue);
    s.sep();
    s.append(val.twap);
    s.sep();
    s.append(val.vwap);
    s.sep();
    s.datetime(val.preMarketTradeTime);
    s.sep();
    s.append(val.preMarketLast);
    s.sep();
    s.append(val.preMarketVolume);
    s.sep();
    s.append(val.preMarketChange);
    s.sep();
    s.append(val.preMarketPercentChange);
    s.sep();
    s.datetime(val.postMarketTradeTime);
    s.sep();
    s.append(val.postMarketLast);
    s.sep();
    s.append(val.postMarketVolume);
    s.sep();
    s.append(val.postMarketChange);
    s.sep();
    s.append(val.postMarketPercentChange);
    s.sep();
    s.append(val.lastTradeExcode);
    s.sep();
    s.append(val.currencyID);
    return s.toString();
};
fmt.Formatter.prototype._fmtlastsale = function (val) {
    var s = new fmt.StringBuilder();
    s.append('LS');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.last);
    s.sep();
    s.append(val.change);
    s.sep();
    s.append(val.percentChange);
    s.sep();
    s.append(val.accumulatedVolume);
    s.sep();
    s.append(val.tick);
    s.sep();
    s.append(val.lastTradeExcode);
    return s.toString();
};
fmt.Formatter.prototype._fmtlimituplimitdown = function (val) {
    var s = new fmt.StringBuilder();
    s.append('LULD');
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.datetime(val.effectiveTime);
    s.sep();
    s.append(val.lowerLimit);
    s.sep();
    s.append(val.upperLimit);
    s.sep();
    s.append(val.bidNotExecutable);
    s.sep();
    s.append(val.askNotExecutable);
    return s.toString();
};
fmt.Formatter.prototype._fmtivgreeks = function (val) {
    var s = new fmt.StringBuilder();
    s.append('IVG');
    s.sep();
    s.datetime(val.lastCalculation);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.delta);
    s.sep();
    s.append(val.gamma);
    s.sep();
    s.append(val.vega);
    s.sep();
    s.append(val.rho);
    s.sep();
    s.append(val.theta);
    s.sep();
    s.append(val.midIV);
    s.sep();
    s.append(val.midIVChange.toFixed(5));
    s.sep();
    s.append(val.bidIV);
    s.sep();
    s.append(val.askIV);
    s.sep();
    s.append(val.mark);
    s.sep();
    s.append(val.intrinsicValue);
    s.sep();
    s.append(val.extrinsicValue);
    s.sep();
    s.append(val.previousMark);
    s.sep();
    s.append(val.markChange);
    s.sep();
    s.append(val.markChangePercent);
    return s.toString();
};

fmt.Formatter.prototype._fmtimbalancestatus = function (val) {
    var s = new fmt.StringBuilder();
    s.append('IS');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.imbalanceType);
    s.sep();
    s.append(val.referencePrice);
    s.sep();
    s.append(val.size);
    s.sep();
    s.append(val.side);
    s.sep();
    s.append(val.pairedVolume);
    s.sep();
    s.append(val.nearIndicativePrice);
    s.sep();
    s.append(val.farIndicativePrice);
    s.sep();
    s.append(val.priceVariation);
    return s.toString();
};

fmt.Formatter.prototype._fmttrade = function (val) {
    var s = new fmt.StringBuilder();

    s.append('T');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.excode);
    s.sep();
    s.append(val.sequenceNumber);
    s.sep();
    s.append(val.matchID);
    s.sep();
    s.append(val.price);
    s.sep();
    s.append(val.size);
    s.sep();
    s.append(val.tick);
    s.sep();
    s.append(val.indicator);
    s.sep();
    s.append(val.rangeIndicator);
    s.sep();
    s.append(val.sellerID);
    s.sep();
    s.append(val.buyerID);
    s.sep();
    s.append(val.accumulatedVolume);
    s.sep();
    s.append(val.vwap);
    // TODO flags
    return s.toString();
};

fmt.Formatter.prototype._fmtinterval = function (val) {
    var s = new fmt.StringBuilder();
    s.append('I');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.last);
    s.sep();
    s.datetime(val.lastTime);
    s.sep();
    s.append(val.open);
    s.sep();
    s.datetime(val.openTime);
    s.sep();
    s.append(val.high);
    s.sep();
    s.append(val.low);
    s.sep();
    s.datetime(val.startTime);
    s.sep();
    s.append(val.tradeValue);
    s.sep();
    s.append(val.volume);
    s.sep();
    s.append(val.vwap);
    s.sep();
    s.append(val.periodMs);
    return s.toString();
};

fmt.Formatter.prototype._fmtnethouseposition = function (val) {
    var s = new fmt.StringBuilder();
    s.append('NHP');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.marketMakerID);
    s.sep();
    s.append(val.buyValue);
    s.sep();
    s.append(val.buyVolume);
    s.sep();
    s.append(val.buyBlockTransactions);
    s.sep();
    s.append(val.buyBlockValue);
    s.sep();
    s.append(val.buyBlockVolume);
    s.sep();
    s.append(val.sellValue);
    s.sep();
    s.append(val.sellVolume);
    s.sep();
    s.append(val.sellBlockTransactions);
    s.sep();
    s.append(val.sellBlockValue);
    s.sep();
    s.append(val.sellBlockVolume);
    return s.toString();
};

fmt.Formatter.prototype._fmtmmquote = function (val) {
    var s = new fmt.StringBuilder();
    s.append('MMQ');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.bidPrice);
    s.sep();
    s.append(val.bidSize);
    s.sep();
    s.append(val.bidChange);
    s.sep();
    s.append(val.askPrice);
    s.sep();
    s.append(val.askSize);
    s.sep();
    s.append(val.askChange);
    s.sep();
    s.append(val.indicator);
    s.sep();
    s.append(val.marketMakerID);
    s.sep();
    s.append(val.sharesPerSizeUnit);
    return s.toString();
};

fmt.Formatter.prototype._fmtbookorder = function (val) {
    var s = new fmt.StringBuilder();
    s.append('BO');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.excode);
    s.sep();
    s.append(val.orderID);
    s.sep();
    s.append(val.orderReference);
    s.sep();
    s.append(val.marketMakerID);
    s.sep();
    s.append(val.orderSide);
    s.sep();
    s.datetime(val.lastUpdate);
    s.sep();
    s.append(val.price);
    s.sep();
    s.append(val.size);
    s.sep();
    s.append(val.display);
    s.sep();
    s.append(val.orderChangeType);
    // TODO flags
    return s.toString();
};

fmt.Formatter.prototype._fmtpurgebook = function (val) {
    var s = new fmt.StringBuilder();
    s.append('PB');
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    return s.toString();
};

fmt.Formatter.prototype._fmtbookdelete = function (val) {
    var s = new fmt.StringBuilder();
    s.append('BD');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.orderReference);
    return s.toString();
};

fmt.Formatter.prototype._fmtsymbolinfo = function (val) {
    var s = new fmt.StringBuilder();
    s.append('SI');
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.excode);
    s.sep();
    s.append(val.instrumentType);
    s.sep();
    s.append(val.currencyId);
    s.sep();
    s.append(val.haltStatus);
    s.sep();
    s.append(val.haltIndicator);
    s.sep();
    s.append(val.regSHOStatus);
    s.sep();
    s.append(val.pqe);
    s.sep();
    s.append(val.caveatEmptor);
    s.sep();
    s.append(val.boardLotSize);
    return s.toString();
};

fmt.Formatter.prototype._fmtsymbolstatus = function (val) {
    var s = new fmt.StringBuilder();
    s.append('SS');
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.haltStatus);
    s.sep();
    s.append(val.haltIndicator);
    s.sep();
    s.append(val.regSHOStatus);
    s.sep();
    s.append(val.closingCalculatedPrice);
    s.sep();
    s.datetime(val.effectiveTime);
    s.sep();
    s.datetime(val.openingTime);
    s.sep();
    s.append(val.note);
    return s.toString();
};

fmt.Formatter.prototype._fmtderivativeinfo = function (val) {
    var s = new fmt.StringBuilder();
    s.append('DI');
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.rootSymbol);
    s.sep();
    s.datetime(val.expiration);
    s.sep();
    s.append(val.openInterest);
    s.sep();
    s.datetime(val.delivery);
    s.sep();
    s.append(val.contractSize);
    s.sep();
    s.append(val.callPutIndicator);
    s.sep();
    s.append(val.minTickSize);
    return s.toString();
};

fmt.Formatter.prototype._fmtalert = function (val) {
    var s = new fmt.StringBuilder();
    s.append('A');
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.locateCode);
    s.sep();
    s.append(val.instrumentType);
    s.sep();
    s.append(val.alertId);
    s.sep();
    s.append(val.triggerValue);

    return s.toString();
};

fmt.Formatter.prototype._fmtnews = function (val) {
    var s = new fmt.StringBuilder();
    s.append('N');
    s.sep();
    s.append(val.storyId);
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.storyUrl);
    s.sep();
    s.append(val.epochtime);
    s.sep();
    s.append(val.headline);
    s.sep();
    s.append(val.source);
    s.sep();
    s.append(val.sourceId);
    s.sep();
    s.append(val.lang);
    s.sep();
    s.append(val.symbol);
    s.sep();
    s.append(val.excode);
    s.sep();
    s.append(val.exgroup);
    s.sep();
    s.append(val.topic);
    s.sep();
    s.append(val.thumbnailUrl);
    s.sep();
    s.append(val.newsUrl);
    s.sep();
    s.append(val.videoUrl);
    s.sep();
    s.append(val.videoImageUrl);

    return s.toString();
};

fmt.Formatter.prototype._fmttradeNotification = function (val) {
    var s = new fmt.StringBuilder();
    s.append("TN");
    s.sep();
    s.append(val.accountId);
    s.sep();
    s.append(val.enduserId);
    s.sep();
    s.append(val.message);
    s.sep();
    s.append(val.eventType);

    return s.toString();
};

fmt.Formatter.prototype._fmtnewscmdfilter = function (val) {
    var s = new fmt.StringBuilder();
    s.append("NEWS CMD_FILTER");
    s.sep();
    s.append(val.srcName + ": [");
    s.append(val.srcValue);
    s.append("]");
    s.sep();
    s.append(val.topicName + ": [");
    s.append(val.topicValue);
    s.append("]");
    s.sep();
    s.append(val.symbolName + ": [");
    s.append(val.symbolValue);
    s.append("]");
    s.sep();
    s.append(val.excodeName + ": ");
    s.append(val.excodeValue);
    s.sep();
    s.append(val.exgroupName + ": ");
    s.append(val.exgroupValue);
    s.sep();
    s.append(val.summaryName + ": ");
    s.append(val.summaryValue);
    s.sep();
    s.append(val.summlenName + ": ");
    s.append(val.summlenValue);
    s.sep();
    s.append(val.constituentName + ": ");
    s.append(val.constituentValue);
    s.sep();
    s.append(val.searchByExchangeName + ": ");
    s.append(val.searchByExchangeValue);

    return s.toString();
};

fmt.Formatter.prototype._fmtnewserror = function (val) {
    var s = new fmt.StringBuilder();
    s.append("NEWS ERROR");
    s.sep();
    s.append("Event: " + val.event);
    s.sep();
    s.append("Code: " + val.code);
    s.sep();
    s.append("Message: " + val.message);

    return s.toString();
};

fmt.Formatter.prototype._fmtdividend = function (val) {
    var s = new fmt.StringBuilder();
    s.append("DV");
    s.sep();
    s.datetime(val.occuredOn);
    s.sep();
    s.append(val.symbolId);
    s.sep();
    s.append(val.instrument);
    s.sep();
    s.datetime(val.declarationDate);
    s.sep();
    s.datetime(val.executionDate);
    s.sep();
    s.datetime(val.recordDate);
    s.sep();
    s.datetime(val.paymentDate);
    s.sep();
    s.append(val.amount);
    s.sep();
    s.append(val.frequency);
    s.sep();
    s.append(val.paymentType);

    return s.toString();
};

fmt.Formatter.prototype._fmtheartbeat = function (val) {
    var s = new fmt.StringBuilder();
    s.append("HEARBEAT");
    s.sep();
    s.datetime(val.timestamp);
    return s.toString();
};

fmt.Formatter.prototype._fmtsubscribe = function (val) {
    var s = new fmt.StringBuilder();
    s.append('SUBSCRIBE');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtexchangesubscribe = function (val) {
    var s = new fmt.StringBuilder();
    s.append('EXCHANGE SUBSCRIBE');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtalertsubunsub = function (val) {
    var s = new fmt.StringBuilder();
    s.append('ALERT');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmttradesubscribe = function (val) {
    var s = new fmt.StringBuilder();
    s.append('TRADE');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtnewssubscribe = function (val) {
    var s = new fmt.StringBuilder();
    s.append('NEWS SUBSCRIBE');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtstats = function (val) {
    var s = new fmt.StringBuilder();
    s.append('STATS');
    return s.toString();
};

fmt.Formatter.prototype._fmtsubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('SUBSCRIBED');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtexchangesubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('EXCHANGE SUBSCRIBED');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtalertsubunsubresponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('ALERT SUBSCRIBED');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmttradesubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('TRADE SUBSCRIBED');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtnewssubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('NEWS SUBSCRIBED');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtnewsunsubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('NEWS UNSUBSCRIBED');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtnewscmdfilterrefreshresponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('NEWS COMMAND FILTER REFRESH');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtnewscmdfilterresponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('NEWS COMMAND FILTER');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtunsubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('UN-SUBSCRIBED');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtexchangeunsubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('EXCHANGE UNSUBSCRIBED');
    s.sep();
    this.__baseresponse(val, s);
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmttradeunsubscriberesponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('TRADE UNSUBSCRIBED');
    // TODO
    return s.toString();
};

fmt.Formatter.prototype._fmtconnectresponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('CONNECT');
    s.sep();
    this.__baseresponse(val, s);
    s.sep();
    s.append(val.version);
    s.sep();
    s.append(val.flowControlCheckInterval);
    s.sep();
    s.append(val.serverInstance);
    s.sep();
    s.append(val.conflationMs);
    s.sep();
    s.append(val.rejectExcessiveConnection);
    s.sep();
    s.append(val.maxEntitlementsPerSubscription);
    return s.toString();
};

fmt.Formatter.prototype._fmtreconnectresponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('RECONNECT');
    s.sep();
    s.append(val.version);
    s.sep();
    s.append(val.flowControlCheckInterval);
    s.sep();
    s.append(val.serverInstance);
    s.sep();
    s.append(val.conflationMs);
    s.sep();
    s.append(val.rejectExcessiveConnection);
    s.sep();
    s.append(val.maxEntitlementsPerSubscription);
    s.sep();
    s.sep(val.entitlements);
    s.sep();
    s.sep(val.exchangeEntitlements);
    return s.toString();
};

fmt.Formatter.prototype._fmtconnectionclose = function (val) {
    var s = new fmt.StringBuilder();
    s.append('CLOSE');
    s.sep();
    s.append(val.code);
    s.sep();
    s.append(val.reason);
    return s.toString();
};

fmt.Formatter.prototype._fmtslowconnection = function (val) {
    var s = new fmt.StringBuilder();
    s.append('SLOW');
    s.sep();
    s.append(val.timesExceeded);
    s.sep();
    s.append(val.maxExceed);
    return s.toString();
};

fmt.Formatter.prototype._fmtstatsresponse = function (val) {
    var s = new fmt.StringBuilder();
    s.append('STATS');
    s.sep();
    this.__baseresponse(val, s);
    s.sep();
    s.append('number of available l1 symbols: ');
    s.append(val.numberOfAvailableSymbolsL1);
    s.sep();
    s.append('number of available l2 symbols: ');
    s.append(val.numberOfAvailableSymbolsL2);
    s.sep();
    s.append('number of available connections: ');
    s.append(val.numberOfAvailableConnections);
    s.sep();
    s.append('number of subscribed l1 symbols: ');
    s.append(val.numberOfSubscribedSymbolsL1);
    s.sep();
    s.append('number of subscribed l2 symbols: ');
    s.append(val.numberOfSubscribedSymbolsL2);
    s.sep();
    s.append('number of open connections: ');
    s.append(val.numberOfOpenedConnections);
    s.sep();
    s.append('number of subscribed exchanges: ');
    s.append(val.numberOfSubscribedExchanges);
    return s.toString();
};

fmt.Formatter.prototype._fmtinitialdatasent = function (val) {
    var s = new fmt.StringBuilder();
    s.append("INITIAL DATA SENT");
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.requestId);
    return s.toString();
};

fmt.Formatter.prototype._fmtresubscribeMessage = function (val) {
    var s = new fmt.StringBuilder();
    s.append("RESUBSCRIBE MESSAGE");
    s.sep();
    s.datetime(val.timestamp);
    return s.toString();
};

fmt.Formatter.prototype._fmtflowmessage = function (val) {
    var s = new fmt.StringBuilder();
    s.append('FLOW');
    s.sep();
    s.append(val.sequence);
    return s.toString();
};

fmt.Formatter.prototype._fmtopenflowmessage = function (val) {
    var s = new fmt.StringBuilder();
    s.append('OPEN FLOW');
    s.sep();
    s.append(val.sequence);
    return s.toString();
};

fmt.Formatter.prototype.__baseresponse = function (val, s) {
    s.append(val.code);
    s.sep();
    s.append(val.reason);
};

fmt.Formatter.prototype._fmtmisseddatasent = function (val) {
    var s = new fmt.StringBuilder();
    s.append("MISSED DATA SENT");
    s.sep();
    s.datetime(val.timestamp);
    s.sep();
    s.append(val.requestId);
    s.sep();
    s.append(val.totalDataSent);
    s.sep();
    s.append(val.totalDataHeld);
    return s.toString();
};

/**
 * Create a new sting builder.
 * @constructor
 */
fmt.StringBuilder = function () {
    this._str = '';
};

fmt.StringBuilder.SEP = ', ';

fmt.StringBuilder.prototype.append = function (str) {
    this._str += str;
};

fmt.StringBuilder.prototype.sep = function () {
    this.append(fmt.StringBuilder.SEP);
};

fmt.StringBuilder.prototype.datetime = function (val) {
    if (val != null) {
        //        this._str += moment(val).format('YYYY-MM-DDTHH:mm:ss.SSS');
        var millis = val;
        if (val instanceof _jsbi2["default"]) {
            millis = _jsbi2["default"].toNumber(val);
        }
        this._str += "" + new Date(millis).toUTCString();
    } else {
        this._str += 'null';
    }
};

fmt.StringBuilder.prototype.toString = function () {
    return this._str;
};

fmt.msgfmt = new fmt.Formatter();

fmt.format = function (msg) {
    return fmt.msgfmt.fmt(msg);
};

module.exports = fmt;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/formatting.js","/lib")
},{"./streamer-api.js":108,"./streamer-utils.js":110,"_process":131,"buffer":121,"jsbi":128,"timers":152}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports["default"] = http;
var XMLHttpFactories = [function () {
    return new XMLHttpRequest();
}, function () {
    return new ActiveXObject("Msxml2.XMLHTTP");
}, function () {
    return new ActiveXObject("Msxml3.XMLHTTP");
}, function () {
    return new ActiveXObject("Microsoft.XMLHTTP");
}, function () {
    var _require = require("xmlhttprequest"),
        XMLHttpRequest = _require.XMLHttpRequest;

    return new XMLHttpRequest();
}];

var createXMLHTTPObject = function () {
    var i = null;

    return function () {
        if (i === null) {
            for (i = 0; i < XMLHttpFactories.length; i++) {
                try {
                    return XMLHttpFactories[i]();
                } catch (e) {}
            }
            if (i === XMLHttpFactories.length) {
                i = null;
                throw new Error("No HTTP implementation found.");
            }
        }
        return XMLHttpFactories[i]();
    };
}();

var getParser = function getParser(dataType) {
    switch (dataType ? dataType.toLowerCase() : dataType) {
        case "json":
            return JSON.parse;
        default:
            return function (result) {
                return result;
            };
    }
};

function http(opts) {
    var url = opts.url;
    var success = opts.success || function () {};
    var failure = opts.failure || function () {};
    var type = opts.type || "POST";
    var contentType = opts.contentType;
    var data = opts.data;
    var timeout = opts.timeout;

    var parseText = getParser(opts.dataType);

    var xhr = createXMLHTTPObject();
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            if (xhr.status === 200) {
                success(parseText(xhr.responseText));
            } else {
                failure(xhr.status);
            }
        }
    };
    xhr.open(type, url, true);
    if (contentType) {
        xhr.setRequestHeader("Content-Type", contentType);
    }
    if (timeout) {
        xhr.timeout = timeout;
    }
    xhr.send(data);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/http.js","/lib")
},{"_process":131,"buffer":121,"timers":152,"xmlhttprequest":157}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

var _json = require("json3");

var _json2 = _interopRequireDefault(_json);

require("./polyfills");

var _streamerUtils = require("./streamer-utils.js");

var utils = _interopRequireWildcard(_streamerUtils);

var _Streamer = require("./Streamer.js");

var _Streamer2 = _interopRequireDefault(_Streamer);

var _formatting = require("./formatting.js");

var fmt = _interopRequireWildcard(_formatting);

var _streamerApi = require("./streamer-api.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

if (window) {
    window.JSON = window.JSON || _json2["default"];
}

_Streamer2["default"].formatting = fmt;
/**
 * Checks for the streamer dataType,
 * @deprecated Use Streamer.marketDataTypes
 */
_Streamer2["default"].dataTypes = _streamerApi.messages.control.MarketdataType;
_Streamer2["default"].dataTypes.get = function (msg) {
    var messageType = utils.getMessageName(msg);
    if (_Streamer2["default"].dataTypes[messageType]) {
        return messageType;
    } else {
        return "UnknownType[" + messageType + "]";
    }
};

/**
 * Contains the different types of market data responses that come from the server
 * Use this instead of Streamer.dataTypes
 * */
_Streamer2["default"].marketDataTypes = _streamerApi.messages.market.MarketDataResponseTypes;
_Streamer2["default"].marketDataTypes.get = function (msg) {
    var messageType = utils.getMessageName(msg);
    if (_Streamer2["default"].marketDataTypes[messageType]) {
        return messageType;
    } else {
        return "UnknownType[" + messageType + "]";
    }
};

/**
 * Contains the different allowed subscription types.
 * It can be used along with the subscription requests.
 * For usage example:
 * @see subscription-example.html
 * */
_Streamer2["default"].subscriptionTypes = _streamerApi.messages.market.SubscriptionTypes;

module.exports = _Streamer2["default"];
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/index.js","/lib")
},{"./Streamer.js":7,"./formatting.js":13,"./polyfills":18,"./streamer-api.js":108,"./streamer-utils.js":110,"_process":131,"buffer":121,"json3":129,"timers":152}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.asLogger = asLogger;
function asLogger(logger) {
    if (!logger) {
        return asLogger({
            log: function log() {}
        });
    } else if (typeof logger === "function") {
        return asLogger({
            log: logger
        });
    } else {
        var _ret = function () {
            var extendedLogger = {
                log: function log(level) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }

                    if (logger[level]) {
                        logger[level].apply(logger, args);
                    } else if (logger.log) {
                        logger.log.apply(logger, [level].concat(args));
                    }
                }
            };

            var _arr = ["info", "error", "warn", "debug"];

            var _loop = function _loop() {
                var _level = _arr[_i];
                var level = _level;
                extendedLogger[level] = function () {
                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        args[_key2] = arguments[_key2];
                    }

                    extendedLogger.log.apply(extendedLogger, [level].concat(args));
                };
            };

            for (var _i = 0; _i < _arr.length; _i++) {
                _loop();
            }
            return {
                v: extendedLogger
            };
        }();

        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    }
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/logging.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
/* @see http://usejsdoc.org */

/**
 * Streamer api namespace.
 * @namespace
 */

/* ****************************************************************************************************************** */

/**
 * Supported encodings.
 * @enum
 */
var Encodings = exports.Encodings = {
    UNDEFINED: "undefined",
    UNDEFINED_CHAR: "U",

    NONE: "none",
    NONE_CHAR: "N",

    BASE64: "base64",
    BASE64_CHAR: "B"
};

/**
 * Supported mime types.
 * @enum
 */
var MimeTypes = exports.MimeTypes = {
    UNDEFINED: "undefined",
    UNDEFINED_CHAR: "U",

    JSON: "application/json",
    JSON_CHAR: "J",

    QMCI: "application/qmci",
    QMCI_CHAR: "Q",

    QITCH: "application/qitch",
    QITCH_CHAR: "I"
};

/**
* Returns the with '0' left padded string representation of the number.
* @param num {number} the number to create string for
* @param len {number} the target length of the string
* @return {string} the with '0' left padded string
* @throws Will throw an error if number doesn't fit within target length
*/
var lpad = exports.lpad = function lpad(num, len) {
    var _numstr = num.toString();
    if (_numstr.length == len) {
        return _numstr;
    } else if (_numstr.length > len) {
        throw "Number to long.";
    }
    var _pad;
    if (num >= 0) {
        _pad = "0";
    } else {
        _numstr = _numstr.slice(1);
        _pad = "-";
    }
    var _padlen = len - _numstr.length;
    for (var _i = 1; _i < _padlen; _i++) {
        // skip first pad char since it has been set '0' or '-'
        _pad += "0";
    }
    return _pad + _numstr;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/message.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.substr(position, searchString.length) === searchString;
    };
}

if (typeof Object.assign != 'function') {
    Object.assign = function (target, varArgs) {
        // .length of function is 2
        'use strict';

        if (target == null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource != null) {
                // Skip over if undefined or null
                for (var nextKey in nextSource) {
                    // Avoid bugs when hasOwnProperty is shadowed
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}

if (typeof Array.isArray != 'function') {
    Array.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

    Array.prototype.map = function (callback /*, thisArg*/) {

        var T, A, k;

        if (this == null) {
            throw new TypeError('this is null or not defined');
        }

        // 1. Let O be the result of calling ToObject passing the |this|
        //    value as the argument.
        var O = Object(this);

        // 2. Let lenValue be the result of calling the Get internal
        //    method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;

        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }

        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = arguments[1];
        }

        // 6. Let A be a new array created as if by the expression new Array(len)
        //    where Array is the standard built-in constructor with that name and
        //    len is the value of len.
        A = new Array(len);

        // 7. Let k be 0
        k = 0;

        // 8. Repeat, while k < len
        while (k < len) {

            var kValue, mappedValue;

            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal
            //    method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {

                // i. Let kValue be the result of calling the Get internal
                //    method of O with argument Pk.
                kValue = O[k];

                // ii. Let mappedValue be the result of calling the Call internal
                //     method of callback with T as the this value and argument
                //     list containing kValue, k, and O.
                mappedValue = callback.call(T, kValue, k, O);

                // iii. Call the DefineOwnProperty internal method of A with arguments
                // Pk, Property Descriptor
                // { Value: mappedValue,
                //   Writable: true,
                //   Enumerable: true,
                //   Configurable: true },
                // and false.

                // In browsers that support Object.defineProperty, use the following:
                // Object.defineProperty(A, k, {
                //   value: mappedValue,
                //   writable: true,
                //   enumerable: true,
                //   configurable: true
                // });

                // For best browser support, use the following:
                A[k] = mappedValue;
            }
            // d. Increase k by 1.
            k++;
        }

        // 9. return A
        return A;
    };
}

if (!Array.from) {
    Array.from = function () {
        var toStr = Object.prototype.toString;
        var isCallable = function isCallable(fn) {
            return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
        };
        var toInteger = function toInteger(value) {
            var number = Number(value);
            if (isNaN(number)) {
                return 0;
            }
            if (number === 0 || !isFinite(number)) {
                return number;
            }
            return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
        };
        var maxSafeInteger = Math.pow(2, 53) - 1;
        var toLength = function toLength(value) {
            var len = toInteger(value);
            return Math.min(Math.max(len, 0), maxSafeInteger);
        };

        // The length property of the from method is 1.
        return function from(arrayLike /*, mapFn, thisArg */) {
            // 1. Let C be the this value.
            var C = this;

            // 2. Let items be ToObject(arrayLike).
            var items = Object(arrayLike);

            // 3. ReturnIfAbrupt(items).
            if (arrayLike == null) {
                throw new TypeError('Array.from requires an array-like object - not null or undefined');
            }

            // 4. If mapfn is undefined, then let mapping be false.
            var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
            var T;
            if (typeof mapFn !== 'undefined') {
                // 5. else
                // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
                if (!isCallable(mapFn)) {
                    throw new TypeError('Array.from: when provided, the second argument must be a function');
                }

                // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
                if (arguments.length > 2) {
                    T = arguments[2];
                }
            }

            // 10. Let lenValue be Get(items, "length").
            // 11. Let len be ToLength(lenValue).
            var len = toLength(items.length);

            // 13. If IsConstructor(C) is true, then
            // 13. a. Let A be the result of calling the [[Construct]] internal method
            // of C with an argument list containing the single item len.
            // 14. a. Else, Let A be ArrayCreate(len).
            var A = isCallable(C) ? Object(new C(len)) : new Array(len);

            // 16. Let k be 0.
            var k = 0;
            // 17. Repeat, while k < len (also steps a - h)
            var kValue;
            while (k < len) {
                kValue = items[k];
                if (mapFn) {
                    A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                } else {
                    A[k] = kValue;
                }
                k += 1;
            }
            // 18. Let putStatus be Put(A, "length", len, true).
            A.length = len;
            // 20. Return A.
            return A;
        };
    }();
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/polyfills.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _Bytes = require("./Bytes");

var _Bytes2 = _interopRequireDefault(_Bytes);

var _DataOperations = require("./DataOperations");

var _QitchConstants = require("./QitchConstants");

var _Qitch = require("./Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BlockHeader = function () {
    function BlockHeader() {
        _classCallCheck(this, BlockHeader);
    }

    BlockHeader.lengthToBytes = function lengthToBytes(dst, offset, value) {
        return _Bytes2["default"].putshort(dst, offset + _QitchConstants.BLOCK_HEADER_LENGTH_OFFSET, _DataOperations.UShort.fromint(value));
    };

    BlockHeader.lengthGetValue = function lengthGetValue(src, offset) {
        return _Bytes2["default"].getshort(src, offset + _QitchConstants.BLOCK_HEADER_LENGTH_OFFSET);
    };

    BlockHeader.messageCountToBytes = function messageCountToBytes(dst, offset, value) {
        dst[offset + _QitchConstants.BLOCK_HEADER_MESSAGECOUNT_OFFSET] = _DataOperations.UByte.fromint(value);
        return dst;
    };

    BlockHeader.messageCountGetValue = function messageCountGetValue(src, offset) {
        return _DataOperations.UByte.frombyte(src[offset + _QitchConstants.BLOCK_HEADER_MESSAGECOUNT_OFFSET]);
    };

    BlockHeader.reservedToBytes = function reservedToBytes(dst, offset, value) {
        dst[offset + _QitchConstants.BLOCK_HEADER_RESERVED_OFFSET] = value;
        return dst;
    };

    BlockHeader.sequenceToBytes = function sequenceToBytes(dst, offset, val) {
        return _Qitch2["default"].putUInt32(dst, offset + _QitchConstants.BLOCK_HEADER_SEQUENCE_OFFSET, val);
    };

    BlockHeader.sequenceGetValue = function sequenceGetValue(src, offset) {
        return _Qitch2["default"].uint32(src, offset + _QitchConstants.BLOCK_HEADER_SEQUENCE_OFFSET);
    };

    return BlockHeader;
}();

exports["default"] = BlockHeader;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/BlockHeader.js","/lib/qitch")
},{"./Bytes":20,"./DataOperations":21,"./Qitch":25,"./QitchConstants":26,"_process":131,"buffer":121,"timers":152}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _jsbi = require("jsbi");

var _jsbi2 = _interopRequireDefault(_jsbi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TWO_POW_EIGHT = Math.pow(2, 8);
var TWO_POW_SIXTEEN = Math.pow(2, 16);
var TWO_POW_TWENTY_FOUR = Math.pow(2, 24);
var BIG_INT_THIRTY_TWO = _jsbi2["default"].BigInt(32);
var BIG_INT_FORTY = _jsbi2["default"].BigInt(40);
var BIG_INT_FORTY_EIGHT = _jsbi2["default"].BigInt(48);
var BIG_INT_FIFTY_SIX = _jsbi2["default"].BigInt(56);

/*
    Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
 */
/**
 * Translates bytes into numbers and vice versa.
 * Use multiplication instead of shifts because in javascript shifts are slower than multiplication
 * (under the hood shifts call ToInt32 which is slower than ToNumber in multiplication).
 */

var Bytes = function () {
    function Bytes() {
        _classCallCheck(this, Bytes);
    }

    Bytes.putshort = function putshort(dst, offset, val) {
        dst[offset] = val >> 8;
        dst[offset + 1] = val;
        return dst;
    };

    /**
     * Gets numeric value that is in range of short (Int16) from byte array
     * @param src The source array
     * @param offset The offset
     * @returns {number} Resulting short value
     */


    Bytes.getshort = function getshort(src, offset) {
        return src[offset] * TWO_POW_EIGHT | // val << 8
        src[offset + 1] & 0xff;
    };

    Bytes.putint = function putint(dst, offset, val) {
        dst[offset] = val >> 24;
        dst[offset + 1] = val >> 16;
        dst[offset + 2] = val >> 8;
        dst[offset + 3] = val;
        return dst;
    };

    /**
     * Gets numeric value that is in range of integer (Int32) from byte array
     * @param src The source array
     * @param offset The offset
     * @returns {number} Resulting int value
     */


    Bytes.getint = function getint(src, offset) {
        return src[offset] * TWO_POW_TWENTY_FOUR | // val << 24
        (src[offset + 1] & 0xff) * TWO_POW_SIXTEEN | // val << 16
        (src[offset + 2] & 0xff) * TWO_POW_EIGHT | // val << 8
        src[offset + 3] & 0xff;
    };

    /**
     * Gets numeric value that is in range of long (Int64) from byte array.
     * @param src The source array
     * @param offset The offset
     * @returns {JSBI} Resulting string representation of long.
     */


    Bytes.getlong = function getlong(src, offset) {
        return _jsbi2["default"].bitwiseOr(_jsbi2["default"].bitwiseOr(_jsbi2["default"].bitwiseOr(_jsbi2["default"].leftShift(_jsbi2["default"].BigInt(src[offset]), BIG_INT_FIFTY_SIX), _jsbi2["default"].leftShift(_jsbi2["default"].BigInt(src[offset + 1] & 0xff), BIG_INT_FORTY_EIGHT)), _jsbi2["default"].bitwiseOr(_jsbi2["default"].leftShift(_jsbi2["default"].BigInt(src[offset + 2] & 0xff), BIG_INT_FORTY), _jsbi2["default"].leftShift(_jsbi2["default"].BigInt(src[offset + 3] & 0xff), BIG_INT_THIRTY_TWO))), _jsbi2["default"].bitwiseOr(_jsbi2["default"].bitwiseOr(_jsbi2["default"].BigInt((src[offset + 4] & 0xff) * TWO_POW_TWENTY_FOUR), _jsbi2["default"].BigInt((src[offset + 5] & 0xff) * TWO_POW_SIXTEEN)), _jsbi2["default"].bitwiseOr(_jsbi2["default"].BigInt((src[offset + 6] & 0xff) * TWO_POW_EIGHT), _jsbi2["default"].BigInt(src[offset + 7] & 0xff))));
    };

    return Bytes;
}();

exports["default"] = Bytes;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/Bytes.js","/lib/qitch")
},{"_process":131,"buffer":121,"jsbi":128,"timers":152}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UShort = function () {
    function UShort() {
        _classCallCheck(this, UShort);
    }

    UShort.fromint = function fromint(val) {
        if (val < UShort.prototype.MIN_VALUE) {
            throw "Value underflows unsiged short";
        } else if (val > UShort.prototype.MAX_VALUE) {
            throw "Value overflows unsigned short";
        }
        return val < UShort.prototype.MAX_SHORT_VALUE ? val : val - (UShort.prototype.MAX_VALUE + 1);
    };

    UShort.fromshort = function fromshort(val) {
        return val & 0xffff;
    };

    return UShort;
}();

/**
 * Length in bytes
 */


UShort.prototype.LENGTH = 2;
UShort.prototype.MIN_VALUE = 0;
UShort.prototype.MAX_VALUE = 65535;
UShort.prototype.MAX_SHORT_VALUE = 32767;

var UByte = function () {
    function UByte() {
        _classCallCheck(this, UByte);
    }

    UByte.fromint = function fromint(val) {
        if (val < UByte.prototype.MIN_VALUE) {
            throw "Value underflows unsigned byte";
        } else if (val > UByte.prototype.MAX_VALUE) {
            throw "Value overflows unsigned byte";
        }
        return val < UByte.prototype.BYTE_MAX_VALUE ? val : val - (UByte.prototype.MAX_VALUE + 1);
    };

    UByte.frombyte = function frombyte(val) {
        return val & 0xff;
    };

    return UByte;
}();

/**
 * Length in bytes
 */


UByte.prototype.LENGTH = 1;
UByte.prototype.MIN_VALUE = 0;
UByte.prototype.MAX_VALUE = 255;
UByte.prototype.BYTE_MAX_VALUE = 127;

var UInt = function () {
    function UInt() {
        _classCallCheck(this, UInt);
    }

    UInt.fromlong = function fromlong(val) {
        if (val < UInt.prototype.MIN_VALUE) {
            throw "Value underfows unsigned int";
        } else if (val > UInt.prototype.MAX_VALUE) {
            throw "Value overflows unsigned int";
        }
        return val < UInt.prototype.INT_MAX_VALUE ? val : val - (UInt.prototype.MAX_VALUE + 1);
    };

    UInt.fromint = function fromint(val) {
        return val & 0xffffffff;
    };

    return UInt;
}();

/**
 * Length in bytes
 */


UInt.prototype.LENGTH = 4;
UInt.prototype.MIN_VALUE = 0;
UInt.prototype.MAX_VALUE = 4294967295;
UInt.prototype.INT_MAX_VALUE = 0x7fffffff;

var ASCIIString = function () {
    function ASCIIString() {
        _classCallCheck(this, ASCIIString);
    }

    ASCIIString.put = function put(dst, offset, val, fixedlength) {
        if (dst.length < offset + fixedlength) {
            throw "Not enough space in destination array";
        }
        var pos = offset;
        if (val != null && !(val.length === 0)) {
            if (val.length > fixedlength) {
                throw "String overflows maximum length";
            }
            var i = void 0;
            for (i = 0; i < val.length; i++) {
                dst[pos++] = val.charAt(i).charCodeAt(0); // ASCII single byte character encoding
            }
        }
        // pad right
        var j = void 0;
        for (j = pos; j < offset + fixedlength; j++) {
            dst[j] = ASCIIString.prototype.PADDING;
        }
        return dst;
    };

    ASCIIString.get = function get(src, offset, fixedlength) {
        var pos = offset;
        var length = fixedlength;
        if (src.length < pos + length) {
            throw "Not enough bytes in source array";
        }
        // trim right padding
        while (length > 0 && src[pos + length - 1] === ASCIIString.prototype.PADDING) {
            length--;
        }
        return String.fromCharCode.apply(String, src.slice(pos, pos + length));
    };

    return ASCIIString;
}();

ASCIIString.prototype.PADDING = 0x20; // ASCII SPACE

exports.UByte = UByte;
exports.UShort = UShort;
exports.UInt = UInt;
exports.ASCIIString = ASCIIString;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/DataOperations.js","/lib/qitch")
},{"_process":131,"buffer":121,"timers":152}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _streamerApi = require("../streamer-api");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NumericMarketdataType = {
    1: "QUOTE",
    2: "PRICEDATA",
    3: "TRADE",
    4: "MMQUOTE",
    5: "ORDERBOOK",
    6: "INTERVAL",
    7: "NETHOUSEPOSITION",
    8: "LASTSALE",
    9: "LIMITUPLIMITDOWN",
    10: "IVGREEKS",
    11: "IMBALANCESTATUS"
};

var EnumValueTranslator = function () {
    function EnumValueTranslator() {
        _classCallCheck(this, EnumValueTranslator);
    }

    EnumValueTranslator.marketdatatypeToInt = function marketdatatypeToInt(val) {
        return Object.keys(NumericMarketdataType).find(function (key) {
            return NumericMarketdataType[key] === val;
        });
    };

    EnumValueTranslator.ubyteToMarketdataType = function ubyteToMarketdataType(val) {
        return NumericMarketdataType[val];
    };

    EnumValueTranslator.ubyteToEntitlementType = function ubyteToEntitlementType(val) {
        switch (val) {
            case 1:
                return "RT";
            case 2:
                return "RTN";
            case 3:
                return "RTB";
            case 4:
                return "DL";
            case 6:
                return "RTO";
            case 7:
                return "DLO";
            case 8:
                return "DLN";
            default:
                return "NA";
        }
    };

    EnumValueTranslator.subscribeActionToChar = function subscribeActionToChar(val) {
        switch (val) {
            case _streamerApi.messages.control.Action.SUBSCRIBE:
                return 'S';
            case _streamerApi.messages.control.Action.UNSUBSCRIBE:
                return 'U';
        }
    };

    return EnumValueTranslator;
}();

exports["default"] = EnumValueTranslator;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/EnumValueTranslator.js","/lib/qitch")
},{"../streamer-api":108,"_process":131,"buffer":121,"timers":152}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _streamerApi = require("../streamer-api");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LocateCodeInjector = function () {
    function LocateCodeInjector() {
        _classCallCheck(this, LocateCodeInjector);

        this.symbols = new Map();
    }

    LocateCodeInjector.prototype.injectLocateCode = function injectLocateCode(message) {
        if (message instanceof _streamerApi.messages.market.SymbolInfo) {
            this.symbols.set(message.locateCode, message.symbol);
        } else if (message instanceof _streamerApi.messages.market.DataMessage) {
            if (message.locateCode !== null && !(message instanceof _streamerApi.messages.market.ImbalanceStatus) && !(message instanceof _streamerApi.messages.market.SymbolStatus) && !(message instanceof _streamerApi.messages.market.Alert)) {
                message.symbol = this.symbols.get(message.locateCode);
            }
        }
    };

    return LocateCodeInjector;
}();

exports["default"] = LocateCodeInjector;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/LocateCodeInjector.js","/lib/qitch")
},{"../streamer-api":108,"_process":131,"buffer":121,"timers":152}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _Bytes = require("./Bytes");

var _Bytes2 = _interopRequireDefault(_Bytes);

var _DataOperations = require("./DataOperations");

var _QitchConstants = require("./QitchConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MessageHeader = function () {
    function MessageHeader() {
        _classCallCheck(this, MessageHeader);
    }

    MessageHeader.lengthGetValue = function lengthGetValue(src, offset) {
        return _DataOperations.UShort.fromshort(_Bytes2["default"].getshort(src, offset + _QitchConstants.MESSAGE_HEADER_LENGTH_OFFSET));
    };

    MessageHeader.lengthGetBytes = function lengthGetBytes(dst, offset, val) {
        return _Bytes2["default"].putshort(dst, offset + _QitchConstants.MESSAGE_HEADER_LENGTH_OFFSET, _DataOperations.UShort.fromint(val));
    };

    MessageHeader.typeGetValue = function typeGetValue(src, offset) {
        return _DataOperations.UByte.frombyte(src[offset + _QitchConstants.MESSAGE_HEADER_TYPE_OFFSET]);
    };

    MessageHeader.typeGetBytes = function typeGetBytes(dst, offset, val) {
        dst[offset + _QitchConstants.MESSAGE_HEADER_TYPE_OFFSET] = _DataOperations.UByte.fromint(val);
        return dst;
    };

    return MessageHeader;
}();

exports["default"] = MessageHeader;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/MessageHeader.js","/lib/qitch")
},{"./Bytes":20,"./DataOperations":21,"./QitchConstants":26,"_process":131,"buffer":121,"timers":152}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _streamerApi = require("../streamer-api");

var _QitchConstants = require("./QitchConstants");

var Constants = _interopRequireWildcard(_QitchConstants);

var _Bytes = require("./Bytes");

var _Bytes2 = _interopRequireDefault(_Bytes);

var _DataOperations = require("./DataOperations");

var _bignumber = require("bignumber.js");

var _bignumber2 = _interopRequireDefault(_bignumber);

var _jsbi = require("jsbi");

var _jsbi2 = _interopRequireDefault(_jsbi);

var _EnumValueTranslator = require("./EnumValueTranslator");

var _EnumValueTranslator2 = _interopRequireDefault(_EnumValueTranslator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
     Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
 */
var Qitch = function () {
    function Qitch() {
        _classCallCheck(this, Qitch);
    }

    /**
     * Copies an array from the specified source array, beginning at sourceIndex,
     * to the specified position of the destination array.
     * The number of components copied is equal to the length argument. The elements are copied
     * into a destination array starting from destinationIndex.
     * @param sourceArray The source array
     * @param sourceIndex The starting position in the source array.
     * @param destinationArray The destination array
     * @param destinationIndex The starting position in the destination array.
     * @param length The number of array elements to be copied.
     */
    Qitch.copyArray = function copyArray(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        if (length === 0) {
            return;
        }
        if (!(sourceArray instanceof Int8Array)) {
            throw "Source must be a byte array";
        }
        if (!(destinationArray instanceof Int8Array)) {
            throw "Destination must be a byte array";
        }
        if (sourceIndex >= sourceArray.length) {
            throw "Source index is out of range. Index: " + sourceIndex + ", max length: " + sourceArray.length;
        }
        if (destinationIndex >= destinationArray.length) {
            throw "Destination index is out of range. Index: " + destinationIndex + ", max length: " + destinationArray.length;
        }
        if (sourceIndex + length > sourceArray.length || destinationIndex + length > destinationArray.length) {
            throw "Length is out of range";
        }
        var i = void 0;
        for (i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    };

    /**
     * Gets boolean value from source byte array at specified position.
     * @param src The source array.
     * @param offset The offset.
     * @returns {boolean} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.bool = function bool(src, offset) {
        if (src instanceof Int8Array) {
            return src[offset] !== 0;
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
    * Puts boolean value into destination array.
    * @param dst The destination array
    * @param offset The offset.
    * @param val Boolean value.
    * @returns {Int8Array} destination array.
    * @throws Exception in case if dst is not {@link Int8Array}
    */


    Qitch.putBool = function putBool(dst, offset, val) {
        if (dst instanceof Int8Array) {
            dst[offset] = val ? 1 : 0;
            return dst;
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Puts byte value into destination array.
     * @param dst The destination array
     * @param offset The offset.
     * @param val Byte value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putByte = function putByte(dst, offset, val) {
        if (dst instanceof Int8Array) {
            dst[offset] = _DataOperations.UByte.fromint(val);
            return dst;
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets integer (int32) value from source byte array at specified position.
     * @param src The source array.
     * @param offset The offset.
     * @returns {number} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.int32 = function int32(src, offset) {
        if (src instanceof Int8Array) {
            return _Bytes2["default"].getint(src, offset);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Sets integer (int32) value to destination array
     * @param dst destination array
     * @param offset offset
     * @param val integer value
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putInt32 = function putInt32(dst, offset, val) {
        if (dst instanceof Int8Array) {
            return _Bytes2["default"].putint(dst, offset, val);
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets unsigned integer (uint32) value from source byte array at specified position.
     * @param src The source array.
     * @param offset The offset.
     * @returns {number} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.uint32 = function uint32(src, offset) {
        if (src instanceof Int8Array) {
            return _DataOperations.UInt.fromint(_Bytes2["default"].getint(src, offset));
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Sets unsigned integer (uint32) value to destination array
     * @param dst destination array
     * @param offset offset
     * @param val unsigned integer value
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putUInt32 = function putUInt32(dst, offset, val) {
        if (dst instanceof Int8Array) {
            return _Bytes2["default"].putint(dst, offset, _DataOperations.UInt.fromlong(val));
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets single character from source byte array at specified position.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null if offset is out of array index range or
     * value is equal to {@link Constants#ASCII_NULL}, otherwise returns the obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.asciichar = function asciichar(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            var value = src[offset];
            return value !== Constants.ASCII_NULL ? String.fromCharCode(value) : null;
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets long (int64) value from source byte array at specified position. Since javascript doesn't support long values,
     * it is returned as {@link JSBI.BigInt}.
     * @param src The source array.
     * @param offset The offset.
     * @returns {JSBI} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.int64 = function int64(src, offset) {
        if (src instanceof Int8Array) {
            return _Bytes2["default"].getlong(src, offset);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets double value from byte source array at specified position.
     * In QITCH double values are sent as longs and then divided by {@link Constants#PRICE_DIVISOR}. Since javascript
     * doesn't support long values, the result is returned as {@link BigNumber}.
     * @param src The source array.
     * @param offset The offset.
     * @returns {BigNumber} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.dec8double = function dec8double(src, offset) {
        if (src instanceof Int8Array) {
            return new _bignumber2["default"](_Bytes2["default"].getlong(src, offset).toString()).dividedBy(Constants.PRICE_DIVISOR);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets signed byte from source byte array at specified position.
     * @param src The source array.
     * @param offset The offset.
     * @returns {number} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.sbyte = function sbyte(src, offset) {
        if (src instanceof Int8Array) {
            return src[offset];
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets timestamp value from source byte array at specified offset. Since javascript doesn't support long values,
     * it is returned as {@link JSBI.BigInt}
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|JSBI} Returns null if value is equal to {@link Constants#TIMESTAMP_NULL}
     * otherwise returns the obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.timestamp = function timestamp(src, offset) {
        if (src instanceof Int8Array) {
            var value = _Bytes2["default"].getlong(src, offset);
            return _jsbi2["default"].equal(value, Constants.TIMESTAMP_NULL) ? null : value;
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets locate code value from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {number} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.locatecode = function locatecode(src, offset) {
        if (src instanceof Int8Array) {
            return _Bytes2["default"].getint(src, offset);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets symbol value from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + symbol length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.symbol = function symbol(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.SYMBOL_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.SYMBOL_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Puts symbol value into destination array.
     * @param dst The destination array.
     * @param offset The offset.
     * @param val Symbol value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putSymbol = function putSymbol(dst, offset, val) {
        if (dst instanceof Int8Array) {
            return _DataOperations.ASCIIString.put(dst, offset, val, Constants.SYMBOL_LENGTH);
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets String value from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @param maxLength The max length of returning value.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + maxLength in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.asciiString = function asciiString(src, offset, maxLength) {
        if (src instanceof Int8Array) {
            return _DataOperations.ASCIIString.get(src, offset, maxLength);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Puts String value into destination array.
     * @param dst The destination array.
     * @param offset The offset.
     * @param val String value.
     * @param maxLength The max length of returning value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putAsciiString = function putAsciiString(dst, offset, val, maxLength) {
        if (dst instanceof Int8Array) {
            return _DataOperations.ASCIIString.put(dst, offset, val, maxLength);
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets excode value from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + excode length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.excode = function excode(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.EXCODE_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.EXCODE_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Puts excode value into destination array.
     * @param dst The destination array.
     * @param offset The offset.
     * @param val excode value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putExcode = function putExcode(dst, offset, val) {
        if (dst instanceof Int8Array) {
            return _DataOperations.ASCIIString.put(dst, offset, val, Constants.EXCODE_LENGTH);
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets mmid value from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + excode length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.mmid = function mmid(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.MMID_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.MMID_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets numeric order id value from source byte array at specified offset. Since javascript doesn't support long values,
     * it is returned as {@link JSBI.BigInt}
     * @param src The source array.
     * @param offset The offset.
     * @returns {JSBI} Returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.orderId = function orderId(src, offset) {
        if (src instanceof Int8Array) {
            return _Bytes2["default"].getlong(src, offset);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets order id as string from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + order id length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.orderIdLegacy = function orderIdLegacy(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.ORDERID_LENGTH > src.length) {
                return null;
            }
            return _Bytes2["default"].getlong(src, offset).toString();
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets currency id from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + currency id length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.currencyid = function currencyid(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.CURRENCYID_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.CURRENCYID_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets tick from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {string|null} Returns null in case if offset is out of array index range,
     * otherwise character at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.tick = function tick(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            return String.fromCharCode(src[offset]);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets order change type from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|*} Returns null in case if offset is out of array index range,
     * otherwise {@link messages.market.OrderChangeType} value that corresponds to the character at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.bookOrderChangeType = function bookOrderChangeType(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            var c = String.fromCharCode(src[offset]);
            if (c === Constants.ASCIICHAR_NULL) {
                return null;
            }
            return _streamerApi.messages.market.OrderChangeType[c];
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets order side from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {string|null} Returns null in case if offset is out of array index range,
     * otherwise character at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.orderside = function orderside(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            var c = String.fromCharCode(src[offset]);
            if (c === Constants.ASCIICHAR_NULL) {
                return null;
            }
            return c;
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets range indicator from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {string|null} Returns null in case if offset is out of array index range,
     * otherwise character at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.rangeindicator = function rangeindicator(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            return String.fromCharCode(src[offset]);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets instrument type from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|*} Returns null in case if offset is out of array index range,
     * otherwise {@link messages.market.InstrumentType} value that corresponds to the byte at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.instrumenttype = function instrumenttype(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            return _streamerApi.messages.market.InstrumentType[_DataOperations.UByte.frombyte(src[offset])];
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets imbalance type from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|*} Returns null in case if offset is out of array index range,
     * otherwise {@link messages.market.ImbalanceType} value that corresponds to the byte at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.imbalancetype = function imbalancetype(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            return _streamerApi.messages.market.ImbalanceType[_DataOperations.UByte.frombyte(src[offset])];
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets order refernece from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + order reference length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.orderreference = function orderreference(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.ORDER_REFERENCE_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.ORDER_REFERENCE_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets response reason from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + reason length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.reason = function reason(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.REASON_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.REASON_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets streamer version from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + version length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.version = function version(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.VERSION_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.VERSION_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets server instance from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + server instance length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.serverInstance = function serverInstance(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.SERVER_INSTANCE_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.SERVER_INSTANCE_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets the note message from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if specified offset is too big (offset + note length in bytes is bigger than length of source array),
     * otherwise returns obtained value.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.note = function note(src, offset) {
        if (src instanceof Int8Array) {
            if (offset + Constants.NOTE_LENGTH > src.length) {
                return null;
            }
            return _DataOperations.ASCIIString.get(src, offset, Constants.NOTE_LENGTH);
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Puts action value into destination array.
     * @param dst The destination array.
     * @param offset The offset.
     * @param val Action value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putAction = function putAction(dst, offset, val) {
        if (dst instanceof Int8Array) {
            dst[offset] = _EnumValueTranslator2["default"].subscribeActionToChar(val).charCodeAt(0);
            return dst;
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Puts mimetype value into destination array.
     * @param dst The destination array.
     * @param offset The offset.
     * @param val Mimetype value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putMimetype = function putMimetype(dst, offset, val) {
        if (dst instanceof Int8Array) {
            return _DataOperations.ASCIIString.put(dst, offset, val, Constants.MIMETYPE_LENGTH);
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Puts conflation value into destination array. If conflation is null, -1 will be put instead.
     * @param dst The destination array.
     * @param offset The offset.
     * @param val Conflation value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putConflation = function putConflation(dst, offset, val) {
        if (dst instanceof Int8Array) {
            return this.putInt32(dst, offset, val != null && val !== '' ? val : Constants.CONFLATION_NULL);
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets marketdata type from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if offset is out of array index range,
     * otherwise {@link messages.control.MarketdataType} value that corresponds to the byte at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.marketdatatype = function marketdatatype(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            return _EnumValueTranslator2["default"].ubyteToMarketdataType(_DataOperations.UByte.frombyte(src[offset]));
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Puts marketdata type value into destination array.
     * @param dst The destination array.
     * @param offset The offset.
     * @param val Marketdatatype value.
     * @returns {Int8Array} destination array.
     * @throws Exception in case if dst is not {@link Int8Array}
     */


    Qitch.putMarketdatatype = function putMarketdatatype(dst, offset, val) {
        if (dst instanceof Int8Array) {
            dst[offset] = _DataOperations.UByte.fromint(_EnumValueTranslator2["default"].marketdatatypeToInt(val));
            return dst;
        }
        throw "Invalid destination. Expected: Int8Array";
    };

    /**
     * Gets entitlement type from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {null|String} Returns null in case if offset is out of array index range,
     * otherwise {@link messages.control.StreamEntitlementType} value that corresponds to the byte at specified offset is returned.
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.entitlementtype = function entitlementtype(src, offset) {
        if (src instanceof Int8Array) {
            if (offset >= src.length) {
                return null;
            }
            return _EnumValueTranslator2["default"].ubyteToEntitlementType(_DataOperations.UByte.frombyte(src[offset]));
        }
        throw "Invalid source. Expected: Int8Array";
    };

    /**
     * Gets stream entitlement entry from source byte array at specified offset.
     * @param src The source array.
     * @param offset The offset.
     * @returns {messages.control.StreamEntitlement}
     * @throws Exception in case if src is not {@link Int8Array}
     */


    Qitch.entitlement = function entitlement(src, offset) {
        if (src instanceof Int8Array) {
            var entitlement = new _streamerApi.messages.control.StreamEntitlement();
            entitlement.symbol = this.symbol(src, offset);
            entitlement.marketdatatype = this.marketdatatype(src, offset + Constants.SYMBOL_LENGTH);
            entitlement.entitlement = this.entitlementtype(src, offset + Constants.SYMBOL_LENGTH + Constants.MARKETDATATYPE_LENGTH);
            return entitlement;
        }
        throw "Invalid source. Expected: Int8Array";
    };

    return Qitch;
}();

exports["default"] = Qitch;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/Qitch.js","/lib/qitch")
},{"../streamer-api":108,"./Bytes":20,"./DataOperations":21,"./EnumValueTranslator":22,"./QitchConstants":26,"_process":131,"bignumber.js":118,"buffer":121,"jsbi":128,"timers":152}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.BLOCK_HEADER_LENGTH = exports.BLOCK_HEADER_SEQUENCE_OFFSET = exports.BLOCK_HEADER_RESERVED_OFFSET = exports.BLOCK_HEADER_MESSAGECOUNT_OFFSET = exports.BLOCK_HEADER_LENGTH_OFFSET = exports.MESSAGE_HEADER_LENGTH = exports.MESSAGE_HEADER_TYPE_OFFSET = exports.MESSAGE_HEADER_LENGTH_OFFSET = exports.NOTE_LENGTH = exports.ENTITLEMENT_LENGTH = exports.ENTITLEMENTTYPE_LENGTH = exports.MARKETDATATYPE_LENGTH = exports.CONFLATION_LENGTH = exports.MIMETYPE_LENGTH = exports.ACTION_LENGTH = exports.BOOLEAN_LENGTH = exports.VERSION_LENGTH = exports.SERVER_INSTANCE_LENGTH = exports.REASON_LENGTH = exports.ORDER_REFERENCE_LENGTH = exports.PRICE_DIVISOR = exports.RANGEINDICATOR_LENGTH = exports.INSTRUMENTTYPE_LENGTH = exports.SYMBOL_LENGTH = exports.CURRENCYID_LENGTH = exports.EXCODE_LENGTH = exports.TICK_LENGTH = exports.IMBALANCETYPE_LENGTH = exports.ORDERSIDE_LENGTH = exports.ORDERID_LENGTH = exports.MMID_LENGTH = exports.LOCATECODE_LENGTH = exports.TIMESTAMP_LENGTH = exports.DOUBLE_LENGTH = exports.LONG_LENGTH = exports.INT_LENGTH = exports.SHORT_LENGTH = exports.ASCIICHAR_LENGTH = exports.BYTE_LENGTH = exports.CONFLATION_NULL = exports.TIMESTAMP_NULL = exports.ASCIICHAR_NULL = exports.ASCII_NULL = undefined;

var _jsbi = require("jsbi");

var _jsbi2 = _interopRequireDefault(_jsbi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*
    Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
 */
var ASCII_NULL = exports.ASCII_NULL = 0;
var ASCIICHAR_NULL = exports.ASCIICHAR_NULL = '0';
var TIMESTAMP_NULL = exports.TIMESTAMP_NULL = _jsbi2["default"].BigInt("-9223372036854775808");
var CONFLATION_NULL = exports.CONFLATION_NULL = -1;
var BYTE_LENGTH = exports.BYTE_LENGTH = 1;
var ASCIICHAR_LENGTH = exports.ASCIICHAR_LENGTH = 1;
var SHORT_LENGTH = exports.SHORT_LENGTH = 2;
var INT_LENGTH = exports.INT_LENGTH = 4;
var LONG_LENGTH = exports.LONG_LENGTH = 8;
var DOUBLE_LENGTH = exports.DOUBLE_LENGTH = 8;
var TIMESTAMP_LENGTH = exports.TIMESTAMP_LENGTH = 8;
var LOCATECODE_LENGTH = exports.LOCATECODE_LENGTH = INT_LENGTH;
var MMID_LENGTH = exports.MMID_LENGTH = 4;
var ORDERID_LENGTH = exports.ORDERID_LENGTH = LONG_LENGTH;
var ORDERSIDE_LENGTH = exports.ORDERSIDE_LENGTH = ASCIICHAR_LENGTH;
var IMBALANCETYPE_LENGTH = exports.IMBALANCETYPE_LENGTH = ASCIICHAR_LENGTH;
var TICK_LENGTH = exports.TICK_LENGTH = ASCIICHAR_LENGTH;
var EXCODE_LENGTH = exports.EXCODE_LENGTH = 5;
var CURRENCYID_LENGTH = exports.CURRENCYID_LENGTH = 3;
var SYMBOL_LENGTH = exports.SYMBOL_LENGTH = 26;
var INSTRUMENTTYPE_LENGTH = exports.INSTRUMENTTYPE_LENGTH = ASCIICHAR_LENGTH;
var RANGEINDICATOR_LENGTH = exports.RANGEINDICATOR_LENGTH = BYTE_LENGTH;
var PRICE_DIVISOR = exports.PRICE_DIVISOR = 100000000;
var ORDER_REFERENCE_LENGTH = exports.ORDER_REFERENCE_LENGTH = EXCODE_LENGTH + SYMBOL_LENGTH + MMID_LENGTH + ORDERID_LENGTH;
var REASON_LENGTH = exports.REASON_LENGTH = 40;
var SERVER_INSTANCE_LENGTH = exports.SERVER_INSTANCE_LENGTH = 1;
var VERSION_LENGTH = exports.VERSION_LENGTH = 8;
var BOOLEAN_LENGTH = exports.BOOLEAN_LENGTH = 1;
var ACTION_LENGTH = exports.ACTION_LENGTH = ASCIICHAR_LENGTH;
var MIMETYPE_LENGTH = exports.MIMETYPE_LENGTH = 20;
var CONFLATION_LENGTH = exports.CONFLATION_LENGTH = INT_LENGTH;
var MARKETDATATYPE_LENGTH = exports.MARKETDATATYPE_LENGTH = BYTE_LENGTH;
var ENTITLEMENTTYPE_LENGTH = exports.ENTITLEMENTTYPE_LENGTH = BYTE_LENGTH;
var ENTITLEMENT_LENGTH = exports.ENTITLEMENT_LENGTH = SYMBOL_LENGTH + MARKETDATATYPE_LENGTH + ENTITLEMENTTYPE_LENGTH;

var NOTE_LENGTH = exports.NOTE_LENGTH = 50;

var MESSAGE_HEADER_LENGTH_OFFSET = exports.MESSAGE_HEADER_LENGTH_OFFSET = 0;
var MESSAGE_HEADER_TYPE_OFFSET = exports.MESSAGE_HEADER_TYPE_OFFSET = MESSAGE_HEADER_LENGTH_OFFSET + SHORT_LENGTH;
var MESSAGE_HEADER_LENGTH = exports.MESSAGE_HEADER_LENGTH = MESSAGE_HEADER_TYPE_OFFSET + BYTE_LENGTH;

var BLOCK_HEADER_LENGTH_OFFSET = exports.BLOCK_HEADER_LENGTH_OFFSET = 0;
var BLOCK_HEADER_MESSAGECOUNT_OFFSET = exports.BLOCK_HEADER_MESSAGECOUNT_OFFSET = BLOCK_HEADER_LENGTH_OFFSET + SHORT_LENGTH;
var BLOCK_HEADER_RESERVED_OFFSET = exports.BLOCK_HEADER_RESERVED_OFFSET = BLOCK_HEADER_MESSAGECOUNT_OFFSET + BYTE_LENGTH;
var BLOCK_HEADER_SEQUENCE_OFFSET = exports.BLOCK_HEADER_SEQUENCE_OFFSET = BLOCK_HEADER_RESERVED_OFFSET + BYTE_LENGTH;
var BLOCK_HEADER_LENGTH = exports.BLOCK_HEADER_LENGTH = BLOCK_HEADER_SEQUENCE_OFFSET + INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/QitchConstants.js","/lib/qitch")
},{"_process":131,"buffer":121,"jsbi":128,"timers":152}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.MAX_ENTITLEMENTS_PER_SUBSCRIPTION_OFFSET = exports.REJECT_EXCESSIVE_CONNECTION_OFFSET = exports.CONFLATION_OFFSET = exports.SERVER_INSTANCE_OFFSET = exports.FLOW_CONTROL_CHECK_INTERVAL_OFFSET = exports.VERSION_OFFSET = exports.REQUEST_ID_OFFSET = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 105;

var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
var VERSION_OFFSET = exports.VERSION_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
var FLOW_CONTROL_CHECK_INTERVAL_OFFSET = exports.FLOW_CONTROL_CHECK_INTERVAL_OFFSET = VERSION_OFFSET + _QitchConstants.VERSION_LENGTH;
var SERVER_INSTANCE_OFFSET = exports.SERVER_INSTANCE_OFFSET = FLOW_CONTROL_CHECK_INTERVAL_OFFSET + _QitchConstants.INT_LENGTH;
var CONFLATION_OFFSET = exports.CONFLATION_OFFSET = SERVER_INSTANCE_OFFSET + _QitchConstants.SERVER_INSTANCE_LENGTH;
var REJECT_EXCESSIVE_CONNECTION_OFFSET = exports.REJECT_EXCESSIVE_CONNECTION_OFFSET = CONFLATION_OFFSET + _QitchConstants.INT_LENGTH;
var MAX_ENTITLEMENTS_PER_SUBSCRIPTION_OFFSET = exports.MAX_ENTITLEMENTS_PER_SUBSCRIPTION_OFFSET = REJECT_EXCESSIVE_CONNECTION_OFFSET + _QitchConstants.BOOLEAN_LENGTH;

var LENGTH = exports.LENGTH = MAX_ENTITLEMENTS_PER_SUBSCRIPTION_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/ConnectResponseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 106;

var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;

var LENGTH = exports.LENGTH = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/ConnectionCloseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.FIXED_LENGTH = exports.EXCODE_OFFSET = exports.CONFLATION_OFFSET = exports.MIMETYPE_OFFSET = exports.ACTION_OFFSET = exports.REQUEST_ID_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 114;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = 0;
var ACTION_OFFSET = exports.ACTION_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
var MIMETYPE_OFFSET = exports.MIMETYPE_OFFSET = ACTION_OFFSET + _QitchConstants.ACTION_LENGTH;
var CONFLATION_OFFSET = exports.CONFLATION_OFFSET = MIMETYPE_OFFSET + _QitchConstants.MIMETYPE_LENGTH;
var EXCODE_OFFSET = exports.EXCODE_OFFSET = CONFLATION_OFFSET + _QitchConstants.CONFLATION_LENGTH;
var FIXED_LENGTH = exports.FIXED_LENGTH = EXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/ExchangeSubscribeMessageDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.REQUEST_ID_OFFSET = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 115;
var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
var LENGTH = exports.LENGTH = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/ExchangeSubscribeResponseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],31:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.REQUEST_ID_OFFSET = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 116;
var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
var LENGTH = exports.LENGTH = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/ExchangeUnsubResponseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.SEQUENCE_NUMBER_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 107;

var SEQUENCE_NUMBER_OFFSET = exports.SEQUENCE_NUMBER_OFFSET = 0;
var LENGTH = exports.LENGTH = SEQUENCE_NUMBER_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/FlowMessageDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 101;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var LENGTH = exports.LENGTH = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/HeartbeatDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.REQUEST_ID_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 110;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var LENGTH = exports.LENGTH = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/InitialDataSentDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 112;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var LENGTH = exports.LENGTH = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/ResubscribeMessageDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.MAX_EXCEED_OFFSET = exports.TIMES_EXCEED_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 111;

var TIMES_EXCEED_OFFSET = exports.TIMES_EXCEED_OFFSET = 0;
var MAX_EXCEED_OFFSET = exports.MAX_EXCEED_OFFSET = TIMES_EXCEED_OFFSET + _QitchConstants.INT_LENGTH;

var LENGTH = exports.LENGTH = MAX_EXCEED_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/SlowConnectionDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.REQUEST_ID_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 108;

var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = 0;
var LENGTH = exports.LENGTH = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/StatsMessageDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.NUMBER_OF_AVAILABLE_CONNECTIONS = exports.NUMBER_OF_OPENED_CONNECTIONS = exports.NUMBER_OF_AVAILABLE_L2_OFFSET = exports.NUMBER_OF_SUBSCRIBED_L2_OFFSET = exports.NUMBER_OF_AVAILABLE_L1_OFFSET = exports.NUMBER_OF_SUBSCRIBED_L1_OFFSET = exports.REQUEST_ID_OFFSET = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 109;

var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
var NUMBER_OF_SUBSCRIBED_L1_OFFSET = exports.NUMBER_OF_SUBSCRIBED_L1_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
var NUMBER_OF_AVAILABLE_L1_OFFSET = exports.NUMBER_OF_AVAILABLE_L1_OFFSET = NUMBER_OF_SUBSCRIBED_L1_OFFSET + _QitchConstants.INT_LENGTH;
var NUMBER_OF_SUBSCRIBED_L2_OFFSET = exports.NUMBER_OF_SUBSCRIBED_L2_OFFSET = NUMBER_OF_AVAILABLE_L1_OFFSET + _QitchConstants.INT_LENGTH;
var NUMBER_OF_AVAILABLE_L2_OFFSET = exports.NUMBER_OF_AVAILABLE_L2_OFFSET = NUMBER_OF_SUBSCRIBED_L2_OFFSET + _QitchConstants.INT_LENGTH;
var NUMBER_OF_OPENED_CONNECTIONS = exports.NUMBER_OF_OPENED_CONNECTIONS = NUMBER_OF_AVAILABLE_L2_OFFSET + _QitchConstants.INT_LENGTH;
var NUMBER_OF_AVAILABLE_CONNECTIONS = exports.NUMBER_OF_AVAILABLE_CONNECTIONS = NUMBER_OF_OPENED_CONNECTIONS + _QitchConstants.INT_LENGTH;

var LENGTH = exports.LENGTH = NUMBER_OF_AVAILABLE_CONNECTIONS + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/StatsResponseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.FIXED_LENGTH = exports.MIMETYPE_OFFSET = exports.OPERATION_OFFSET = exports.REQUEST_ID_OFFSET = exports.FIXED_OPERATION_LENGTH = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 117;

// Will take at most 11 bytes for UNSUBSCRIBE/SUBSCRIBE operation string type
var FIXED_OPERATION_LENGTH = exports.FIXED_OPERATION_LENGTH = 11;

var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = 0;
var OPERATION_OFFSET = exports.OPERATION_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
var MIMETYPE_OFFSET = exports.MIMETYPE_OFFSET = OPERATION_OFFSET + FIXED_OPERATION_LENGTH;

var FIXED_LENGTH = exports.FIXED_LENGTH = MIMETYPE_OFFSET + _QitchConstants.MIMETYPE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/SubUnsubAlertMessageDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.OPERATION_OFFSET = exports.REQUEST_ID_OFFSET = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.FIXED_OPERATION_LENGTH = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 118;

// Will take at most 12 bytes for UNSUBSCRIBED/SUBSCRIBED operation string type
var FIXED_OPERATION_LENGTH = exports.FIXED_OPERATION_LENGTH = 12;

var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
var OPERATION_OFFSET = exports.OPERATION_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;

var LENGTH = exports.LENGTH = OPERATION_OFFSET + FIXED_OPERATION_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/SubUnsubAlertResponseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.FIXED_LENGTH = exports.NUMBER_OF_TYPES_OFFSET = exports.NUMBER_OF_SYMBOLS_OFFSET = exports.CONFLATION_OFFSET = exports.SKIP_HEAVY_INITIAL_LOAD_OFFSET = exports.MIMETYPE_OFFSET = exports.ACTION_OFFSET = exports.REQUEST_ID_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 102;

var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = 0;
var ACTION_OFFSET = exports.ACTION_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
var MIMETYPE_OFFSET = exports.MIMETYPE_OFFSET = ACTION_OFFSET + _QitchConstants.ACTION_LENGTH;
var SKIP_HEAVY_INITIAL_LOAD_OFFSET = exports.SKIP_HEAVY_INITIAL_LOAD_OFFSET = MIMETYPE_OFFSET + _QitchConstants.MIMETYPE_LENGTH;
var CONFLATION_OFFSET = exports.CONFLATION_OFFSET = SKIP_HEAVY_INITIAL_LOAD_OFFSET + _QitchConstants.BOOLEAN_LENGTH;
var NUMBER_OF_SYMBOLS_OFFSET = exports.NUMBER_OF_SYMBOLS_OFFSET = CONFLATION_OFFSET + _QitchConstants.CONFLATION_LENGTH;
var NUMBER_OF_TYPES_OFFSET = exports.NUMBER_OF_TYPES_OFFSET = NUMBER_OF_SYMBOLS_OFFSET + _QitchConstants.INT_LENGTH;

var FIXED_LENGTH = exports.FIXED_LENGTH = NUMBER_OF_TYPES_OFFSET + _QitchConstants.BYTE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/SubscribeMessageDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.FIXED_LENGTH = exports.NUMBER_OF_INVALID_SYMBOLS_OFFSET = exports.NUMBER_OF_REJECTED_SYMBOLS_OFFSET = exports.NUMBER_OF_ENTITLEMENTS_OFFSET = exports.REQUEST_ID_OFFSET = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 103;

var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
var NUMBER_OF_ENTITLEMENTS_OFFSET = exports.NUMBER_OF_ENTITLEMENTS_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;
var NUMBER_OF_REJECTED_SYMBOLS_OFFSET = exports.NUMBER_OF_REJECTED_SYMBOLS_OFFSET = NUMBER_OF_ENTITLEMENTS_OFFSET + _QitchConstants.INT_LENGTH;
var NUMBER_OF_INVALID_SYMBOLS_OFFSET = exports.NUMBER_OF_INVALID_SYMBOLS_OFFSET = NUMBER_OF_REJECTED_SYMBOLS_OFFSET + _QitchConstants.INT_LENGTH;

var FIXED_LENGTH = exports.FIXED_LENGTH = NUMBER_OF_INVALID_SYMBOLS_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/SubscribeResponseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.FIXED_LENGTH = exports.NUMBER_OF_UNSUBSCRIBED_ENTITLEMENTS_OFFSET = exports.REQUEST_ID_OFFSET = exports.REASON_OFFSET = exports.CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 104;

var CODE_OFFSET = exports.CODE_OFFSET = 0;
var REASON_OFFSET = exports.REASON_OFFSET = CODE_OFFSET + _QitchConstants.INT_LENGTH;
var REQUEST_ID_OFFSET = exports.REQUEST_ID_OFFSET = REASON_OFFSET + _QitchConstants.REASON_LENGTH;
var NUMBER_OF_UNSUBSCRIBED_ENTITLEMENTS_OFFSET = exports.NUMBER_OF_UNSUBSCRIBED_ENTITLEMENTS_OFFSET = REQUEST_ID_OFFSET + _QitchConstants.INT_LENGTH;

var FIXED_LENGTH = exports.FIXED_LENGTH = NUMBER_OF_UNSUBSCRIBED_ENTITLEMENTS_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/controlMessageDefinition/UnsubscribeResponseDef.js","/lib/qitch/controlMessageDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _Qitch = require("../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

var _MessageHeader = require("../MessageHeader");

var _MessageHeader2 = _interopRequireDefault(_MessageHeader);

var _BlockHeader = require("../BlockHeader");

var _BlockHeader2 = _interopRequireDefault(_BlockHeader);

var _QitchConstants = require("../QitchConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Decodes a stream of message blocks into messages.
 * This class is stateful and cannot be shared between multiple streams.
 */
var BlockDecoder = function () {
    function BlockDecoder(decoders, capacity) {
        _classCallCheck(this, BlockDecoder);

        if (decoders == null) {
            throw "Decoders cannot be null";
        }
        this.buffer = new ArrayBuffer(capacity);
        this.bufferView = new Int8Array(this.buffer);
        this.bufferPosition = 0;
        this.bufferCapacity = capacity;
        this.decodeblockheader = new DecodeBlockHeader(this);
        this.decodemessageheader = new DecodeMessageHeader(this);
        this.decodemessage = new DecodeMessage(decoders, this);
        this.state = new State();
        this.state.current = this.decodeblockheader;
        this.docompact = false;
        this.doflip = false;
    }

    /**
     * The number of messages in the current block.
     * @returns {number} The number of messages or -1 if no block is being decoded
     */


    BlockDecoder.prototype.messagecount = function messagecount() {
        return this.state.messagecount;
    };

    /**
     * Returns the sequence number of the current block.
     * @returns {number} the sequence number of the current block.
     */


    BlockDecoder.prototype.blocksequencenumber = function blocksequencenumber() {
        return this.state.blocksequencenumber;
    };

    /**
     * Adds bytes to internal buffer.
     * Call {@link decode}  to decode the buffered data.
     * @param bytes The array from witch bytes are to be added.
     * @param offset The offset within the array of the fist byte to be added.
     * @param length The number of bytes to be added from the given array.
     * @returns {Number} Number of bytes that weren't added due to buffer not having enough space.
     */


    BlockDecoder.prototype.add = function add(bytes, offset, length) {
        var numOfLeftoverBytes = 0;
        if (bytes != null) {
            if (this.docompact) {
                var remaining = this.bufferPosition <= this.bufferLimit ? this.bufferLimit - this.bufferPosition : 0;
                _Qitch2["default"].copyArray(this.bufferView, this.bufferPosition, this.bufferView, 0, remaining);
                this.bufferPosition = remaining;
                this.bufferLimit = this.bufferCapacity;
                this.docompact = false;
            }
            if (length + this.bufferPosition > this.bufferView.length) {
                numOfLeftoverBytes = length - (this.bufferView.length - this.bufferPosition);
                _Qitch2["default"].copyArray(bytes, offset, this.bufferView, this.bufferPosition, length - numOfLeftoverBytes);
                this.messagelength = this.bufferView.length;
                this.bufferPosition = this.bufferView.length;
            } else {
                _Qitch2["default"].copyArray(bytes, offset, this.bufferView, this.bufferPosition, length);
                this.messagelength = length;
                this.bufferPosition = this.bufferPosition + this.messagelength;
            }
            this.doflip = true;
        }
        return numOfLeftoverBytes;
    };

    /**
     * Incrementally decodes the data in the internal buffer.
     * Successive calls to this method will return the next decoded message as long enough data is avail
     * If not enough data is available null will be returned until more data is added.
     * @returns {*} The next decoded message or null if not enough data is available.
     */


    BlockDecoder.prototype.decode = function decode() {
        if (this.doflip) {
            this.bufferLimit = this.bufferPosition;
            this.bufferPosition = 0;
            this.doflip = false;
        }
        if (this.state.current === this.decodeblockheader) {
            // Reset previous block header state when starting a new block
            this.state.blocklength = -1;
            this.state.messagecount = -1;
            this.state.blocksequencenumber = -1;
            this.state.messagelength = -1;
            this.state.messagetype = -1;
        } else if (this.state.current === this.decodemessageheader) {
            // Reset previous message header state when staring a new message
            this.state.messagelength = -1;
            this.state.messagetype = -1;
        }

        var position = 0;
        try {
            do {
                position = this.state.current.decode(this.state, this.bufferView, this.bufferLimit, this.bufferPosition);
                // shift state
                if (position !== -1) {
                    this.state.previous = this.state.current;
                    this.state.current = this.state.next;
                    this.state.next = null;
                    this.bufferPosition = position;
                }
                if (this.state.result != null && position >= this.messagelength) {
                    break;
                }
            } while (position >= 0);
        } catch (e) {
            // clear the decoder state in case if exception occurred.
            this.state.current = this.decodeblockheader;
            this.bufferPosition = 0;
            this.bufferLimit = this.bufferCapacity;
            throw e;
        }
        var result = this.state.result;
        this.state.result = null;
        this.docompact = true;
        return result;
    };

    return BlockDecoder;
}();

var State = function State() {
    _classCallCheck(this, State);

    this.previous = null;
    this.current = null;
    this.next = null;
    this.blocklength = 0;
    this.messagecount = 0;
    this.blocksequencenumber = 0;
    this.messagelength = 0;
    this.messagetype = 0;
    this.result = null;
};

var DecodeBlockHeader = function () {
    function DecodeBlockHeader(blockDecoder) {
        _classCallCheck(this, DecodeBlockHeader);

        this.blockDecoder = blockDecoder;
    }

    DecodeBlockHeader.prototype.decode = function decode(state, buffer, bufferLimit, bufferPosition) {
        if (bufferLimit - bufferPosition < _QitchConstants.BLOCK_HEADER_LENGTH) {
            return -1;
        }
        state.blocklength = _BlockHeader2["default"].lengthGetValue(buffer, bufferPosition);
        state.messagecount = _BlockHeader2["default"].messageCountGetValue(buffer, bufferPosition);
        state.blocksequencenumber = _BlockHeader2["default"].sequenceGetValue(buffer, bufferPosition);
        if (state.messagecount > 0) {
            state.next = this.blockDecoder.decodemessageheader;
        } else {
            // No messages
            state.next = this.blockDecoder.decodeblockheader;
        }
        return bufferPosition + _QitchConstants.BLOCK_HEADER_LENGTH;
    };

    return DecodeBlockHeader;
}();

var DecodeMessageHeader = function () {
    function DecodeMessageHeader(blockDecoder) {
        _classCallCheck(this, DecodeMessageHeader);

        this.blockDecoder = blockDecoder;
    }

    DecodeMessageHeader.prototype.decode = function decode(state, buffer, bufferLimit, bufferPosition) {
        if (bufferLimit - bufferPosition < _QitchConstants.MESSAGE_HEADER_LENGTH) {
            return -1;
        }
        state.messagelength = _MessageHeader2["default"].lengthGetValue(buffer, bufferPosition);
        state.messagetype = _MessageHeader2["default"].typeGetValue(buffer, bufferPosition);
        // Do not change b.position, header is required to decode message
        state.next = this.blockDecoder.decodemessage;
        return bufferPosition;
    };

    return DecodeMessageHeader;
}();

var DecodeMessage = function () {
    function DecodeMessage(decoders, blockDecoder) {
        _classCallCheck(this, DecodeMessage);

        this.decoders = decoders;
        this.blockDecoder = blockDecoder;
    }

    DecodeMessage.prototype.decode = function decode(state, buffer, bufferLimit, bufferPosition) {
        if (bufferLimit - bufferPosition < state.messagelength + _QitchConstants.MESSAGE_HEADER_LENGTH) {
            return -1;
        }
        var result = this.decoders.decode(buffer, bufferPosition);
        if (result != null) {
            if (!state.result) {
                state.result = [];
            }
            result.messagecount = state.messagecount;
            result.blocksequencenumber = state.blocksequencenumber;
            state.result.push(result);
        }
        state.messagecount--;
        //
        if (state.messagecount > 0) {
            state.next = this.blockDecoder.decodemessageheader;
        } else {
            // No more messages
            state.next = this.blockDecoder.decodeblockheader;
        }
        return bufferPosition + _QitchConstants.MESSAGE_HEADER_LENGTH + state.messagelength;
    };

    return DecodeMessage;
}();

exports["default"] = BlockDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/BlockDecoder.js","/lib/qitch/decoder")
},{"../BlockHeader":19,"../MessageHeader":24,"../Qitch":25,"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _MessageHeader = require("../MessageHeader");

var _MessageHeader2 = _interopRequireDefault(_MessageHeader);

var _QitchConstants = require("../QitchConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MessageDecoder = function () {
    function MessageDecoder(decoders) {
        _classCallCheck(this, MessageDecoder);

        if (decoders === null) {
            throw "Decoders cannot be null";
        }
        this.decoders = new Map();
        var i = void 0;
        for (i = 0; i < decoders.length; i++) {
            this.decoders.set(decoders[i].type(), decoders[i]);
        }
    }

    MessageDecoder.prototype.decode = function decode(src, offset) {
        if (src == null) {
            throw "The source cannot be null";
        }
        if (src.length === 0) {
            return null;
        }
        var typeId = _MessageHeader2["default"].typeGetValue(src, offset);
        var decoder = this.decoders.get(typeId);
        if (decoder == null) {
            return null; // Ignore unknown types
        }
        var datalength = _MessageHeader2["default"].lengthGetValue(src, offset);
        this._check(src, offset, datalength);

        var positionedBuffer = new Int8Array(src.buffer, _QitchConstants.MESSAGE_HEADER_LENGTH + offset, datalength);
        return decoder.decode(positionedBuffer, 0);
    };

    MessageDecoder.prototype._check = function _check(src, offset, datalength) {
        var available = src.length - offset;
        var required = _QitchConstants.MESSAGE_HEADER_LENGTH + datalength;
        if (available < required) {
            throw "Not enough data available. Available: " + available + " Required: " + required;
        }
    };

    return MessageDecoder;
}();

exports["default"] = MessageDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/MessageDecoder.js","/lib/qitch/decoder")
},{"../MessageHeader":24,"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.MessageBlock = exports.BinaryMessage = undefined;

var _BlockDecoder = require("./BlockDecoder");

var _BlockDecoder2 = _interopRequireDefault(_BlockDecoder);

var _MessageDecoder = require("./MessageDecoder");

var _MessageDecoder2 = _interopRequireDefault(_MessageDecoder);

var _message = require("../../message.js");

var _TradeDecoder = require("./dataDecoder/TradeDecoder");

var _TradeDecoder2 = _interopRequireDefault(_TradeDecoder);

var _SymbolInfoDecoder = require("./dataDecoder/SymbolInfoDecoder");

var _SymbolInfoDecoder2 = _interopRequireDefault(_SymbolInfoDecoder);

var _PricedataDecoder = require("./dataDecoder/PricedataDecoder");

var _PricedataDecoder2 = _interopRequireDefault(_PricedataDecoder);

var _SymbolStatusDecoder = require("./dataDecoder/SymbolStatusDecoder");

var _SymbolStatusDecoder2 = _interopRequireDefault(_SymbolStatusDecoder);

var _QuoteDecoder = require("./dataDecoder/QuoteDecoder");

var _QuoteDecoder2 = _interopRequireDefault(_QuoteDecoder);

var _DerivativeInfoDecoder = require("./dataDecoder/DerivativeInfoDecoder");

var _DerivativeInfoDecoder2 = _interopRequireDefault(_DerivativeInfoDecoder);

var _IVGreeksDecoder = require("./dataDecoder/IVGreeksDecoder");

var _IVGreeksDecoder2 = _interopRequireDefault(_IVGreeksDecoder);

var _LastSaleDecoder = require("./dataDecoder/LastSaleDecoder");

var _LastSaleDecoder2 = _interopRequireDefault(_LastSaleDecoder);

var _LimitUpLimitDownDecoder = require("./dataDecoder/LimitUpLimitDownDecoder");

var _LimitUpLimitDownDecoder2 = _interopRequireDefault(_LimitUpLimitDownDecoder);

var _ImbalanceStatusDecoder = require("./dataDecoder/ImbalanceStatusDecoder");

var _ImbalanceStatusDecoder2 = _interopRequireDefault(_ImbalanceStatusDecoder);

var _NethousePositionDecoder = require("./dataDecoder/NethousePositionDecoder");

var _NethousePositionDecoder2 = _interopRequireDefault(_NethousePositionDecoder);

var _IntervalDecoder = require("./dataDecoder/IntervalDecoder");

var _IntervalDecoder2 = _interopRequireDefault(_IntervalDecoder);

var _MMQuoteDecoder = require("./dataDecoder/MMQuoteDecoder");

var _MMQuoteDecoder2 = _interopRequireDefault(_MMQuoteDecoder);

var _PurgeBookDecoder = require("./dataDecoder/PurgeBookDecoder");

var _PurgeBookDecoder2 = _interopRequireDefault(_PurgeBookDecoder);

var _BookDeleteDecoder = require("./dataDecoder/BookDeleteDecoder");

var _BookDeleteDecoder2 = _interopRequireDefault(_BookDeleteDecoder);

var _BookOrderDecoder = require("./dataDecoder/BookOrderDecoder");

var _BookOrderDecoder2 = _interopRequireDefault(_BookOrderDecoder);

var _SMessage3 = require("../../SMessage");

var _SMessage4 = _interopRequireDefault(_SMessage3);

var _HeartbeatDecoder = require("./controlMessageDecoder/HeartbeatDecoder");

var _HeartbeatDecoder2 = _interopRequireDefault(_HeartbeatDecoder);

var _InitialDataSentDecoder = require("./controlMessageDecoder/InitialDataSentDecoder");

var _InitialDataSentDecoder2 = _interopRequireDefault(_InitialDataSentDecoder);

var _ConnectResponseDecoder = require("./controlMessageDecoder/ConnectResponseDecoder");

var _ConnectResponseDecoder2 = _interopRequireDefault(_ConnectResponseDecoder);

var _StatsResponseDecoder = require("./controlMessageDecoder/StatsResponseDecoder");

var _StatsResponseDecoder2 = _interopRequireDefault(_StatsResponseDecoder);

var _SubscribeResponseDecoder = require("./controlMessageDecoder/SubscribeResponseDecoder");

var _SubscribeResponseDecoder2 = _interopRequireDefault(_SubscribeResponseDecoder);

var _UnsubscribeResponseDecoder = require("./controlMessageDecoder/UnsubscribeResponseDecoder");

var _UnsubscribeResponseDecoder2 = _interopRequireDefault(_UnsubscribeResponseDecoder);

var _SlowConnectionDecoder = require("./controlMessageDecoder/SlowConnectionDecoder");

var _SlowConnectionDecoder2 = _interopRequireDefault(_SlowConnectionDecoder);

var _ConnectionCloseDecoder = require("./controlMessageDecoder/ConnectionCloseDecoder");

var _ConnectionCloseDecoder2 = _interopRequireDefault(_ConnectionCloseDecoder);

var _ResubscribeMessageDecoder = require("./controlMessageDecoder/ResubscribeMessageDecoder");

var _ResubscribeMessageDecoder2 = _interopRequireDefault(_ResubscribeMessageDecoder);

var _ExchangeSubscribeResponseDecoder = require("./controlMessageDecoder/ExchangeSubscribeResponseDecoder");

var _ExchangeSubscribeResponseDecoder2 = _interopRequireDefault(_ExchangeSubscribeResponseDecoder);

var _ExchangeUnsubResponseDecoder = require("./controlMessageDecoder/ExchangeUnsubResponseDecoder");

var _ExchangeUnsubResponseDecoder2 = _interopRequireDefault(_ExchangeUnsubResponseDecoder);

var _AlertDecoder = require("./dataDecoder/AlertDecoder");

var _AlertDecoder2 = _interopRequireDefault(_AlertDecoder);

var _SubUnsubAlertResponseDecoder = require("./controlMessageDecoder/SubUnsubAlertResponseDecoder");

var _SubUnsubAlertResponseDecoder2 = _interopRequireDefault(_SubUnsubAlertResponseDecoder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
    Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
 */
var QitchDecoder = function () {
    function QitchDecoder(bufferSize) {
        _classCallCheck(this, QitchDecoder);

        var decoders = [
        // Ctr Messages
        new _HeartbeatDecoder2["default"](), new _SubscribeResponseDecoder2["default"](), new _UnsubscribeResponseDecoder2["default"](), new _ConnectResponseDecoder2["default"](), new _ConnectionCloseDecoder2["default"](), new _StatsResponseDecoder2["default"](), new _SlowConnectionDecoder2["default"](), new _InitialDataSentDecoder2["default"](), new _ResubscribeMessageDecoder2["default"](), new _SubUnsubAlertResponseDecoder2["default"](),
        // Market Data Messages
        new _SymbolInfoDecoder2["default"](), new _TradeDecoder2["default"](), new _PricedataDecoder2["default"](), new _SymbolStatusDecoder2["default"](), new _QuoteDecoder2["default"](), new _DerivativeInfoDecoder2["default"](), new _IVGreeksDecoder2["default"](), new _LastSaleDecoder2["default"](), new _LimitUpLimitDownDecoder2["default"](), new _ImbalanceStatusDecoder2["default"](), new _NethousePositionDecoder2["default"](), new _IntervalDecoder2["default"](), new _MMQuoteDecoder2["default"](), new _PurgeBookDecoder2["default"](), new _BookDeleteDecoder2["default"](), new _BookOrderDecoder2["default"](), new _ExchangeSubscribeResponseDecoder2["default"](), new _ExchangeUnsubResponseDecoder2["default"](), new _AlertDecoder2["default"]()];
        this.decoder = new _BlockDecoder2["default"](new _MessageDecoder2["default"](decoders), bufferSize);
    }

    QitchDecoder.prototype.decode = function decode(bytes) {
        var remainingMessageLength = bytes.length;
        var decodedMessages = [];
        var currentIndex = 0;
        while (remainingMessageLength > 0) {
            var addedBytes = remainingMessageLength - this.decoder.add(bytes, currentIndex, remainingMessageLength);
            currentIndex = currentIndex + addedBytes;
            remainingMessageLength = remainingMessageLength - addedBytes;
            var decoded = this.decoder.decode();
            if (decoded == null) {
                continue;
            } else if (decoded.length === 1 && decoded[0].messagecount === 1) {
                // Single message
                decodedMessages.push(this._messageImpl(decoded[0]));
            } else if (decoded.length > 1) {
                // Multiple messages that weren't packed into a block but were received together
                for (var i = 0; i < decoded.length; i++) {
                    if (decoded[i].messagecount > 1) {
                        decodedMessages.push(this._messageBlockImpl(decoded.slice(i + 1, i + decoded[i].messagecount)));
                        i += decoded[i].messagecount + 1;
                    } else {
                        decodedMessages.push(this._messageImpl(decoded[i]));
                    }
                }
            } else {
                // Multiple messages
                var messages = [];
                var msgCount = 0;
                while (decoded != null) {
                    messages[msgCount++] = decoded;
                    decoded = this.decoder.decode();
                }
                decodedMessages.push(this._messageBlockImpl(messages));
            }
        }
        return decodedMessages;
    };

    QitchDecoder.prototype._messageBlockImpl = function _messageBlockImpl(messages) {
        if (messages == null || !(messages instanceof Array) || messages.length === 0) {
            return null;
        }
        var wrapped = new Array(messages.length);
        var i = void 0;
        for (i = 0; i < messages.length; i++) {
            wrapped[i] = this._messageImpl(messages[i]);
        }
        var messageBlock = new MessageBlock();
        messageBlock.sequencenumber = this.decoder.blocksequencenumber();
        messageBlock.timestamp = new Date().getMilliseconds();
        messageBlock.encoding = _message.Encodings.NONE_CHAR;
        messageBlock.mimetype = _message.MimeTypes.QITCH_CHAR;
        messageBlock.messages = wrapped;
        return messageBlock;
    };

    QitchDecoder.prototype._messageImpl = function _messageImpl(message) {
        var binaryMessage = new BinaryMessage();
        binaryMessage.sequencenumber = message.blocksequencenumber;
        binaryMessage.timestamp = new Date().getTime();
        binaryMessage.encoding = _message.Encodings.NONE_CHAR;
        binaryMessage.mimetype = _message.MimeTypes.QITCH_CHAR;
        binaryMessage.decodedPayload = message;
        binaryMessage.id = message.requestId;
        return binaryMessage;
    };

    return QitchDecoder;
}();

var BinaryMessage = exports.BinaryMessage = function (_SMessage) {
    _inherits(BinaryMessage, _SMessage);

    function BinaryMessage() {
        _classCallCheck(this, BinaryMessage);

        var _this = _possibleConstructorReturn(this, _SMessage.call(this));

        _this.type = '1';
        _this.decodedPayload = null;
        return _this;
    }

    return BinaryMessage;
}(_SMessage4["default"]);

var MessageBlock = exports.MessageBlock = function (_SMessage2) {
    _inherits(MessageBlock, _SMessage2);

    function MessageBlock() {
        _classCallCheck(this, MessageBlock);

        var _this2 = _possibleConstructorReturn(this, _SMessage2.call(this));

        _this2.type = 'B';
        _this2.messages = null;
        return _this2;
    }

    return MessageBlock;
}(_SMessage4["default"]);

exports["default"] = QitchDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/QitchDecoder.js","/lib/qitch/decoder")
},{"../../SMessage":5,"../../message.js":17,"./BlockDecoder":44,"./MessageDecoder":45,"./controlMessageDecoder/ConnectResponseDecoder":47,"./controlMessageDecoder/ConnectionCloseDecoder":48,"./controlMessageDecoder/ExchangeSubscribeResponseDecoder":49,"./controlMessageDecoder/ExchangeUnsubResponseDecoder":50,"./controlMessageDecoder/HeartbeatDecoder":51,"./controlMessageDecoder/InitialDataSentDecoder":52,"./controlMessageDecoder/ResubscribeMessageDecoder":53,"./controlMessageDecoder/SlowConnectionDecoder":54,"./controlMessageDecoder/StatsResponseDecoder":55,"./controlMessageDecoder/SubUnsubAlertResponseDecoder":56,"./controlMessageDecoder/SubscribeResponseDecoder":57,"./controlMessageDecoder/UnsubscribeResponseDecoder":58,"./dataDecoder/AlertDecoder":59,"./dataDecoder/BookDeleteDecoder":60,"./dataDecoder/BookOrderDecoder":61,"./dataDecoder/DerivativeInfoDecoder":62,"./dataDecoder/IVGreeksDecoder":63,"./dataDecoder/ImbalanceStatusDecoder":64,"./dataDecoder/IntervalDecoder":65,"./dataDecoder/LastSaleDecoder":66,"./dataDecoder/LimitUpLimitDownDecoder":67,"./dataDecoder/MMQuoteDecoder":68,"./dataDecoder/NethousePositionDecoder":69,"./dataDecoder/PricedataDecoder":70,"./dataDecoder/PurgeBookDecoder":71,"./dataDecoder/QuoteDecoder":72,"./dataDecoder/SymbolInfoDecoder":73,"./dataDecoder/SymbolStatusDecoder":74,"./dataDecoder/TradeDecoder":75,"_process":131,"buffer":121,"timers":152}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _ConnectResponseDef = require("../../controlMessageDefinition/ConnectResponseDef");

var def = _interopRequireWildcard(_ConnectResponseDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ConnectResponseDecoder = function () {
    function ConnectResponseDecoder() {
        _classCallCheck(this, ConnectResponseDecoder);
    }

    ConnectResponseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    ConnectResponseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.ConnectResponse();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);
        out.version = _Qitch2["default"].version(src, offset + def.VERSION_OFFSET);
        out.flowControlCheckInterval = _Qitch2["default"].int32(src, offset + def.FLOW_CONTROL_CHECK_INTERVAL_OFFSET);
        out.serverInstance = _Qitch2["default"].serverInstance(src, offset + def.SERVER_INSTANCE_OFFSET);
        out.conflationMs = _Qitch2["default"].int32(src, offset + def.CONFLATION_OFFSET);
        out.rejectExcessiveConnection = _Qitch2["default"].bool(src, offset + def.REJECT_EXCESSIVE_CONNECTION_OFFSET);
        out.maxEntitlementsPerSubscription = _Qitch2["default"].int32(src, offset + def.MAX_ENTITLEMENTS_PER_SUBSCRIPTION_OFFSET);
        return out;
    };

    return ConnectResponseDecoder;
}();

exports["default"] = ConnectResponseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/ConnectResponseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/ConnectResponseDef":27,"_process":131,"buffer":121,"timers":152}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _ConnectionCloseDef = require("../../controlMessageDefinition/ConnectionCloseDef");

var def = _interopRequireWildcard(_ConnectionCloseDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ConnectionCloseDecoder = function () {
    function ConnectionCloseDecoder() {
        _classCallCheck(this, ConnectionCloseDecoder);
    }

    ConnectionCloseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    ConnectionCloseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.ConnectionClose();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        return out;
    };

    return ConnectionCloseDecoder;
}();

exports["default"] = ConnectionCloseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/ConnectionCloseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/ConnectionCloseDef":28,"_process":131,"buffer":121,"timers":152}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _ExchangeSubscribeResponseDef = require("../../controlMessageDefinition/ExchangeSubscribeResponseDef");

var def = _interopRequireWildcard(_ExchangeSubscribeResponseDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExchangeSubscribeResponseDecoder = function () {
    function ExchangeSubscribeResponseDecoder() {
        _classCallCheck(this, ExchangeSubscribeResponseDecoder);
    }

    ExchangeSubscribeResponseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    ExchangeSubscribeResponseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.ExchangeSubscribeResponse();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);

        return out;
    };

    return ExchangeSubscribeResponseDecoder;
}();

exports["default"] = ExchangeSubscribeResponseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/ExchangeSubscribeResponseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/ExchangeSubscribeResponseDef":30,"_process":131,"buffer":121,"timers":152}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _ExchangeUnsubResponseDef = require("../../controlMessageDefinition/ExchangeUnsubResponseDef");

var def = _interopRequireWildcard(_ExchangeUnsubResponseDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExchangeUnsubResponseDecoder = function () {
    function ExchangeUnsubResponseDecoder() {
        _classCallCheck(this, ExchangeUnsubResponseDecoder);
    }

    ExchangeUnsubResponseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    ExchangeUnsubResponseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.ExchangeUnsubscribeResponse();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);

        return out;
    };

    return ExchangeUnsubResponseDecoder;
}();

exports["default"] = ExchangeUnsubResponseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/ExchangeUnsubResponseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/ExchangeUnsubResponseDef":31,"_process":131,"buffer":121,"timers":152}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _HeartbeatDef = require("../../controlMessageDefinition/HeartbeatDef");

var def = _interopRequireWildcard(_HeartbeatDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HeartbeatDecoder = function () {
    function HeartbeatDecoder() {
        _classCallCheck(this, HeartbeatDecoder);
    }

    HeartbeatDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    HeartbeatDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.Heartbeat();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        return out;
    };

    return HeartbeatDecoder;
}();

exports["default"] = HeartbeatDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/HeartbeatDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/HeartbeatDef":33,"_process":131,"buffer":121,"timers":152}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _InitialDataSentDef = require("../../controlMessageDefinition/InitialDataSentDef");

var def = _interopRequireWildcard(_InitialDataSentDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var InitialDataSentDecoder = function () {
    function InitialDataSentDecoder() {
        _classCallCheck(this, InitialDataSentDecoder);
    }

    InitialDataSentDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    InitialDataSentDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.InitialDataSent();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);
        return out;
    };

    return InitialDataSentDecoder;
}();

exports["default"] = InitialDataSentDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/InitialDataSentDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/InitialDataSentDef":34,"_process":131,"buffer":121,"timers":152}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _ResubscribeMessageDef = require("../../controlMessageDefinition/ResubscribeMessageDef");

var def = _interopRequireWildcard(_ResubscribeMessageDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResubscribeMessageDecoder = function () {
    function ResubscribeMessageDecoder() {
        _classCallCheck(this, ResubscribeMessageDecoder);
    }

    ResubscribeMessageDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    ResubscribeMessageDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.ResubscribeMessage();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        return out;
    };

    return ResubscribeMessageDecoder;
}();

exports["default"] = ResubscribeMessageDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/ResubscribeMessageDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/ResubscribeMessageDef":35,"_process":131,"buffer":121,"timers":152}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SlowConnectionDef = require("../../controlMessageDefinition/SlowConnectionDef");

var def = _interopRequireWildcard(_SlowConnectionDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SlowConnectionDecoder = function () {
    function SlowConnectionDecoder() {
        _classCallCheck(this, SlowConnectionDecoder);
    }

    SlowConnectionDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    SlowConnectionDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.SlowConnection();
        out.timesExceeded = _Qitch2["default"].int32(src, offset + def.TIMES_EXCEED_OFFSET);
        out.maxExceed = _Qitch2["default"].int32(src, offset + def.MAX_EXCEED_OFFSET);
        return out;
    };

    return SlowConnectionDecoder;
}();

exports["default"] = SlowConnectionDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/SlowConnectionDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/SlowConnectionDef":36,"_process":131,"buffer":121,"timers":152}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _StatsResponseDef = require("../../controlMessageDefinition/StatsResponseDef");

var def = _interopRequireWildcard(_StatsResponseDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StatsResponseDecoder = function () {
    function StatsResponseDecoder() {
        _classCallCheck(this, StatsResponseDecoder);
    }

    StatsResponseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    StatsResponseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.StatsResponse();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);
        out.numberOfSubscribedSymbolsL1 = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_SUBSCRIBED_L1_OFFSET);
        out.numberOfAvailableSymbolsL1 = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_AVAILABLE_L1_OFFSET);
        out.numberOfSubscribedSymbolsL2 = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_SUBSCRIBED_L2_OFFSET);
        out.numberOfAvailableSymbolsL2 = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_AVAILABLE_L2_OFFSET);
        out.numberOfOpenedConnections = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_OPENED_CONNECTIONS);
        out.numberOfAvailableConnections = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_AVAILABLE_CONNECTIONS);
        return out;
    };

    return StatsResponseDecoder;
}();

exports["default"] = StatsResponseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/StatsResponseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/StatsResponseDef":38,"_process":131,"buffer":121,"timers":152}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SubUnsubAlertResponseDef = require("../../controlMessageDefinition/SubUnsubAlertResponseDef");

var def = _interopRequireWildcard(_SubUnsubAlertResponseDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SubUnsubAlertResponseDecoder = function () {
    function SubUnsubAlertResponseDecoder() {
        _classCallCheck(this, SubUnsubAlertResponseDecoder);
    }

    SubUnsubAlertResponseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    SubUnsubAlertResponseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.AlertSubUnsubResponse();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);
        out.operation = _Qitch2["default"].asciiString(src, offset + def.OPERATION_OFFSET, def.FIXED_OPERATION_LENGTH);
        return out;
    };

    return SubUnsubAlertResponseDecoder;
}();

exports["default"] = SubUnsubAlertResponseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/SubUnsubAlertResponseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../controlMessageDefinition/SubUnsubAlertResponseDef":40,"_process":131,"buffer":121,"timers":152}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SubscribeResponseDef = require("../../controlMessageDefinition/SubscribeResponseDef");

var def = _interopRequireWildcard(_SubscribeResponseDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

var _QitchConstants = require("../../QitchConstants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SubscribeResponseDecoder = function () {
    function SubscribeResponseDecoder() {
        _classCallCheck(this, SubscribeResponseDecoder);
    }

    SubscribeResponseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    SubscribeResponseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.SubscribeResponse();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);

        var numberOfEntitlements = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_ENTITLEMENTS_OFFSET);
        var numberOfRejectedSymbols = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_REJECTED_SYMBOLS_OFFSET);
        var numberOfInvalidSymbols = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_INVALID_SYMBOLS_OFFSET);

        out.entitlements = this._decodeEntitlements(src, offset + def.FIXED_LENGTH, numberOfEntitlements);
        out.rejectedsymbols = this._decodeSymbolList(src, offset + def.FIXED_LENGTH + numberOfEntitlements * _QitchConstants.ENTITLEMENT_LENGTH, numberOfRejectedSymbols);
        out.invalidsymbols = this._decodeSymbolList(src, offset + def.FIXED_LENGTH + numberOfEntitlements * _QitchConstants.ENTITLEMENT_LENGTH + numberOfRejectedSymbols * _QitchConstants.SYMBOL_LENGTH, numberOfInvalidSymbols);

        return out;
    };

    SubscribeResponseDecoder.prototype._decodeEntitlements = function _decodeEntitlements(src, offset, numberOfEntitlements) {
        var entitlements = [];
        for (var i = 0; i < numberOfEntitlements; i++) {
            entitlements.push(_Qitch2["default"].entitlement(src, offset + i * _QitchConstants.ENTITLEMENT_LENGTH));
        }
        return entitlements;
    };

    SubscribeResponseDecoder.prototype._decodeSymbolList = function _decodeSymbolList(src, offset, numberOfSymbols) {
        var symbols = [];
        for (var i = 0; i < numberOfSymbols; i++) {
            symbols.push(_Qitch2["default"].symbol(src, offset + i * _QitchConstants.SYMBOL_LENGTH));
        }
        return symbols;
    };

    return SubscribeResponseDecoder;
}();

exports["default"] = SubscribeResponseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/SubscribeResponseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../QitchConstants":26,"../../controlMessageDefinition/SubscribeResponseDef":42,"_process":131,"buffer":121,"timers":152}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _UnsubscribeResponseDef = require("../../controlMessageDefinition/UnsubscribeResponseDef");

var def = _interopRequireWildcard(_UnsubscribeResponseDef);

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

var _QitchConstants = require("../../QitchConstants");

var _streamerApi = require("../../../streamer-api");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UnsubscribeResponseDecoder = function () {
    function UnsubscribeResponseDecoder() {
        _classCallCheck(this, UnsubscribeResponseDecoder);
    }

    UnsubscribeResponseDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    UnsubscribeResponseDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.control.UnsubscribeResponse();
        out.code = _Qitch2["default"].int32(src, offset + def.CODE_OFFSET);
        out.reason = _Qitch2["default"].reason(src, offset + def.REASON_OFFSET);
        out.requestId = _Qitch2["default"].int32(src, offset + def.REQUEST_ID_OFFSET);

        var numberOfUnsubscribedEntitlements = _Qitch2["default"].int32(src, offset + def.NUMBER_OF_UNSUBSCRIBED_ENTITLEMENTS_OFFSET);
        out.unsubscribed = this._decodeEntitlements(src, offset + def.FIXED_LENGTH, numberOfUnsubscribedEntitlements);

        return out;
    };

    UnsubscribeResponseDecoder.prototype._decodeEntitlements = function _decodeEntitlements(src, offset, numberOfEntitlements) {
        var entitlements = [];
        for (var i = 0; i < numberOfEntitlements; i++) {
            entitlements.push(_Qitch2["default"].entitlement(src, offset + i * _QitchConstants.ENTITLEMENT_LENGTH));
        }
        return entitlements;
    };

    return UnsubscribeResponseDecoder;
}();

exports["default"] = UnsubscribeResponseDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/controlMessageDecoder/UnsubscribeResponseDecoder.js","/lib/qitch/decoder/controlMessageDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../QitchConstants":26,"../../controlMessageDefinition/UnsubscribeResponseDef":43,"_process":131,"buffer":121,"timers":152}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _AlertDef = require("../../marketDataDefinition/AlertDef");

var def = _interopRequireWildcard(_AlertDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AlertDecoder = function () {
    function AlertDecoder() {
        _classCallCheck(this, AlertDecoder);
    }

    AlertDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    AlertDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.Alert();
        out.symbol = _Qitch2["default"].symbol(src, offset + def.SYMBOL_OFFSET);
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.instrumentType = _Qitch2["default"].instrumenttype(src, offset + def.INSTRUMENTTYPE_OFFSET);
        out.alertId = _Qitch2["default"].int64(src, offset + def.ALERT_ID_OFFSET);
        out.triggerValue = _Qitch2["default"].dec8double(src, offset + def.TRIGGER_VALUE_OFFSET);
        return out;
    };

    return AlertDecoder;
}();

exports["default"] = AlertDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/AlertDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/AlertDef":82,"_process":131,"buffer":121,"timers":152}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _BookDeleteDef = require("../../marketDataDefinition/BookDeleteDef");

var def = _interopRequireWildcard(_BookDeleteDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BookDeleteDecoder = function () {
    function BookDeleteDecoder() {
        _classCallCheck(this, BookDeleteDecoder);
    }

    BookDeleteDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    BookDeleteDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.BookDelete();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.orderReference = _Qitch2["default"].orderreference(src, offset + def.ORDER_REFERENCE_OFFSET);
        return out;
    };

    return BookDeleteDecoder;
}();

exports["default"] = BookDeleteDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/BookDeleteDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/BookDeleteDef":83,"_process":131,"buffer":121,"timers":152}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _BookOrderDef = require("../../marketDataDefinition/BookOrderDef");

var def = _interopRequireWildcard(_BookOrderDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BookOrderDecoder = function () {
    function BookOrderDecoder() {
        _classCallCheck(this, BookOrderDecoder);
    }

    BookOrderDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    BookOrderDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.BookOrder();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.marketMakerID = _Qitch2["default"].mmid(src, offset + def.MMID_OFFSET);
        out.orderID = _Qitch2["default"].orderIdLegacy(src, offset + def.ORDERID_OFFSET);
        out.orderSide = _Qitch2["default"].orderside(src, offset + def.SIDE_OFFSET);
        out.price = _Qitch2["default"].dec8double(src, offset + def.PRICE_OFFSET);
        out.size = _Qitch2["default"].int32(src, offset + def.SIZE_OFFSET);
        out.lastUpdate = _Qitch2["default"].timestamp(src, offset + def.LASTUPDATE_OFFSET);
        var flags = _Qitch2["default"].int32(src, offset + def.FLAGS_OFFSET);
        out.flags = flags;
        out.display = def.BookOrderFlags.isDisplay(flags);
        out.orderChangeType = _Qitch2["default"].bookOrderChangeType(src, offset + def.CHANGE_TYPE_OFFSET);
        out.orderReference = _Qitch2["default"].orderreference(src, offset + def.ORDER_REFERENCE_OFFSET);
        out.excode = _Qitch2["default"].excode(src, offset + def.EXCODE_OFFSET);
        return out;
    };

    return BookOrderDecoder;
}();

exports["default"] = BookOrderDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/BookOrderDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/BookOrderDef":84,"_process":131,"buffer":121,"timers":152}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _DerivativeInfoDef = require("../../marketDataDefinition/DerivativeInfoDef");

var def = _interopRequireWildcard(_DerivativeInfoDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DerivativeInfoDecoder = function () {
    function DerivativeInfoDecoder() {
        _classCallCheck(this, DerivativeInfoDecoder);
    }

    DerivativeInfoDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    DerivativeInfoDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.DerivativeInfo();
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.rootSymbol = _Qitch2["default"].symbol(src, offset + def.ROOTSYMBOL_OFFSET);
        out.expiration = _Qitch2["default"].timestamp(src, offset + def.EXPIRATION_OFFSET);
        out.delivery = _Qitch2["default"].timestamp(src, offset + def.DELIVERY_OFFSET);
        out.openInterest = _Qitch2["default"].int64(src, offset + def.OPENINTEREST_OFFSET);
        out.contractSize = _Qitch2["default"].int32(src, offset + def.CONTRACTSIZE_OFFSET);
        out.callPutIndicator = _Qitch2["default"].asciichar(src, offset + def.CALLPUTINDICATOR_OFFSET);
        out.minTickSize = _Qitch2["default"].dec8double(src, offset + def.MINTICKSIZE_OFFSET);
        return out;
    };

    return DerivativeInfoDecoder;
}();

exports["default"] = DerivativeInfoDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/DerivativeInfoDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/DerivativeInfoDef":85,"_process":131,"buffer":121,"timers":152}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _IVGreeksDef = require("../../marketDataDefinition/IVGreeksDef");

var def = _interopRequireWildcard(_IVGreeksDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IVGreeksDecoder = function () {
    function IVGreeksDecoder() {
        _classCallCheck(this, IVGreeksDecoder);
    }

    IVGreeksDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    IVGreeksDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.IVGreeks();
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.LOCATECODE_OFFSET);
        out.lastCalculation = _Qitch2["default"].timestamp(src, offset + def.LAST_CALCULATION_OFFSET);
        out.delta = _Qitch2["default"].dec8double(src, offset + def.DELTA_OFFSET);
        out.gamma = _Qitch2["default"].dec8double(src, offset + def.GAMMA_OFFSET);
        out.vega = _Qitch2["default"].dec8double(src, offset + def.VEGA_OFFSET);
        out.rho = _Qitch2["default"].dec8double(src, offset + def.RHO_OFFSET);
        out.theta = _Qitch2["default"].dec8double(src, offset + def.THETA_OFFSET);
        out.midIV = _Qitch2["default"].dec8double(src, offset + def.IMPLIED_VOLATILITY_OFFSET);
        out.midIVChange = _Qitch2["default"].dec8double(src, offset + def.IMPLIED_VOLATILITY_CHANGE_OFFSET);
        out.bidIV = _Qitch2["default"].dec8double(src, offset + def.BID_IMPLIED_VOLATILITY_OFFSET);
        out.askIV = _Qitch2["default"].dec8double(src, offset + def.ASK_IMPLIED_VOLATILITY_OFFSET);
        out.mark = _Qitch2["default"].dec8double(src, offset + def.MARK_OFFSET);
        out.intrinsicValue = _Qitch2["default"].dec8double(src, offset + def.INTRINSIC_VALUE_OFFSET);
        out.extrinsicValue = _Qitch2["default"].dec8double(src, offset + def.EXTRINSIC_VALUE_OFFSET);
        out.previousMark = _Qitch2["default"].dec8double(src, offset + def.PREVIOUS_MARK_OFFSET);
        out.markChange = _Qitch2["default"].dec8double(src, offset + def.MARK_CHANGE_OFFSET);
        out.markChangePercent = _Qitch2["default"].dec8double(src, offset + def.MARK_CHANGE_PERCENT_OFFSET);
        return out;
    };

    return IVGreeksDecoder;
}();

exports["default"] = IVGreeksDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/IVGreeksDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/IVGreeksDef":86,"_process":131,"buffer":121,"timers":152}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _ImbalanceStatusDef = require("../../marketDataDefinition/ImbalanceStatusDef");

var def = _interopRequireWildcard(_ImbalanceStatusDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ImbalanceStatusDecoder = function () {
    function ImbalanceStatusDecoder() {
        _classCallCheck(this, ImbalanceStatusDecoder);
    }

    ImbalanceStatusDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    ImbalanceStatusDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.ImbalanceStatus();
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.LOCATECODE_OFFSET);
        out.imbalanceType = _Qitch2["default"].imbalancetype(src, offset + def.IMBALANCE_TYPE_OFFSET);
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.referencePrice = _Qitch2["default"].dec8double(src, offset + def.REFERENCEPRICE_OFFSET);
        out.size = _Qitch2["default"].int64(src, offset + def.SIZE_OFFSET);
        out.side = _Qitch2["default"].orderside(src, offset + def.ORDERSIDE_OFFSET);
        out.pairedVolume = _Qitch2["default"].int32(src, offset + def.PAIREDVOLUME_OFFSET);
        out.nearIndicativePrice = _Qitch2["default"].dec8double(src, offset + def.NEARINDICATIVEPRICE_OFFSET);
        out.farIndicativePrice = _Qitch2["default"].dec8double(src, offset + def.FARINDICATIVEPRICE_OFFSET);
        out.priceVariation = _Qitch2["default"].dec8double(src, offset + def.PRICEVARIATION_OFFSET);
        out.symbol = _Qitch2["default"].symbol(src, offset + def.SYMBOL_OFFSET);
        return out;
    };

    return ImbalanceStatusDecoder;
}();

exports["default"] = ImbalanceStatusDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/ImbalanceStatusDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/ImbalanceStatusDef":87,"_process":131,"buffer":121,"timers":152}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _IntervalDef = require("../../marketDataDefinition/IntervalDef");

var def = _interopRequireWildcard(_IntervalDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

var _jsbi = require("jsbi");

var _jsbi2 = _interopRequireDefault(_jsbi);

var _bignumber = require("bignumber.js");

var _bignumber2 = _interopRequireDefault(_bignumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IntervalDecoder = function () {
    function IntervalDecoder() {
        _classCallCheck(this, IntervalDecoder);
    }

    IntervalDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    IntervalDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.Interval();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.open = _Qitch2["default"].dec8double(src, offset + def.OPEN_OFFSET);
        out.low = _Qitch2["default"].dec8double(src, offset + def.LOW_OFFSET);
        out.high = _Qitch2["default"].dec8double(src, offset + def.HIGH_OFFSET);
        out.last = _Qitch2["default"].dec8double(src, offset + def.LAST_OFFSET);
        out.volume = _Qitch2["default"].dec8double(src, offset + def.LONGDECIMALVOLUME_OFFSET);
        out.startTime = _Qitch2["default"].timestamp(src, offset + def.STARTTIME_OFFSET);
        out.openTime = _Qitch2["default"].timestamp(src, offset + def.OPENTIME_OFFSET);
        out.lastTime = _Qitch2["default"].timestamp(src, offset + def.LASTTIME_OFFSET);
        out.tradeValue = _Qitch2["default"].int64(src, offset + def.TRADEVALUE_OFFSET);
        out.vwap = this._vwap(out);
        out.periodMs = _Qitch2["default"].int32(src, offset + def.PERIODMS_OFFSET);
        return out;
    };

    IntervalDecoder.prototype._vwap = function _vwap(interval) {
        if (interval.tradeValue != null && interval.volume != null && interval.volume.toNumber() !== 0) {
            return new _bignumber2["default"](interval.tradeValue.toString()).dividedBy(interval.volume);
        }
        return null;
    };

    return IntervalDecoder;
}();

exports["default"] = IntervalDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/IntervalDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/IntervalDef":88,"_process":131,"bignumber.js":118,"buffer":121,"jsbi":128,"timers":152}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _LastSaleDef = require("../../marketDataDefinition/LastSaleDef");

var def = _interopRequireWildcard(_LastSaleDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LastSaleDecoder = function () {
    function LastSaleDecoder() {
        _classCallCheck(this, LastSaleDecoder);
    }

    LastSaleDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    LastSaleDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.LastSale();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.last = _Qitch2["default"].dec8double(src, offset + def.LAST_OFFSET);
        out.previousClose = _Qitch2["default"].dec8double(src, offset + def.PREVCLOSE_OFFSET);
        out.accumulatedVolume = _Qitch2["default"].int64(src, offset + def.ACCUMULATEDVOLUME_OFFSET);
        out.tick = _Qitch2["default"].tick(src, offset + def.TICK_OFFSET);
        out.change = this._change(out);
        out.percentChange = this._percentChange(out);
        out.lastTradeExcode = _Qitch2["default"].excode(src, offset + def.LASTTRADE_EXCODE_OFFSET);
        return out;
    };

    LastSaleDecoder.prototype._change = function _change(data) {
        if (data.last != null && data.previousClose != null) {
            return data.last.minus(data.previousClose);
        }
        return null;
    };

    LastSaleDecoder.prototype._percentChange = function _percentChange(data) {
        if (data.last != null && data.previousClose != null && !data.previousClose.isEqualTo(0)) {
            return (data.last - data.previousClose) / data.previousClose * 100;
        }
        return null;
    };

    return LastSaleDecoder;
}();

exports["default"] = LastSaleDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/LastSaleDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/LastSaleDef":89,"_process":131,"buffer":121,"timers":152}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _LimitUpLimitDownDef = require("../../marketDataDefinition/LimitUpLimitDownDef");

var def = _interopRequireWildcard(_LimitUpLimitDownDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LimitUpLimitDownDecoder = function () {
    function LimitUpLimitDownDecoder() {
        _classCallCheck(this, LimitUpLimitDownDecoder);
    }

    LimitUpLimitDownDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    LimitUpLimitDownDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.LimitUpLimitDown();

        out.locateCode = _Qitch2["default"].int32(src, offset + def.LOCATECODE_OFFSET);
        out.lowerLimit = _Qitch2["default"].dec8double(src, offset + def.LOWERLIMIT_OFFSET);
        out.effectiveTime = _Qitch2["default"].timestamp(src, offset + def.EFFECTIVETIME_OFFSET);
        out.upperLimit = _Qitch2["default"].dec8double(src, offset + def.UPPERLIMIT_OFFSET);

        var priceBandIndicator = _Qitch2["default"].sbyte(src, offset + def.PRICEBANDINDICATOR_OFFSET);
        out.bidNotExecutable = def.LimitUpLimitDownFlags.isBidNotExecutable(priceBandIndicator);
        out.askNotExecutable = def.LimitUpLimitDownFlags.isAskNotExecutable(priceBandIndicator);
        return out;
    };

    return LimitUpLimitDownDecoder;
}();

exports["default"] = LimitUpLimitDownDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/LimitUpLimitDownDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/LimitUpLimitDownDef":90,"_process":131,"buffer":121,"timers":152}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _MMQuoteDef = require("../../marketDataDefinition/MMQuoteDef");

var def = _interopRequireWildcard(_MMQuoteDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MMQuoteDecoder = function () {
    function MMQuoteDecoder() {
        _classCallCheck(this, MMQuoteDecoder);
    }

    MMQuoteDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    MMQuoteDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.MMQuote();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.bidPrice = _Qitch2["default"].dec8double(src, offset + def.BIDPRICE_OFFSET);
        out.bidSize = _Qitch2["default"].dec8double(src, offset + def.DECIMALBIDSIZE_OFFSET);
        out.askPrice = _Qitch2["default"].dec8double(src, offset + def.ASKPRICE_OFFSET);
        out.askSize = _Qitch2["default"].dec8double(src, offset + def.DECIMALASKSIZE_OFFSET);
        out.marketMakerID = _Qitch2["default"].mmid(src, offset + def.MMID_OFFSET);
        out.indicator = _Qitch2["default"].asciichar(src, offset + def.INDICATOR_OFFSET);
        out.bidChange = _Qitch2["default"].dec8double(src, offset + def.BIDCHANGE_OFFSET);
        out.askChange = _Qitch2["default"].dec8double(src, offset + def.ASKCHANGE_OFFSET);
        out.sharesPerSizeUnit = _Qitch2["default"].int32(src, offset + def.SHARESPERSIZEUNIT_OFFSET);
        return out;
    };

    return MMQuoteDecoder;
}();

exports["default"] = MMQuoteDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/MMQuoteDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/MMQuoteDef":91,"_process":131,"buffer":121,"timers":152}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _NethousePositionDef = require("../../marketDataDefinition/NethousePositionDef");

var def = _interopRequireWildcard(_NethousePositionDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NethousePositionDecoder = function () {
    function NethousePositionDecoder() {
        _classCallCheck(this, NethousePositionDecoder);
    }

    NethousePositionDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    NethousePositionDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.NethousePosition();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.marketMakerID = _Qitch2["default"].mmid(src, offset + def.MMID_OFFSET);
        out.buyValue = _Qitch2["default"].dec8double(src, offset + def.BUYVALUE_OFFSET);
        out.buyVolume = _Qitch2["default"].int64(src, offset + def.BUYVOLUME_OFFSET);
        out.sellValue = _Qitch2["default"].dec8double(src, offset + def.SELLVALUE_OFFSET);
        out.sellVolume = _Qitch2["default"].int64(src, offset + def.SELLVOLUME_OFFSET);
        out.buyBlockValue = _Qitch2["default"].dec8double(src, offset + def.BUYBLOCKVALUE_OFFSET);
        out.buyBlockVolume = _Qitch2["default"].int64(src, offset + def.BUYBLOCKVOLUME_OFFSET);
        out.sellBlockValue = _Qitch2["default"].dec8double(src, offset + def.SELLBLOCKVALUE_OFFSET);
        out.sellBlockVolume = _Qitch2["default"].int64(src, offset + def.SELLBLOCKVOLUME_OFFSET);
        out.buyTransactions = _Qitch2["default"].int32(src, offset + def.BUYTRANSACTIONS_OFFSET);
        out.sellTransactions = _Qitch2["default"].int32(src, offset + def.SELLTRANSACTIONS_OFFSET);
        out.buyBlockTransactions = _Qitch2["default"].int32(src, offset + def.BUYBLOCKTRANSACTIONS_OFFSET);
        out.sellBlockTransactions = _Qitch2["default"].int32(src, offset + def.SELLBLOCKTRANSACTIONS_OFFSET);
        return out;
    };

    return NethousePositionDecoder;
}();

exports["default"] = NethousePositionDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/NethousePositionDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/NethousePositionDef":92,"_process":131,"buffer":121,"timers":152}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _PricedataDef = require("../../marketDataDefinition/PricedataDef");

var def = _interopRequireWildcard(_PricedataDef);

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

var _streamerApi = require("../../../streamer-api.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PricedataDecoder = function () {
    function PricedataDecoder() {
        _classCallCheck(this, PricedataDecoder);
    }

    PricedataDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    PricedataDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.PriceData();
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.last = _Qitch2["default"].dec8double(src, offset + def.LAST_OFFSET);
        out.previousClose = _Qitch2["default"].dec8double(src, offset + def.PREVCLOSE_OFFSET);
        out.open = _Qitch2["default"].dec8double(src, offset + def.OPEN_OFFSET);
        out.high = _Qitch2["default"].dec8double(src, offset + def.HIGH_OFFSET);
        out.low = _Qitch2["default"].dec8double(src, offset + def.LOW_OFFSET);
        out.accumulatedVolume = _Qitch2["default"].dec8double(src, offset + def.DECIMALACCUMULATEDVOLUME_OFFSET);
        out.lastTradeTime = _Qitch2["default"].timestamp(src, offset + def.LASTTRADETIME_OFFSET);
        out.tick = _Qitch2["default"].tick(src, offset + def.TICK_OFFSET);
        out.lastTradeSize = _Qitch2["default"].dec8double(src, offset + def.DECIMALLASTTRADESIZE_OFFSET);
        out.close = _Qitch2["default"].dec8double(src, offset + def.CLOSE_OFFSET);
        out.tradeCount = _Qitch2["default"].int64(src, offset + def.TRADECOUNT_OFFSET);
        out.accumulatedPrice = null; // @Deprecatd
        out.accumulatedTradeValue = _Qitch2["default"].dec8double(src, offset + def.ACCUMULATEDTRADEVALUE_OFFSET);
        out.change = this._change(out);
        out.percentChange = this._percentChange(out);
        var flags = _Qitch2["default"].sbyte(src, offset + def.FLAGS_OFFSET);
        out.annualHigh = def.PricedataFlags.isAnnualHigh(flags);
        out.annualLow = def.PricedataFlags.isAnnualLow(flags);
        out.vwap = _Qitch2["default"].dec8double(src, offset + def.VWAP_OFFSET);
        out.twap = _Qitch2["default"].dec8double(src, offset + def.TWAP_OFFSET);

        out.preMarketTradeTime = _Qitch2["default"].timestamp(src, offset + def.PREMARKETTRADETIME_OFFSET);
        out.preMarketLast = _Qitch2["default"].dec8double(src, offset + def.PREMARKETLASTPRICE_OFFSET);
        out.preMarketVolume = _Qitch2["default"].dec8double(src, offset + def.DECIMALPREMARKETVOLUME_OFFSET);
        out.preMarketChange = _Qitch2["default"].dec8double(src, offset + def.PREMARKETCHANGE_OFFSET);
        out.preMarketPercentChange = this._premarketPercentChange(out);
        out.postMarketTradeTime = _Qitch2["default"].timestamp(src, offset + def.POSTMARKETTRADETIME_OFFSET);
        out.postMarketLast = _Qitch2["default"].dec8double(src, offset + def.POSTMARKETLASTPRICE_OFFSET);
        out.postMarketVolume = _Qitch2["default"].dec8double(src, offset + def.DECIMALPOSTMARKETVOLUME_OFFSET);
        out.postMarketChange = _Qitch2["default"].dec8double(src, offset + def.POSTMARKETCHANGE_OFFSET);
        out.postMarketPercentChange = this._postmarketPercentChange(out);
        out.lastTradeExcode = _Qitch2["default"].excode(src, offset + def.LASTTRADEEXCODE_OFFSET);
        out.currencyID = _Qitch2["default"].currencyid(src, offset + def.CURRENCYID_OFFSET);

        return out;
    };

    PricedataDecoder.prototype._change = function _change(data) {
        if (data.last != null && data.previousClose != null) {
            return data.last.minus(data.previousClose);
        }
        return null;
    };

    PricedataDecoder.prototype._percentChange = function _percentChange(data) {
        if (data.last != null && data.previousClose != null && !data.previousClose.isEqualTo(0)) {
            return data.last.minus(data.previousClose).dividedBy(data.previousClose).multipliedBy(100);
        }
        return null;
    };

    PricedataDecoder.prototype._premarketPercentChange = function _premarketPercentChange(data) {
        if (data.preMarketChange != null) {
            if (data.close != null && !data.close.isEqualTo(0)) {
                return data.preMarketChange.minus(data.close).dividedBy(data.close).multipliedBy(100);
            } else if (data.previousClose != null && !data.previousClose.isEqualTo(0)) {
                return data.preMarketChange.minus(data.previousClose).dividedBy(data.previousClose).multipliedBy(100);
            }
        }
        return null;
    };

    PricedataDecoder.prototype._postmarketPercentChange = function _postmarketPercentChange(data) {
        if (data.postMarketLast != null && data.last != null && !data.last.isEqualTo(0)) {
            return data.postMarketLast.minus(data.last).dividedBy(data.last).multipliedBy(100);
        }
        return null;
    };

    return PricedataDecoder;
}();

exports["default"] = PricedataDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/PricedataDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api.js":108,"../../Qitch":25,"../../marketDataDefinition/PricedataDef":93,"_process":131,"buffer":121,"timers":152}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _PurgeBookDef = require("../../marketDataDefinition/PurgeBookDef");

var def = _interopRequireWildcard(_PurgeBookDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PurgeBookDecoder = function () {
    function PurgeBookDecoder() {
        _classCallCheck(this, PurgeBookDecoder);
    }

    PurgeBookDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    PurgeBookDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.PurgeBook();
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        return out;
    };

    return PurgeBookDecoder;
}();

exports["default"] = PurgeBookDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/PurgeBookDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/PurgeBookDef":94,"_process":131,"buffer":121,"timers":152}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _QuoteDef = require("../../marketDataDefinition/QuoteDef");

var def = _interopRequireWildcard(_QuoteDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var QuoteDecoder = function () {
    function QuoteDecoder() {
        _classCallCheck(this, QuoteDecoder);
    }

    QuoteDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    QuoteDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.Quote();
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        out.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        out.askCondition = _Qitch2["default"].asciichar(src, offset + def.ASKCONDITION_OFFSET);
        out.askExcode = _Qitch2["default"].excode(src, offset + def.ASKEXCODE_OFFSET);
        out.askPrice = _Qitch2["default"].dec8double(src, offset + def.ASKPRICE_OFFSET);
        out.askSize = _Qitch2["default"].dec8double(src, offset + def.DECIMALASKSIZE_OFFSET);
        out.bidCondition = _Qitch2["default"].asciichar(src, offset + def.BIDCONDITION_OFFSET);
        out.bidExcode = _Qitch2["default"].excode(src, offset + def.BIDEXCODE_OFFSET);
        out.bidPrice = _Qitch2["default"].dec8double(src, offset + def.BIDPRICE_OFFSET);
        out.bidSize = _Qitch2["default"].dec8double(src, offset + def.DECIMALBIDSIZE_OFFSET);
        out.indicator = _Qitch2["default"].asciichar(src, offset + def.INDICATOR_OFFSET);
        out.sharesPerSizeUnit = _Qitch2["default"].int32(src, offset + def.SHARESPERSIZEUNIT_OFFSET);
        return out;
    };

    return QuoteDecoder;
}();

exports["default"] = QuoteDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/QuoteDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/QuoteDef":95,"_process":131,"buffer":121,"timers":152}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SymbolInfoDef = require("../../marketDataDefinition/SymbolInfoDef");

var def = _interopRequireWildcard(_SymbolInfoDef);

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

var _streamerApi = require("../../../streamer-api.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolInfoDecoder = function () {
    function SymbolInfoDecoder() {
        _classCallCheck(this, SymbolInfoDecoder);
    }

    SymbolInfoDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    SymbolInfoDecoder.prototype.decode = function decode(src, offset) {
        var resultingMessage = new _streamerApi.messages.market.SymbolInfo();
        resultingMessage.symbol = _Qitch2["default"].symbol(src, offset + def.SYMBOL_OFFSET);
        resultingMessage.locateCode = _Qitch2["default"].locatecode(src, offset + def.LOCATECODE_OFFSET);
        resultingMessage.excode = _Qitch2["default"].excode(src, offset + def.EXCODE_OFFSET);
        resultingMessage.instrumentType = _Qitch2["default"].instrumenttype(src, offset + def.INSTRUMENTTYPE_OFFSET);
        resultingMessage.currencyId = _Qitch2["default"].currencyid(src, offset + def.CURRENCYID_OFFSET);
        resultingMessage.haltStatus = _Qitch2["default"].sbyte(src, offset + def.HALTSTATUS_OFFSET);
        resultingMessage.haltIndicator = _Qitch2["default"].sbyte(src, offset + def.HALTINDICATOR_OFFSET);
        resultingMessage.regSHOStatus = _Qitch2["default"].asciichar(src, offset + def.REGSHOSTATUS_OFFSET);
        resultingMessage.pqe = _Qitch2["default"].sbyte(src, offset + def.PQE_OFFSET) > 0;
        resultingMessage.caveatEmptor = _Qitch2["default"].sbyte(src, offset + def.CAVEATEMPTOR_OFFSET) > 0;
        resultingMessage.boardLotSize = _Qitch2["default"].int32(src, offset + def.BOARDLOTSIZE_OFFSET);

        return resultingMessage;
    };

    return SymbolInfoDecoder;
}();

exports["default"] = SymbolInfoDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/SymbolInfoDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api.js":108,"../../Qitch":25,"../../marketDataDefinition/SymbolInfoDef":96,"_process":131,"buffer":121,"timers":152}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SymbolStatusDef = require("../../marketDataDefinition/SymbolStatusDef");

var def = _interopRequireWildcard(_SymbolStatusDef);

var _streamerApi = require("../../../streamer-api");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolStatusDecoder = function () {
    function SymbolStatusDecoder() {
        _classCallCheck(this, SymbolStatusDecoder);
    }

    SymbolStatusDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    SymbolStatusDecoder.prototype.decode = function decode(src, offset) {
        var out = new _streamerApi.messages.market.SymbolStatus();
        out.locateCode = _Qitch2["default"].locatecode(src, offset + def.LOCATE_CODE_OFFSET);
        out.haltStatus = _Qitch2["default"].sbyte(src, offset + def.HALTSTATUS_OFFSET);
        out.haltIndicator = _Qitch2["default"].sbyte(src, offset + def.HALTINDICATOR_OFFSET);
        out.regSHOStatus = _Qitch2["default"].asciichar(src, offset + def.REGSHOSTATUS_OFFSET);
        out.closingCalculatedPrice = _Qitch2["default"].dec8double(src, offset + def.CLOSINGPRICE_OFFSET);
        out.effectiveTime = _Qitch2["default"].timestamp(src, offset + def.EFFECTIVETIME_OFFSET);
        out.openingTime = _Qitch2["default"].timestamp(src, offset + def.OPENINGTIME_OFFSET);
        out.note = _Qitch2["default"].note(src, offset + def.NOTE_OFFSET);
        out.symbol = _Qitch2["default"].symbol(src, offset + def.SYMBOL_OFFSET);
        return out;
    };

    return SymbolStatusDecoder;
}();

exports["default"] = SymbolStatusDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/SymbolStatusDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api":108,"../../Qitch":25,"../../marketDataDefinition/SymbolStatusDef":97,"_process":131,"buffer":121,"timers":152}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

var _streamerApi = require("../../../streamer-api.js");

var _TradeDef = require("../../marketDataDefinition/TradeDef");

var def = _interopRequireWildcard(_TradeDef);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TradeDecoder = function () {
    function TradeDecoder() {
        _classCallCheck(this, TradeDecoder);
    }

    TradeDecoder.prototype.type = function type() {
        return def.TYPEID;
    };

    TradeDecoder.prototype.decode = function decode(src, offset) {
        var resultingMessage = new _streamerApi.messages.market.Trade();
        resultingMessage.timestamp = _Qitch2["default"].timestamp(src, offset + def.TIMESTAMP_OFFSET);
        resultingMessage.locateCode = _Qitch2["default"].locatecode(src, offset + def.SYMBOL_OFFSET);
        resultingMessage.price = _Qitch2["default"].dec8double(src, offset + def.PRICE_OFFSET);
        resultingMessage.size = _Qitch2["default"].dec8double(src, offset + def.DECIMALSIZE_OFFSET);
        resultingMessage.indicator = _Qitch2["default"].asciichar(src, offset + def.INDICATOR_OFFSET);
        resultingMessage.tick = _Qitch2["default"].tick(src, offset + def.TICK_OFFSET);
        resultingMessage.accumulatedVolume = _Qitch2["default"].int64(src, offset + def.ACCUMULATEDVOLUME_OFFSET);
        resultingMessage.sequenceNumber = _Qitch2["default"].int32(src, offset + def.SEQUENCENUMBER_OFFSET);
        resultingMessage.flags = _Qitch2["default"].int32(src, offset + def.FLAGS_OFFSET);
        resultingMessage.buyerID = _Qitch2["default"].mmid(src, offset + def.BUYERMMID_OFFSET);
        resultingMessage.sellerID = _Qitch2["default"].mmid(src, offset + def.SELLERMMID_OFFSET);
        resultingMessage.rangeIndicator = _Qitch2["default"].rangeindicator(src, offset + def.RANGEINDICATOR_OFFSET);
        resultingMessage.matchID = _Qitch2["default"].int64(src, offset + def.MATCHID_OFFSET);
        resultingMessage.vwap = _Qitch2["default"].dec8double(src, offset + def.VWAP_OFFSET);
        resultingMessage.excode = _Qitch2["default"].excode(src, offset + def.EXCODE_OFFSET);
        return resultingMessage;
    };

    return TradeDecoder;
}();

exports["default"] = TradeDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/decoder/dataDecoder/TradeDecoder.js","/lib/qitch/decoder/dataDecoder")
},{"../../../streamer-api.js":108,"../../Qitch":25,"../../marketDataDefinition/TradeDef":98,"_process":131,"buffer":121,"timers":152}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _streamerApi = require("../../streamer-api");

var _SMessage = require("../../SMessage");

var _SMessage2 = _interopRequireDefault(_SMessage);

var _QitchConstants = require("../QitchConstants");

var _BlockHeader = require("../BlockHeader");

var _BlockHeader2 = _interopRequireDefault(_BlockHeader);

var _streamerUtils = require("../../streamer-utils");

var _MessageHeader = require("../MessageHeader");

var _MessageHeader2 = _interopRequireDefault(_MessageHeader);

var _StatsMessageEncoder = require("./controlMessageEncoder/StatsMessageEncoder");

var _StatsMessageEncoder2 = _interopRequireDefault(_StatsMessageEncoder);

var _SubscribeMessageEncoder = require("./controlMessageEncoder/SubscribeMessageEncoder");

var _SubscribeMessageEncoder2 = _interopRequireDefault(_SubscribeMessageEncoder);

var _FlowMessageEncoder = require("./controlMessageEncoder/FlowMessageEncoder");

var _FlowMessageEncoder2 = _interopRequireDefault(_FlowMessageEncoder);

var _ExchangeSubscribeMessageEncoder = require("./controlMessageEncoder/ExchangeSubscribeMessageEncoder");

var _ExchangeSubscribeMessageEncoder2 = _interopRequireDefault(_ExchangeSubscribeMessageEncoder);

var _SubUnsubAlertMessageEncoder = require("./controlMessageEncoder/SubUnsubAlertMessageEncoder");

var _SubUnsubAlertMessageEncoder2 = _interopRequireDefault(_SubUnsubAlertMessageEncoder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
    Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
 */
var QitchEncoder = function () {
    function QitchEncoder() {
        _classCallCheck(this, QitchEncoder);

        this.encoder = new MessageEncoder();
    }

    /**
     * Encodes a message into its binary representation.
     * @param msg Msg {SMessage} the message to encode
     * @param offset The offset used to write message into a buffer
     * @returns  {ArrayBuffer} the encoded bytes
     * @throws Throws an error if message cannot be encoded
     */


    QitchEncoder.prototype.encode = function encode(msg, offset) {
        if (msg == null) {
            throw "Argument cannot be null.";
        }
        if (!msg instanceof _SMessage2["default"]) {
            throw "Wrong message type";
        }
        var messageLength = this.encoder.length(msg.payload);
        var blockLength = _QitchConstants.BLOCK_HEADER_LENGTH + messageLength;
        var bytes = new ArrayBuffer(offset + blockLength);
        var view = new Int8Array(bytes);
        _BlockHeader2["default"].lengthToBytes(view, offset, messageLength);
        _BlockHeader2["default"].messageCountToBytes(view, offset, 1);
        _BlockHeader2["default"].reservedToBytes(view, offset, 0x00);
        _BlockHeader2["default"].sequenceToBytes(view, offset, msg.sequencenumber);
        return this.encoder.encode(view, offset + _QitchConstants.BLOCK_HEADER_LENGTH, msg.payload);
    };

    return QitchEncoder;
}();

var MessageEncoder = function () {
    function MessageEncoder() {
        _classCallCheck(this, MessageEncoder);

        this[_streamerApi.messages.MessageTypeNames.ctrl.STATS] = new _StatsMessageEncoder2["default"]();
        this[_streamerApi.messages.MessageTypeNames.ctrl.FLOW] = new _FlowMessageEncoder2["default"]();
        this[_streamerApi.messages.MessageTypeNames.ctrl.SUBSCRIBE] = new _SubscribeMessageEncoder2["default"]();
        this[_streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_SUBSCRIBE] = new _ExchangeSubscribeMessageEncoder2["default"]();
        this[_streamerApi.messages.MessageTypeNames.ctrl.ALERTS_SUBUNSUB] = new _SubUnsubAlertMessageEncoder2["default"]();
    }

    MessageEncoder.prototype.length = function length(message) {
        var encoder = this[(0, _streamerUtils.messagetype)(message)];
        if (encoder !== null) {
            return encoder.length(message) + _QitchConstants.MESSAGE_HEADER_LENGTH;
        }
        return 0;
    };

    MessageEncoder.prototype.encode = function encode(dst, offset, message) {
        var encoder = this[(0, _streamerUtils.messagetype)(message)];
        if (encoder !== null) {
            _MessageHeader2["default"].lengthGetBytes(dst, offset, encoder.length(message));
            _MessageHeader2["default"].typeGetBytes(dst, offset, encoder.type());
            return encoder.encode(dst, offset + _QitchConstants.MESSAGE_HEADER_LENGTH, message);
        }
        return dst;
    };

    return MessageEncoder;
}();

exports["default"] = QitchEncoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/encoder/QitchEncoder.js","/lib/qitch/encoder")
},{"../../SMessage":5,"../../streamer-api":108,"../../streamer-utils":110,"../BlockHeader":19,"../MessageHeader":24,"../QitchConstants":26,"./controlMessageEncoder/ExchangeSubscribeMessageEncoder":77,"./controlMessageEncoder/FlowMessageEncoder":78,"./controlMessageEncoder/StatsMessageEncoder":79,"./controlMessageEncoder/SubUnsubAlertMessageEncoder":80,"./controlMessageEncoder/SubscribeMessageEncoder":81,"_process":131,"buffer":121,"timers":152}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _ExchangeSubscribeMessageDef = require("../../controlMessageDefinition/ExchangeSubscribeMessageDef");

var def = _interopRequireWildcard(_ExchangeSubscribeMessageDef);

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExchangeSubscribeMessageEncoder = function () {
    function ExchangeSubscribeMessageEncoder() {
        _classCallCheck(this, ExchangeSubscribeMessageEncoder);
    }

    ExchangeSubscribeMessageEncoder.prototype.type = function type() {
        return def.TYPEID;
    };

    ExchangeSubscribeMessageEncoder.prototype.length = function length(message) {
        return def.FIXED_LENGTH;
    };

    ExchangeSubscribeMessageEncoder.prototype.encode = function encode(dst, offset, message) {
        _Qitch2["default"].putInt32(dst, offset + def.REQUEST_ID_OFFSET, message.id);
        _Qitch2["default"].putAction(dst, offset + def.ACTION_OFFSET, message.action);
        _Qitch2["default"].putMimetype(dst, offset + def.MIMETYPE_OFFSET, message.mimetype);
        _Qitch2["default"].putConflation(dst, offset + def.CONFLATION_OFFSET, message.conflation);
        _Qitch2["default"].putExcode(dst, offset + def.EXCODE_OFFSET, message.exchange);
        return dst;
    };

    return ExchangeSubscribeMessageEncoder;
}();

exports["default"] = ExchangeSubscribeMessageEncoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/encoder/controlMessageEncoder/ExchangeSubscribeMessageEncoder.js","/lib/qitch/encoder/controlMessageEncoder")
},{"../../Qitch":25,"../../controlMessageDefinition/ExchangeSubscribeMessageDef":29,"_process":131,"buffer":121,"timers":152}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _FlowMessageDef = require("../../controlMessageDefinition/FlowMessageDef");

var def = _interopRequireWildcard(_FlowMessageDef);

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FlowMessageEncoder = function () {
    function FlowMessageEncoder() {
        _classCallCheck(this, FlowMessageEncoder);
    }

    FlowMessageEncoder.prototype.type = function type() {
        return def.TYPEID;
    };

    FlowMessageEncoder.prototype.length = function length(msg) {
        return def.LENGTH;
    };

    FlowMessageEncoder.prototype.encode = function encode(dst, offset, msg) {
        _Qitch2["default"].putInt32(dst, offset + def.SEQUENCE_NUMBER_OFFSET, msg.sequence);
        return dst;
    };

    return FlowMessageEncoder;
}();

exports["default"] = FlowMessageEncoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/encoder/controlMessageEncoder/FlowMessageEncoder.js","/lib/qitch/encoder/controlMessageEncoder")
},{"../../Qitch":25,"../../controlMessageDefinition/FlowMessageDef":32,"_process":131,"buffer":121,"timers":152}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _StatsMessageDef = require("../../controlMessageDefinition/StatsMessageDef");

var def = _interopRequireWildcard(_StatsMessageDef);

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StatsMessageEncoder = function () {
    function StatsMessageEncoder() {
        _classCallCheck(this, StatsMessageEncoder);
    }

    StatsMessageEncoder.prototype.type = function type() {
        return def.TYPEID;
    };

    StatsMessageEncoder.prototype.length = function length(msg) {
        return def.LENGTH;
    };

    StatsMessageEncoder.prototype.encode = function encode(dst, offset, msg) {
        _Qitch2["default"].putInt32(dst, offset + def.REQUEST_ID_OFFSET, msg.sequenceNumber);
        return dst;
    };

    return StatsMessageEncoder;
}();

exports["default"] = StatsMessageEncoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/encoder/controlMessageEncoder/StatsMessageEncoder.js","/lib/qitch/encoder/controlMessageEncoder")
},{"../../Qitch":25,"../../controlMessageDefinition/StatsMessageDef":37,"_process":131,"buffer":121,"timers":152}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SubUnsubAlertMessageDef = require("../../controlMessageDefinition/SubUnsubAlertMessageDef");

var def = _interopRequireWildcard(_SubUnsubAlertMessageDef);

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SubUnsubAlertMessageEncoder = function () {
    function SubUnsubAlertMessageEncoder() {
        _classCallCheck(this, SubUnsubAlertMessageEncoder);
    }

    SubUnsubAlertMessageEncoder.prototype.type = function type() {
        return def.TYPEID;
    };

    SubUnsubAlertMessageEncoder.prototype.length = function length(message) {
        return def.FIXED_LENGTH;
    };

    SubUnsubAlertMessageEncoder.prototype.encode = function encode(dst, offset, message) {
        _Qitch2["default"].putInt32(dst, offset + def.REQUEST_ID_OFFSET, message.id);
        _Qitch2["default"].putAsciiString(dst, offset + def.OPERATION_OFFSET, message.operation, def.FIXED_OPERATION_LENGTH);
        _Qitch2["default"].putMimetype(dst, offset + def.MIMETYPE_OFFSET, message.mimetype);
        return dst;
    };

    return SubUnsubAlertMessageEncoder;
}();

exports["default"] = SubUnsubAlertMessageEncoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/encoder/controlMessageEncoder/SubUnsubAlertMessageEncoder.js","/lib/qitch/encoder/controlMessageEncoder")
},{"../../Qitch":25,"../../controlMessageDefinition/SubUnsubAlertMessageDef":39,"_process":131,"buffer":121,"timers":152}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SubscribeMessageDef = require("../../controlMessageDefinition/SubscribeMessageDef");

var def = _interopRequireWildcard(_SubscribeMessageDef);

var _QitchConstants = require("../../QitchConstants");

var _Qitch = require("../../Qitch");

var _Qitch2 = _interopRequireDefault(_Qitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SubscribeMessageEncoder = function () {
    function SubscribeMessageEncoder() {
        _classCallCheck(this, SubscribeMessageEncoder);
    }

    SubscribeMessageEncoder.prototype.type = function type() {
        return def.TYPEID;
    };

    SubscribeMessageEncoder.prototype.length = function length(message) {
        var symbolsLength = _QitchConstants.SYMBOL_LENGTH * message.symbols.length;
        var marketdataTypesLength = _QitchConstants.MARKETDATATYPE_LENGTH * message.types.length;
        return def.FIXED_LENGTH + symbolsLength + marketdataTypesLength;
    };

    SubscribeMessageEncoder.prototype.encode = function encode(dst, offset, message) {
        var symbolsLength = _QitchConstants.SYMBOL_LENGTH * message.symbols.length;

        _Qitch2["default"].putInt32(dst, offset + def.REQUEST_ID_OFFSET, message.id);
        _Qitch2["default"].putAction(dst, offset + def.ACTION_OFFSET, message.action);
        _Qitch2["default"].putMimetype(dst, offset + def.MIMETYPE_OFFSET, message.mimetype);
        _Qitch2["default"].putBool(dst, offset + def.SKIP_HEAVY_INITIAL_LOAD_OFFSET, message.skipHeavyInitialLoad);
        _Qitch2["default"].putConflation(dst, offset + def.CONFLATION_OFFSET, message.conflation);
        _Qitch2["default"].putInt32(dst, offset + def.NUMBER_OF_SYMBOLS_OFFSET, message.symbols.length);
        _Qitch2["default"].putByte(dst, offset + def.NUMBER_OF_TYPES_OFFSET, message.types.length);
        this._encodeSymbols(message, offset + def.FIXED_LENGTH, dst);
        this._encodeMarketdataTypes(message, offset + def.FIXED_LENGTH + symbolsLength, dst);
        return dst;
    };

    SubscribeMessageEncoder.prototype._encodeSymbols = function _encodeSymbols(message, offset, dst) {
        for (var i = 0; i < message.symbols.length; i++) {
            _Qitch2["default"].putSymbol(dst, offset + i * _QitchConstants.SYMBOL_LENGTH, message.symbols[i]);
        }
    };

    SubscribeMessageEncoder.prototype._encodeMarketdataTypes = function _encodeMarketdataTypes(message, offset, dst) {
        for (var i = 0; i < message.types.length; i++) {
            _Qitch2["default"].putMarketdatatype(dst, offset + i * _QitchConstants.MARKETDATATYPE_LENGTH, message.types[i]);
        }
    };

    return SubscribeMessageEncoder;
}();

exports["default"] = SubscribeMessageEncoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/encoder/controlMessageEncoder/SubscribeMessageEncoder.js","/lib/qitch/encoder/controlMessageEncoder")
},{"../../Qitch":25,"../../QitchConstants":26,"../../controlMessageDefinition/SubscribeMessageDef":41,"_process":131,"buffer":121,"timers":152}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.TRIGGER_VALUE_OFFSET = exports.ALERT_ID_OFFSET = exports.INSTRUMENTTYPE_OFFSET = exports.TIMESTAMP_OFFSET = exports.SYMBOL_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 17;

var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = 0;
var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = SYMBOL_OFFSET + _QitchConstants.SYMBOL_LENGTH;
var INSTRUMENTTYPE_OFFSET = exports.INSTRUMENTTYPE_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var ALERT_ID_OFFSET = exports.ALERT_ID_OFFSET = INSTRUMENTTYPE_OFFSET + _QitchConstants.INSTRUMENTTYPE_LENGTH;
var TRIGGER_VALUE_OFFSET = exports.TRIGGER_VALUE_OFFSET = ALERT_ID_OFFSET + _QitchConstants.LONG_LENGTH;
var LENGTH = exports.LENGTH = TRIGGER_VALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/AlertDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.ORDER_REFERENCE_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 5;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var ORDER_REFERENCE_OFFSET = exports.ORDER_REFERENCE_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var LENGTH = exports.LENGTH = ORDER_REFERENCE_OFFSET + _QitchConstants.ORDER_REFERENCE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/BookDeleteDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.BookOrderFlags = exports.LENGTH = exports.EXCODE_OFFSET = exports.ORDER_REFERENCE_OFFSET = exports.CHANGE_TYPE_OFFSET = exports.FLAGS_OFFSET = exports.LASTUPDATE_OFFSET = exports.SIZE_OFFSET = exports.PRICE_OFFSET = exports.SIDE_OFFSET = exports.ORDERID_OFFSET = exports.MMID_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPEID = exports.TYPEID = 4;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var MMID_OFFSET = exports.MMID_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var ORDERID_OFFSET = exports.ORDERID_OFFSET = MMID_OFFSET + _QitchConstants.MMID_LENGTH;
var SIDE_OFFSET = exports.SIDE_OFFSET = ORDERID_OFFSET + _QitchConstants.ORDERID_LENGTH;
var PRICE_OFFSET = exports.PRICE_OFFSET = SIDE_OFFSET + _QitchConstants.ORDERSIDE_LENGTH;
var SIZE_OFFSET = exports.SIZE_OFFSET = PRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LASTUPDATE_OFFSET = exports.LASTUPDATE_OFFSET = SIZE_OFFSET + _QitchConstants.INT_LENGTH;
var FLAGS_OFFSET = exports.FLAGS_OFFSET = LASTUPDATE_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var CHANGE_TYPE_OFFSET = exports.CHANGE_TYPE_OFFSET = FLAGS_OFFSET + _QitchConstants.INT_LENGTH;
var ORDER_REFERENCE_OFFSET = exports.ORDER_REFERENCE_OFFSET = CHANGE_TYPE_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var EXCODE_OFFSET = exports.EXCODE_OFFSET = ORDER_REFERENCE_OFFSET + _QitchConstants.ORDER_REFERENCE_LENGTH;
var LENGTH = exports.LENGTH = EXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;

var BookOrderFlags = exports.BookOrderFlags = function () {
    function BookOrderFlags() {
        _classCallCheck(this, BookOrderFlags);
    }

    BookOrderFlags.isLotsOf = function isLotsOf(bits) {
        return (bits & BookOrderFlags.prototype.LOTSOF_MASK) > 0;
    };

    BookOrderFlags.isAllOrNone = function isAllOrNone(bits) {
        return (bits & BookOrderFlags.prototype.ALLORNONE_MASK) > 0;
    };

    BookOrderFlags.isMinimumFillVolume = function isMinimumFillVolume(bits) {
        return (bits & BookOrderFlags.prototype.MINIMUMFILLVOLUME_MASK) > 0;
    };

    BookOrderFlags.isNonResident = function isNonResident(bits) {
        return (bits & BookOrderFlags.prototype.NONRESIDENT_MASK) > 0;
    };

    BookOrderFlags.isCashSettlement = function isCashSettlement(bits) {
        return (bits & BookOrderFlags.prototype.CASHSETTLEMENT_MASK) > 0;
    };

    BookOrderFlags.isCashTodaySettlement = function isCashTodaySettlement(bits) {
        return (bits & BookOrderFlags.prototype.CASHTODAYSETTLEMENT_MASK) > 0;
    };

    BookOrderFlags.isDelayedDateSettlement = function isDelayedDateSettlement(bits) {
        return (bits & BookOrderFlags.prototype.DELAYEDDATESETTLEMENT_MASK) > 0;
    };

    BookOrderFlags.isDerivativeRelatedSettlement = function isDerivativeRelatedSettlement(bits) {
        return (bits & BookOrderFlags.prototype.DERIVATIVERELATEDSETTLEMENT_MASK) > 0;
    };

    BookOrderFlags.isNonNetSettlement = function isNonNetSettlement(bits) {
        return (bits & BookOrderFlags.prototype.NONNETSETTLEMENT_MASK) > 0;
    };

    BookOrderFlags.isMarketOrder = function isMarketOrder(bits) {
        return (bits & BookOrderFlags.prototype.MARKETORDER_MASK) > 0;
    };

    BookOrderFlags.isFirmQuote = function isFirmQuote(bits) {
        return (bits & BookOrderFlags.prototype.FIRMQUOTE_MASK) > 0;
    };

    BookOrderFlags.isDisplay = function isDisplay(bits) {
        return (bits & BookOrderFlags.prototype.DISPLAY_MASK) > 0;
    };

    BookOrderFlags.isMarketPrice = function isMarketPrice(bits) {
        return (bits & BookOrderFlags.prototype.PRICE_MARKET_MASK) > 0;
    };

    BookOrderFlags.isOpeningPrice = function isOpeningPrice(bits) {
        return (bits & BookOrderFlags.prototype.PRICE_OPENING_MASK) > 0;
    };

    BookOrderFlags.isPriceMustBeFilled = function isPriceMustBeFilled(bits) {
        return (bits & BookOrderFlags.prototype.PRICE_MUSTBEFILLED_MASK) > 0;
    };

    BookOrderFlags.isFutureSettlement = function isFutureSettlement(bits) {
        return (bits & BookOrderFlags.prototype.FUTURESETTLEMENT_MASK) > 0;
    };

    BookOrderFlags.isNextDaySettlement = function isNextDaySettlement(bits) {
        return (bits & BookOrderFlags.prototype.NEXTDAYSETTLEMENT_MASK) > 0;
    };

    return BookOrderFlags;
}();

BookOrderFlags.prototype.LOTSOF_MASK = 0x0001;
BookOrderFlags.prototype.ALLORNONE_MASK = 0x0002;
BookOrderFlags.prototype.MINIMUMFILLVOLUME_MASK = 0x0004;
BookOrderFlags.prototype.NONRESIDENT_MASK = 0x0008;
BookOrderFlags.prototype.CASHSETTLEMENT_MASK = 0x0010;
BookOrderFlags.prototype.CASHTODAYSETTLEMENT_MASK = 0x0020;
BookOrderFlags.prototype.DELAYEDDATESETTLEMENT_MASK = 0x0040;
BookOrderFlags.prototype.DERIVATIVERELATEDSETTLEMENT_MASK = 0x0080;
BookOrderFlags.prototype.NONNETSETTLEMENT_MASK = 0x0100;
BookOrderFlags.prototype.MARKETORDER_MASK = 0x0200;
BookOrderFlags.prototype.FIRMQUOTE_MASK = 0x0400;
BookOrderFlags.prototype.DISPLAY_MASK = 0x01000000;
BookOrderFlags.prototype.PRICE_MARKET_MASK = 0x10000000;
BookOrderFlags.prototype.PRICE_OPENING_MASK = 0x20000000;
BookOrderFlags.prototype.PRICE_MUSTBEFILLED_MASK = 0x40000000;
BookOrderFlags.prototype.FUTURESETTLEMENT_MASK = 0x0800;
BookOrderFlags.prototype.NEXTDAYSETTLEMENT_MASK = 0x1000;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/BookOrderDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.MINTICKSIZE_OFFSET = exports.CALLPUTINDICATOR_OFFSET = exports.CONTRACTSIZE_OFFSET = exports.OPENINTEREST_OFFSET = exports.DELIVERY_OFFSET = exports.EXPIRATION_OFFSET = exports.ROOTSYMBOL_OFFSET = exports.SYMBOL_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 12;

var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = 0;
var ROOTSYMBOL_OFFSET = exports.ROOTSYMBOL_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var EXPIRATION_OFFSET = exports.EXPIRATION_OFFSET = ROOTSYMBOL_OFFSET + _QitchConstants.SYMBOL_LENGTH;
var DELIVERY_OFFSET = exports.DELIVERY_OFFSET = EXPIRATION_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var OPENINTEREST_OFFSET = exports.OPENINTEREST_OFFSET = DELIVERY_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var CONTRACTSIZE_OFFSET = exports.CONTRACTSIZE_OFFSET = OPENINTEREST_OFFSET + _QitchConstants.LONG_LENGTH;
var CALLPUTINDICATOR_OFFSET = exports.CALLPUTINDICATOR_OFFSET = CONTRACTSIZE_OFFSET + _QitchConstants.INT_LENGTH;
var MINTICKSIZE_OFFSET = exports.MINTICKSIZE_OFFSET = CALLPUTINDICATOR_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var LENGTH = exports.LENGTH = MINTICKSIZE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/DerivativeInfoDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.MARK_CHANGE_PERCENT_OFFSET = exports.MARK_CHANGE_OFFSET = exports.PREVIOUS_MARK_OFFSET = exports.EXTRINSIC_VALUE_OFFSET = exports.INTRINSIC_VALUE_OFFSET = exports.MARK_OFFSET = exports.LAST_CALCULATION_OFFSET = exports.ASK_IMPLIED_VOLATILITY_OFFSET = exports.BID_IMPLIED_VOLATILITY_OFFSET = exports.IMPLIED_VOLATILITY_CHANGE_OFFSET = exports.IMPLIED_VOLATILITY_OFFSET = exports.THETA_OFFSET = exports.RHO_OFFSET = exports.VEGA_OFFSET = exports.GAMMA_OFFSET = exports.DELTA_OFFSET = exports.LOCATECODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 15;

var LOCATECODE_OFFSET = exports.LOCATECODE_OFFSET = 0;
var DELTA_OFFSET = exports.DELTA_OFFSET = LOCATECODE_OFFSET + _QitchConstants.INT_LENGTH;
var GAMMA_OFFSET = exports.GAMMA_OFFSET = DELTA_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var VEGA_OFFSET = exports.VEGA_OFFSET = GAMMA_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var RHO_OFFSET = exports.RHO_OFFSET = VEGA_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var THETA_OFFSET = exports.THETA_OFFSET = RHO_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var IMPLIED_VOLATILITY_OFFSET = exports.IMPLIED_VOLATILITY_OFFSET = THETA_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var IMPLIED_VOLATILITY_CHANGE_OFFSET = exports.IMPLIED_VOLATILITY_CHANGE_OFFSET = IMPLIED_VOLATILITY_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var BID_IMPLIED_VOLATILITY_OFFSET = exports.BID_IMPLIED_VOLATILITY_OFFSET = IMPLIED_VOLATILITY_CHANGE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var ASK_IMPLIED_VOLATILITY_OFFSET = exports.ASK_IMPLIED_VOLATILITY_OFFSET = BID_IMPLIED_VOLATILITY_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LAST_CALCULATION_OFFSET = exports.LAST_CALCULATION_OFFSET = ASK_IMPLIED_VOLATILITY_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var MARK_OFFSET = exports.MARK_OFFSET = LAST_CALCULATION_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var INTRINSIC_VALUE_OFFSET = exports.INTRINSIC_VALUE_OFFSET = MARK_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var EXTRINSIC_VALUE_OFFSET = exports.EXTRINSIC_VALUE_OFFSET = INTRINSIC_VALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var PREVIOUS_MARK_OFFSET = exports.PREVIOUS_MARK_OFFSET = EXTRINSIC_VALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var MARK_CHANGE_OFFSET = exports.MARK_CHANGE_OFFSET = PREVIOUS_MARK_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var MARK_CHANGE_PERCENT_OFFSET = exports.MARK_CHANGE_PERCENT_OFFSET = MARK_CHANGE_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var LENGTH = exports.LENGTH = MARK_CHANGE_PERCENT_OFFSET + _QitchConstants.DOUBLE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/IVGreeksDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.SYMBOL_OFFSET = exports.PRICEVARIATION_OFFSET = exports.FARINDICATIVEPRICE_OFFSET = exports.NEARINDICATIVEPRICE_OFFSET = exports.PAIREDVOLUME_OFFSET = exports.ORDERSIDE_OFFSET = exports.SIZE_OFFSET = exports.REFERENCEPRICE_OFFSET = exports.TIMESTAMP_OFFSET = exports.IMBALANCE_TYPE_OFFSET = exports.LOCATECODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 16;

var LOCATECODE_OFFSET = exports.LOCATECODE_OFFSET = 0;
var IMBALANCE_TYPE_OFFSET = exports.IMBALANCE_TYPE_OFFSET = LOCATECODE_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = IMBALANCE_TYPE_OFFSET + _QitchConstants.IMBALANCETYPE_LENGTH;
var REFERENCEPRICE_OFFSET = exports.REFERENCEPRICE_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var SIZE_OFFSET = exports.SIZE_OFFSET = REFERENCEPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var ORDERSIDE_OFFSET = exports.ORDERSIDE_OFFSET = SIZE_OFFSET + _QitchConstants.LONG_LENGTH;
var PAIREDVOLUME_OFFSET = exports.PAIREDVOLUME_OFFSET = ORDERSIDE_OFFSET + _QitchConstants.ORDERSIDE_LENGTH;
var NEARINDICATIVEPRICE_OFFSET = exports.NEARINDICATIVEPRICE_OFFSET = PAIREDVOLUME_OFFSET + _QitchConstants.INT_LENGTH;
var FARINDICATIVEPRICE_OFFSET = exports.FARINDICATIVEPRICE_OFFSET = NEARINDICATIVEPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var PRICEVARIATION_OFFSET = exports.PRICEVARIATION_OFFSET = FARINDICATIVEPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = PRICEVARIATION_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LENGTH = exports.LENGTH = SYMBOL_OFFSET + _QitchConstants.SYMBOL_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/ImbalanceStatusDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.PERIODMS_OFFSET = exports.LONGDECIMALVOLUME_OFFSET = exports.TRADEVALUE_OFFSET = exports.LASTTIME_OFFSET = exports.OPENTIME_OFFSET = exports.STARTTIME_OFFSET = exports.VOLUME_OFFSET = exports.LAST_OFFSET = exports.HIGH_OFFSET = exports.LOW_OFFSET = exports.OPEN_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 8;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var OPEN_OFFSET = exports.OPEN_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var LOW_OFFSET = exports.LOW_OFFSET = OPEN_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var HIGH_OFFSET = exports.HIGH_OFFSET = LOW_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LAST_OFFSET = exports.LAST_OFFSET = HIGH_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var VOLUME_OFFSET = exports.VOLUME_OFFSET = LAST_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var STARTTIME_OFFSET = exports.STARTTIME_OFFSET = VOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var OPENTIME_OFFSET = exports.OPENTIME_OFFSET = STARTTIME_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var LASTTIME_OFFSET = exports.LASTTIME_OFFSET = OPENTIME_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var TRADEVALUE_OFFSET = exports.TRADEVALUE_OFFSET = LASTTIME_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var LONGDECIMALVOLUME_OFFSET = exports.LONGDECIMALVOLUME_OFFSET = TRADEVALUE_OFFSET + _QitchConstants.LONG_LENGTH;
var PERIODMS_OFFSET = exports.PERIODMS_OFFSET = LONGDECIMALVOLUME_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LENGTH = exports.LENGTH = PERIODMS_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/IntervalDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.LASTTRADE_EXCODE_OFFSET = exports.TICK_OFFSET = exports.ACCUMULATEDVOLUME_OFFSET = exports.PREVCLOSE_OFFSET = exports.LAST_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 13;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var LAST_OFFSET = exports.LAST_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var PREVCLOSE_OFFSET = exports.PREVCLOSE_OFFSET = LAST_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var ACCUMULATEDVOLUME_OFFSET = exports.ACCUMULATEDVOLUME_OFFSET = PREVCLOSE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var TICK_OFFSET = exports.TICK_OFFSET = ACCUMULATEDVOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var LASTTRADE_EXCODE_OFFSET = exports.LASTTRADE_EXCODE_OFFSET = TICK_OFFSET + _QitchConstants.TICK_LENGTH;
var LENGTH = exports.LENGTH = LASTTRADE_EXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/LastSaleDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LimitUpLimitDownFlags = exports.LENGTH = exports.UPPERLIMIT_OFFSET = exports.LOWERLIMIT_OFFSET = exports.EFFECTIVETIME_OFFSET = exports.PRICEBANDINDICATOR_OFFSET = exports.LOCATECODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPEID = exports.TYPEID = 14;

var LOCATECODE_OFFSET = exports.LOCATECODE_OFFSET = 0;
var PRICEBANDINDICATOR_OFFSET = exports.PRICEBANDINDICATOR_OFFSET = LOCATECODE_OFFSET + _QitchConstants.INT_LENGTH;
var EFFECTIVETIME_OFFSET = exports.EFFECTIVETIME_OFFSET = PRICEBANDINDICATOR_OFFSET + _QitchConstants.BYTE_LENGTH;
var LOWERLIMIT_OFFSET = exports.LOWERLIMIT_OFFSET = EFFECTIVETIME_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var UPPERLIMIT_OFFSET = exports.UPPERLIMIT_OFFSET = LOWERLIMIT_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var LENGTH = exports.LENGTH = UPPERLIMIT_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var LimitUpLimitDownFlags = exports.LimitUpLimitDownFlags = function () {
    function LimitUpLimitDownFlags() {
        _classCallCheck(this, LimitUpLimitDownFlags);
    }

    LimitUpLimitDownFlags.isBidNotExecutable = function isBidNotExecutable(bits) {
        return (bits & LimitUpLimitDownFlags.prototype.BID_NOT_EXECUTABLE) > 0;
    };

    LimitUpLimitDownFlags.isAskNotExecutable = function isAskNotExecutable(bits) {
        return (bits & LimitUpLimitDownFlags.prototype.ASK_NOT_EXECUTABLE) > 0;
    };

    return LimitUpLimitDownFlags;
}();

LimitUpLimitDownFlags.prototype.BID_NOT_EXECUTABLE = 0x1;
LimitUpLimitDownFlags.prototype.ASK_NOT_EXECUTABLE = 0x2;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/LimitUpLimitDownDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.DECIMALASKSIZE_OFFSET = exports.DECIMALBIDSIZE_OFFSET = exports.SHARESPERSIZEUNIT_OFFSET = exports.ASKCHANGE_OFFSET = exports.BIDCHANGE_OFFSET = exports.INDICATOR_OFFSET = exports.MMID_OFFSET = exports.ASKSIZE_OFFSET = exports.ASKPRICE_OFFSET = exports.BIDSIZE_OFFSET = exports.BIDPRICE_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 7;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var BIDPRICE_OFFSET = exports.BIDPRICE_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var BIDSIZE_OFFSET = exports.BIDSIZE_OFFSET = BIDPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var ASKPRICE_OFFSET = exports.ASKPRICE_OFFSET = BIDSIZE_OFFSET + _QitchConstants.INT_LENGTH;
var ASKSIZE_OFFSET = exports.ASKSIZE_OFFSET = ASKPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var MMID_OFFSET = exports.MMID_OFFSET = ASKSIZE_OFFSET + _QitchConstants.INT_LENGTH;
var INDICATOR_OFFSET = exports.INDICATOR_OFFSET = MMID_OFFSET + _QitchConstants.MMID_LENGTH;
var BIDCHANGE_OFFSET = exports.BIDCHANGE_OFFSET = INDICATOR_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var ASKCHANGE_OFFSET = exports.ASKCHANGE_OFFSET = BIDCHANGE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var SHARESPERSIZEUNIT_OFFSET = exports.SHARESPERSIZEUNIT_OFFSET = ASKCHANGE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var DECIMALBIDSIZE_OFFSET = exports.DECIMALBIDSIZE_OFFSET = SHARESPERSIZEUNIT_OFFSET + _QitchConstants.INT_LENGTH;
var DECIMALASKSIZE_OFFSET = exports.DECIMALASKSIZE_OFFSET = DECIMALBIDSIZE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LENGTH = exports.LENGTH = DECIMALASKSIZE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/MMQuoteDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.SELLBLOCKTRANSACTIONS_OFFSET = exports.BUYBLOCKTRANSACTIONS_OFFSET = exports.SELLTRANSACTIONS_OFFSET = exports.BUYTRANSACTIONS_OFFSET = exports.SELLBLOCKVOLUME_OFFSET = exports.SELLBLOCKVALUE_OFFSET = exports.BUYBLOCKVOLUME_OFFSET = exports.BUYBLOCKVALUE_OFFSET = exports.SELLVOLUME_OFFSET = exports.SELLVALUE_OFFSET = exports.BUYVOLUME_OFFSET = exports.BUYVALUE_OFFSET = exports.MMID_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 9;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var MMID_OFFSET = exports.MMID_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var BUYVALUE_OFFSET = exports.BUYVALUE_OFFSET = MMID_OFFSET + _QitchConstants.MMID_LENGTH;
var BUYVOLUME_OFFSET = exports.BUYVOLUME_OFFSET = BUYVALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var SELLVALUE_OFFSET = exports.SELLVALUE_OFFSET = BUYVOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var SELLVOLUME_OFFSET = exports.SELLVOLUME_OFFSET = SELLVALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var BUYBLOCKVALUE_OFFSET = exports.BUYBLOCKVALUE_OFFSET = SELLVOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var BUYBLOCKVOLUME_OFFSET = exports.BUYBLOCKVOLUME_OFFSET = BUYBLOCKVALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var SELLBLOCKVALUE_OFFSET = exports.SELLBLOCKVALUE_OFFSET = BUYBLOCKVOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var SELLBLOCKVOLUME_OFFSET = exports.SELLBLOCKVOLUME_OFFSET = SELLBLOCKVALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var BUYTRANSACTIONS_OFFSET = exports.BUYTRANSACTIONS_OFFSET = SELLBLOCKVOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var SELLTRANSACTIONS_OFFSET = exports.SELLTRANSACTIONS_OFFSET = BUYTRANSACTIONS_OFFSET + _QitchConstants.INT_LENGTH;
var BUYBLOCKTRANSACTIONS_OFFSET = exports.BUYBLOCKTRANSACTIONS_OFFSET = SELLTRANSACTIONS_OFFSET + _QitchConstants.INT_LENGTH;
var SELLBLOCKTRANSACTIONS_OFFSET = exports.SELLBLOCKTRANSACTIONS_OFFSET = BUYBLOCKTRANSACTIONS_OFFSET + _QitchConstants.INT_LENGTH;
var LENGTH = exports.LENGTH = SELLBLOCKTRANSACTIONS_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/NethousePositionDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.PricedataFlags = exports.LENGTH = exports.CURRENCYID_OFFSET = exports.DECIMALLASTTRADESIZE_OFFSET = exports.DECIMALPOSTMARKETVOLUME_OFFSET = exports.DECIMALPREMARKETVOLUME_OFFSET = exports.DECIMALACCUMULATEDVOLUME_OFFSET = exports.LASTTRADEEXCODE_OFFSET = exports.POSTMARKETCHANGE_OFFSET = exports.POSTMARKETVOLUME_OFFSET = exports.POSTMARKETLASTPRICE_OFFSET = exports.POSTMARKETTRADETIME_OFFSET = exports.PREMARKETCHANGE_OFFSET = exports.PREMARKETVOLUME_OFFSET = exports.PREMARKETLASTPRICE_OFFSET = exports.PREMARKETTRADETIME_OFFSET = exports.TWAP_OFFSET = exports.VWAP_OFFSET = exports.FLAGS_OFFSET = exports.ACCUMULATEDTRADEVALUE_OFFSET = exports.TRADECOUNT_OFFSET = exports.CLOSE_OFFSET = exports.LASTTRADESIZE_OFFSET = exports.TICK_OFFSET = exports.LASTTRADETIME_OFFSET = exports.ACCUMULATEDVOLUME_OFFSET = exports.LOW_OFFSET = exports.HIGH_OFFSET = exports.OPEN_OFFSET = exports.PREVCLOSE_OFFSET = exports.LAST_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPEID = exports.TYPEID = 2;
var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var LAST_OFFSET = exports.LAST_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var PREVCLOSE_OFFSET = exports.PREVCLOSE_OFFSET = LAST_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var OPEN_OFFSET = exports.OPEN_OFFSET = PREVCLOSE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var HIGH_OFFSET = exports.HIGH_OFFSET = OPEN_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LOW_OFFSET = exports.LOW_OFFSET = HIGH_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var ACCUMULATEDVOLUME_OFFSET = exports.ACCUMULATEDVOLUME_OFFSET = LOW_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LASTTRADETIME_OFFSET = exports.LASTTRADETIME_OFFSET = ACCUMULATEDVOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var TICK_OFFSET = exports.TICK_OFFSET = LASTTRADETIME_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var LASTTRADESIZE_OFFSET = exports.LASTTRADESIZE_OFFSET = TICK_OFFSET + _QitchConstants.TICK_LENGTH;
var CLOSE_OFFSET = exports.CLOSE_OFFSET = LASTTRADESIZE_OFFSET + _QitchConstants.INT_LENGTH;
var TRADECOUNT_OFFSET = exports.TRADECOUNT_OFFSET = CLOSE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var ACCUMULATEDTRADEVALUE_OFFSET = exports.ACCUMULATEDTRADEVALUE_OFFSET = TRADECOUNT_OFFSET + _QitchConstants.LONG_LENGTH;
var FLAGS_OFFSET = exports.FLAGS_OFFSET = ACCUMULATEDTRADEVALUE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var VWAP_OFFSET = exports.VWAP_OFFSET = FLAGS_OFFSET + 1;
var TWAP_OFFSET = exports.TWAP_OFFSET = VWAP_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var PREMARKETTRADETIME_OFFSET = exports.PREMARKETTRADETIME_OFFSET = TWAP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var PREMARKETLASTPRICE_OFFSET = exports.PREMARKETLASTPRICE_OFFSET = PREMARKETTRADETIME_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var PREMARKETVOLUME_OFFSET = exports.PREMARKETVOLUME_OFFSET = PREMARKETLASTPRICE_OFFSET + _QitchConstants.LONG_LENGTH;
var PREMARKETCHANGE_OFFSET = exports.PREMARKETCHANGE_OFFSET = PREMARKETVOLUME_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var POSTMARKETTRADETIME_OFFSET = exports.POSTMARKETTRADETIME_OFFSET = PREMARKETCHANGE_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var POSTMARKETLASTPRICE_OFFSET = exports.POSTMARKETLASTPRICE_OFFSET = POSTMARKETTRADETIME_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var POSTMARKETVOLUME_OFFSET = exports.POSTMARKETVOLUME_OFFSET = POSTMARKETLASTPRICE_OFFSET + _QitchConstants.LONG_LENGTH;
var POSTMARKETCHANGE_OFFSET = exports.POSTMARKETCHANGE_OFFSET = POSTMARKETVOLUME_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LASTTRADEEXCODE_OFFSET = exports.LASTTRADEEXCODE_OFFSET = POSTMARKETCHANGE_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var DECIMALACCUMULATEDVOLUME_OFFSET = exports.DECIMALACCUMULATEDVOLUME_OFFSET = LASTTRADEEXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;
var DECIMALPREMARKETVOLUME_OFFSET = exports.DECIMALPREMARKETVOLUME_OFFSET = DECIMALACCUMULATEDVOLUME_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var DECIMALPOSTMARKETVOLUME_OFFSET = exports.DECIMALPOSTMARKETVOLUME_OFFSET = DECIMALPREMARKETVOLUME_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var DECIMALLASTTRADESIZE_OFFSET = exports.DECIMALLASTTRADESIZE_OFFSET = DECIMALPOSTMARKETVOLUME_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var CURRENCYID_OFFSET = exports.CURRENCYID_OFFSET = DECIMALLASTTRADESIZE_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var LENGTH = exports.LENGTH = CURRENCYID_OFFSET + _QitchConstants.CURRENCYID_LENGTH;

var PricedataFlags = exports.PricedataFlags = function () {
    function PricedataFlags() {
        _classCallCheck(this, PricedataFlags);
    }

    PricedataFlags.isAnnualHigh = function isAnnualHigh(bits) {
        return (bits & PricedataFlags.prototype.ANNUALHIGH_MASK) > 0;
    };

    PricedataFlags.isAnnualLow = function isAnnualLow(bits) {
        return (bits & PricedataFlags.prototype.ANNUALLOW_MASK) > 0;
    };

    return PricedataFlags;
}();

PricedataFlags.prototype.ANNUALHIGH_MASK = 0x01;
PricedataFlags.prototype.ANNUALLOW_MASK = 0x02;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/PricedataDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.SYMBOL_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 6;

var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = 0;
var LENGTH = exports.LENGTH = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/PurgeBookDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.DECIMALBIDSIZE_OFFSET = exports.DECIMALASKSIZE_OFFSET = exports.SHARESPERSIZEUNIT_OFFSET = exports.INDICATOR_OFFSET = exports.BIDSIZE_OFFSET = exports.BIDPRICE_OFFSET = exports.BIDEXCODE_OFFSET = exports.BIDCONDITION_OFFSET = exports.ASKSIZE_OFFSET = exports.ASKPRICE_OFFSET = exports.ASKEXCODE_OFFSET = exports.ASKCONDITION_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 1;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var ASKCONDITION_OFFSET = exports.ASKCONDITION_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var ASKEXCODE_OFFSET = exports.ASKEXCODE_OFFSET = ASKCONDITION_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var ASKPRICE_OFFSET = exports.ASKPRICE_OFFSET = ASKEXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;
var ASKSIZE_OFFSET = exports.ASKSIZE_OFFSET = ASKPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var BIDCONDITION_OFFSET = exports.BIDCONDITION_OFFSET = ASKSIZE_OFFSET + _QitchConstants.INT_LENGTH;
var BIDEXCODE_OFFSET = exports.BIDEXCODE_OFFSET = BIDCONDITION_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var BIDPRICE_OFFSET = exports.BIDPRICE_OFFSET = BIDEXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;
var BIDSIZE_OFFSET = exports.BIDSIZE_OFFSET = BIDPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var INDICATOR_OFFSET = exports.INDICATOR_OFFSET = BIDSIZE_OFFSET + _QitchConstants.INT_LENGTH;
var SHARESPERSIZEUNIT_OFFSET = exports.SHARESPERSIZEUNIT_OFFSET = INDICATOR_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var DECIMALASKSIZE_OFFSET = exports.DECIMALASKSIZE_OFFSET = SHARESPERSIZEUNIT_OFFSET + _QitchConstants.INT_LENGTH;
var DECIMALBIDSIZE_OFFSET = exports.DECIMALBIDSIZE_OFFSET = DECIMALASKSIZE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var LENGTH = exports.LENGTH = DECIMALBIDSIZE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/QuoteDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.BOARDLOTSIZE_OFFSET = exports.CAVEATEMPTOR_OFFSET = exports.PQE_OFFSET = exports.REGSHOSTATUS_OFFSET = exports.HALTINDICATOR_OFFSET = exports.HALTSTATUS_OFFSET = exports.CURRENCYID_OFFSET = exports.INSTRUMENTTYPE_OFFSET = exports.EXCODE_OFFSET = exports.LOCATECODE_OFFSET = exports.SYMBOL_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 10;

var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = 0;
var LOCATECODE_OFFSET = exports.LOCATECODE_OFFSET = SYMBOL_OFFSET + _QitchConstants.SYMBOL_LENGTH;
var EXCODE_OFFSET = exports.EXCODE_OFFSET = LOCATECODE_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var INSTRUMENTTYPE_OFFSET = exports.INSTRUMENTTYPE_OFFSET = EXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;
var CURRENCYID_OFFSET = exports.CURRENCYID_OFFSET = INSTRUMENTTYPE_OFFSET + _QitchConstants.INSTRUMENTTYPE_LENGTH;
var HALTSTATUS_OFFSET = exports.HALTSTATUS_OFFSET = CURRENCYID_OFFSET + _QitchConstants.CURRENCYID_LENGTH;
var HALTINDICATOR_OFFSET = exports.HALTINDICATOR_OFFSET = HALTSTATUS_OFFSET + _QitchConstants.BYTE_LENGTH;
var REGSHOSTATUS_OFFSET = exports.REGSHOSTATUS_OFFSET = HALTINDICATOR_OFFSET + _QitchConstants.BYTE_LENGTH;
var PQE_OFFSET = exports.PQE_OFFSET = REGSHOSTATUS_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var CAVEATEMPTOR_OFFSET = exports.CAVEATEMPTOR_OFFSET = PQE_OFFSET + _QitchConstants.BYTE_LENGTH;
var BOARDLOTSIZE_OFFSET = exports.BOARDLOTSIZE_OFFSET = CAVEATEMPTOR_OFFSET + _QitchConstants.BYTE_LENGTH;
var LENGTH = exports.LENGTH = BOARDLOTSIZE_OFFSET + _QitchConstants.INT_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/SymbolInfoDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.LENGTH = exports.SYMBOL_OFFSET = exports.NOTE_OFFSET = exports.OPENINGTIME_OFFSET = exports.EFFECTIVETIME_OFFSET = exports.CLOSINGPRICE_OFFSET = exports.REGSHOSTATUS_OFFSET = exports.HALTINDICATOR_OFFSET = exports.HALTSTATUS_OFFSET = exports.LOCATE_CODE_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

var TYPEID = exports.TYPEID = 11;

var LOCATE_CODE_OFFSET = exports.LOCATE_CODE_OFFSET = 0;
var HALTSTATUS_OFFSET = exports.HALTSTATUS_OFFSET = LOCATE_CODE_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var HALTINDICATOR_OFFSET = exports.HALTINDICATOR_OFFSET = HALTSTATUS_OFFSET + _QitchConstants.BYTE_LENGTH;
var REGSHOSTATUS_OFFSET = exports.REGSHOSTATUS_OFFSET = HALTINDICATOR_OFFSET + _QitchConstants.BYTE_LENGTH;
var CLOSINGPRICE_OFFSET = exports.CLOSINGPRICE_OFFSET = REGSHOSTATUS_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var EFFECTIVETIME_OFFSET = exports.EFFECTIVETIME_OFFSET = CLOSINGPRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var OPENINGTIME_OFFSET = exports.OPENINGTIME_OFFSET = EFFECTIVETIME_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var NOTE_OFFSET = exports.NOTE_OFFSET = OPENINGTIME_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = NOTE_OFFSET + _QitchConstants.NOTE_LENGTH;

var LENGTH = exports.LENGTH = SYMBOL_OFFSET + _QitchConstants.SYMBOL_LENGTH;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/SymbolStatusDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
exports.TradeFlags = exports.LENGTH = exports.DECIMALSIZE_OFFSET = exports.EXCODE_OFFSET = exports.VWAP_OFFSET = exports.MATCHID_OFFSET = exports.RANGEINDICATOR_OFFSET = exports.SELLERMMID_OFFSET = exports.BUYERMMID_OFFSET = exports.FLAGS_OFFSET = exports.SEQUENCENUMBER_OFFSET = exports.ACCUMULATEDVOLUME_OFFSET = exports.TICK_OFFSET = exports.INDICATOR_OFFSET = exports.SIZE_OFFSET = exports.PRICE_OFFSET = exports.SYMBOL_OFFSET = exports.TIMESTAMP_OFFSET = exports.TYPEID = undefined;

var _QitchConstants = require("../QitchConstants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPEID = exports.TYPEID = 3;

var TIMESTAMP_OFFSET = exports.TIMESTAMP_OFFSET = 0;
var SYMBOL_OFFSET = exports.SYMBOL_OFFSET = TIMESTAMP_OFFSET + _QitchConstants.TIMESTAMP_LENGTH;
var PRICE_OFFSET = exports.PRICE_OFFSET = SYMBOL_OFFSET + _QitchConstants.LOCATECODE_LENGTH;
var SIZE_OFFSET = exports.SIZE_OFFSET = PRICE_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var INDICATOR_OFFSET = exports.INDICATOR_OFFSET = SIZE_OFFSET + _QitchConstants.INT_LENGTH;
var TICK_OFFSET = exports.TICK_OFFSET = INDICATOR_OFFSET + _QitchConstants.ASCIICHAR_LENGTH;
var ACCUMULATEDVOLUME_OFFSET = exports.ACCUMULATEDVOLUME_OFFSET = TICK_OFFSET + _QitchConstants.TICK_LENGTH;
var SEQUENCENUMBER_OFFSET = exports.SEQUENCENUMBER_OFFSET = ACCUMULATEDVOLUME_OFFSET + _QitchConstants.LONG_LENGTH;
var FLAGS_OFFSET = exports.FLAGS_OFFSET = SEQUENCENUMBER_OFFSET + _QitchConstants.INT_LENGTH;
var BUYERMMID_OFFSET = exports.BUYERMMID_OFFSET = FLAGS_OFFSET + _QitchConstants.INT_LENGTH;
var SELLERMMID_OFFSET = exports.SELLERMMID_OFFSET = BUYERMMID_OFFSET + _QitchConstants.MMID_LENGTH;
var RANGEINDICATOR_OFFSET = exports.RANGEINDICATOR_OFFSET = SELLERMMID_OFFSET + _QitchConstants.MMID_LENGTH;
var MATCHID_OFFSET = exports.MATCHID_OFFSET = RANGEINDICATOR_OFFSET + _QitchConstants.RANGEINDICATOR_LENGTH;
var VWAP_OFFSET = exports.VWAP_OFFSET = MATCHID_OFFSET + _QitchConstants.LONG_LENGTH;
var EXCODE_OFFSET = exports.EXCODE_OFFSET = VWAP_OFFSET + _QitchConstants.DOUBLE_LENGTH;
var DECIMALSIZE_OFFSET = exports.DECIMALSIZE_OFFSET = EXCODE_OFFSET + _QitchConstants.EXCODE_LENGTH;
var LENGTH = exports.LENGTH = DECIMALSIZE_OFFSET + _QitchConstants.DOUBLE_LENGTH;

var TradeFlags = exports.TradeFlags = function () {
    function TradeFlags() {
        _classCallCheck(this, TradeFlags);
    }

    TradeFlags.isOpen = function isOpen(bits) {
        return (bits & TradeFlags.prototype.OPEN_MASK) > 0;
    };

    TradeFlags.isHigh = function isHigh(bits) {
        return (bits & TradeFlags.prototype.HIGH_MASK) > 0;
    };

    TradeFlags.isLow = function isLow(bits) {
        return (bits & TradeFlags.prototype.LOW_MASK) > 0;
    };

    TradeFlags.isClose = function isClose(bits) {
        return (bits & TradeFlags.prototype.CLOSE_MASK) > 0;
    };

    TradeFlags.isUpdateVolume = function isUpdateVolume(bits) {
        return (bits & TradeFlags.prototype.UPDATEVOLUME_MASK) > 0;
    };

    TradeFlags.isCancel = function isCancel(bits) {
        return (bits & TradeFlags.prototype.CANCEL_MASK) > 0;
    };

    TradeFlags.isFromBook = function isFromBook(bits) {
        return (bits & TradeFlags.prototype.FROMBOOK_MASK) > 0;
    };

    TradeFlags.isATrade = function isATrade(bits) {
        return (bits & TradeFlags.prototype.ISATRADE_MASK) > 0;
    };

    TradeFlags.isIncrementVolume = function isIncrementVolume(bits) {
        return (bits & TradeFlags.prototype.INCREMENTVOLUME_MASK) > 0;
    };

    TradeFlags.isUpdateAfterHours = function isUpdateAfterHours(bits) {
        return (bits & TradeFlags.prototype.UPDATEAFTERHOURS_MASK) > 0;
    };

    TradeFlags.isUpdateLast = function isUpdateLast(bits) {
        return (bits & TradeFlags.prototype.UPDATELAST_MASK) > 0;
    };

    TradeFlags.isAfterHoursTrade = function isAfterHoursTrade(bits) {
        return (bits & TradeFlags.prototype.AFTERHOURSTRADE) > 0;
    };

    TradeFlags.isIgnoreHighLow = function isIgnoreHighLow(bits) {
        return (bits & TradeFlags.prototype.IGNOREHIGHLOW_MASK) > 0;
    };

    TradeFlags.isParticipantOnly = function isParticipantOnly(bits) {
        return (bits & TradeFlags.prototype.PARTICIPANTONLY_MAKS) > 0;
    };

    TradeFlags.isBlockTrade = function isBlockTrade(bits) {
        return (bits & TradeFlags.prototype.BLOCKTRADE_MASK) > 0;
    };

    TradeFlags.isIgnoreOpen = function isIgnoreOpen(bits) {
        return (bits & TradeFlags.prototype.IGNOREOPEN_MASK) > 0;
    };

    TradeFlags.isTradeThroughExempt = function isTradeThroughExempt(bits) {
        return (bits & TradeFlags.prototype.TRADETHROUGHEXEMPT) > 0;
    };

    TradeFlags.isCorrection = function isCorrection(bits) {
        return bits & TradeFlags.prototype.CORRECTION_MASK;
    };

    TradeFlags.isOutOfSequence = function isOutOfSequence(bits) {
        return bits & TradeFlags.prototype.OUTOFSEQUENCE_MASK;
    };

    return TradeFlags;
}();

TradeFlags.prototype.OPEN_MASK = 0x00100000;
TradeFlags.prototype.HIGH_MASK = 0x00200000;
TradeFlags.prototype.LOW_MASK = 0x00400000;
TradeFlags.prototype.CLOSE_MASK = 0x00800000;
TradeFlags.prototype.UPDATEVOLUME_MASK = 0x01000000;
TradeFlags.prototype.CANCEL_MASK = 0x02000000;
TradeFlags.prototype.FROMBOOK_MASK = 0x04000000;
TradeFlags.prototype.ISATRADE_MASK = 0x00010000;
TradeFlags.prototype.INCREMENTVOLUME_MASK = 0x00020000;
TradeFlags.prototype.UPDATEAFTERHOURS_MASK = 0x00040000;
TradeFlags.prototype.UPDATELAST_MASK = 0x00080000;
TradeFlags.prototype.AFTERHOURSTRADE = 0x00001000;
TradeFlags.prototype.IGNOREHIGHLOW_MASK = 0x00002000;
TradeFlags.prototype.PARTICIPANTONLY_MAKS = 0x00004000;
TradeFlags.prototype.BLOCKTRADE_MASK = 0x00008000;
TradeFlags.prototype.IGNOREOPEN_MASK = 0x00000100;
TradeFlags.prototype.TRADETHROUGHEXEMPT = 0x00000200;
TradeFlags.prototype.CORRECTION_MASK = 0x08000000;
TradeFlags.prototype.OUTOFSEQUENCE_MASK = 0x00000400;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/qitch/marketDataDefinition/TradeDef.js","/lib/qitch/marketDataDefinition")
},{"../QitchConstants":26,"_process":131,"buffer":121,"timers":152}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SMessageDecoder_ = require("./v1/SMessageDecoder_1.js");

var _SMessageDecoder_2 = _interopRequireDefault(_SMessageDecoder_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SMessageDecoder = function () {
    function SMessageDecoder() {
        _classCallCheck(this, SMessageDecoder);

        this._1 = new _SMessageDecoder_2["default"]();
    }

    /**
     * Decodes a string into a message.
     * @param str {string} the string to decode
     * @return {exports.SMessage} the decoded message
     * @throws Throws an error if string representation cannot be decoded
     */


    SMessageDecoder.prototype.decode = function decode(str) {
        if (str == null) {
            throw "Argument cannot be null.";
        } else if (str.length == 0) {
            throw "Argument cannot be empty string.";
        }

        var type = str.charAt(0);
        var decoder = this['_' + type];
        if (decoder != null) {
            return decoder.decode(str);
        } else {
            throw "Unsupported message type '" + type + "'.";
        }
    };

    return SMessageDecoder;
}();

exports["default"] = SMessageDecoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/serialization/SMessageDecoder.js","/lib/serialization")
},{"./v1/SMessageDecoder_1.js":101,"_process":131,"buffer":121,"timers":152}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SMessageEncoder_ = require("./v1/SMessageEncoder_1.js");

var _SMessageEncoder_2 = _interopRequireDefault(_SMessageEncoder_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SMessageEncoder = function () {
    function SMessageEncoder() {
        _classCallCheck(this, SMessageEncoder);

        this._1 = new _SMessageEncoder_2["default"]();
    }

    /**
     * Encodes a message into its string representation.
     * @param msg {exports.SMessage} the message to encode
     * @return {string} the encoded string
     * @throws Throws an error if message cannot be encoded
     */


    SMessageEncoder.prototype.encode = function encode(msg) {
        if (msg == null) {
            throw "Argument cannot be null.";
        }

        var encoder = this['_' + msg.type];
        if (encoder != null) {
            return encoder.encode(msg);
        } else {
            throw "Unsupported message type '" + msg.type + "'.";
        }
    };

    return SMessageEncoder;
}();

exports["default"] = SMessageEncoder;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/serialization/SMessageEncoder.js","/lib/serialization")
},{"./v1/SMessageEncoder_1.js":102,"_process":131,"buffer":121,"timers":152}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _SMessage = require("../../SMessage.js");

var _SMessage2 = _interopRequireDefault(_SMessage);

var _codec = require("./codec.js");

var _codec2 = _interopRequireDefault(_codec);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SMessageDecoder_1 = function () {
    function SMessageDecoder_1() {
        _classCallCheck(this, SMessageDecoder_1);
    }

    /**
     * Decodes a type 1 string into a message.
     * @param str {string} the string to decode
     * @return {exports.SMessage} the decoded message
     */
    SMessageDecoder_1.prototype.decode = function decode(str) {
        if (str == null) {
            throw "Argument cannot be null.";
        } else if (str.length == 0) {
            throw "Argument cannot be empty string.";
        }

        var _msg = new _SMessage2["default"]();
        _msg.type = _codec2["default"].TYPE;
        var _headerlength = Number(str.substr(_codec2["default"].HEADERLENGTH_OFFSET, _codec2["default"].USHORT_LENGTH_CHAR));
        _msg.sequencenumber = Number(str.substr(_codec2["default"].SEQUENCENUMBER_OFFSET, _codec2["default"].LONG_LENGTH_CHAR));
        _msg.timestamp = Number(str.substr(_codec2["default"].TIMESTAMP_OFFSET, _codec2["default"].LONG_LENGTH_CHAR));
        _msg.id = Number(str.substr(_codec2["default"].ID_OFFSET, _codec2["default"].USHORT_LENGTH_CHAR));
        _msg.encoding = str.charAt(_codec2["default"].ENCODING_OFFSET);
        _msg.mimetype = str.charAt(_codec2["default"].MIMETYPE_OFFSET);
        var _payloadlength = Number(str.substr(_codec2["default"].PAYLOADLENGTH_OFFSET, _codec2["default"].UINT_LENGTH_CHAR));
        _msg.payload = str.substr(_headerlength, _payloadlength);

        return _msg;
    };

    return SMessageDecoder_1;
}();

exports["default"] = SMessageDecoder_1;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/serialization/v1/SMessageDecoder_1.js","/lib/serialization/v1")
},{"../../SMessage.js":5,"./codec.js":103,"_process":131,"buffer":121,"timers":152}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _message = require("../../message.js");

var _codec = require("./codec.js");

var _codec2 = _interopRequireDefault(_codec);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SMessageEncoder_1 = function () {
    function SMessageEncoder_1() {
        _classCallCheck(this, SMessageEncoder_1);
    }

    /**
     * Encodes a message into its type 1 string representation.
     * @param msg {exports.SMessage} the message to encode
     * @return {string} the type 1 string representation
     */
    SMessageEncoder_1.prototype.encode = function encode(msg) {
        if (msg == null) {
            throw "Argument cannot be null.";
        }

        var _str = _codec2["default"].TYPE;
        _str += (0, _message.lpad)(_codec2["default"].HEADER_LENGTH_CHAR, _codec2["default"].USHORT_LENGTH_CHAR);
        _str += (0, _message.lpad)(msg.sequencenumber, _codec2["default"].LONG_LENGTH_CHAR);
        _str += (0, _message.lpad)(msg.timestamp, _codec2["default"].LONG_LENGTH_CHAR);
        _str += (0, _message.lpad)(msg.id, _codec2["default"].USHORT_LENGTH_CHAR);
        _str += msg.encoding;
        _str += msg.mimetype;
        _str += (0, _message.lpad)(msg.payload != null ? msg.payload.length : 0, _codec2["default"].UINT_LENGTH_CHAR);
        if (msg.payload != null) {
            _str += msg.payload;
        }
        return _str;
    };

    return SMessageEncoder_1;
}();

exports["default"] = SMessageEncoder_1;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/serialization/v1/SMessageEncoder_1.js","/lib/serialization/v1")
},{"../../message.js":17,"./codec.js":103,"_process":131,"buffer":121,"timers":152}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
/**
 * Message codec constants.
 * @enum
 */
exports["default"] = new function () {
    this.TYPE = "1";

    /**
     * Unsigned short field length in characters.
     */
    this.USHORT_LENGTH_CHAR = 5;
    this.USHORT_MIN = 0;
    this.USHORT_MAX = 65535; // 2^16-1

    /**
     * Unsigned int field length in characters.
     */
    this.UINT_LENGTH_CHAR = 10;
    this.UINT_MIN = 0;
    this.UINT_MAX = 4294967295; // 2^32-1

    /**
     * Long field length in characters.
     * Limited to java long.
     */
    this.LONG_LENGTH_CHAR = 20;
    this.LONG_MIN = Number.MIN_SAFE_INTEGER;
    this.LONG_MAX = Number.MAX_SAFE_INTEGER;

    this.TYPE_OFFSET = 0;
    this.HEADERLENGTH_OFFSET = this.TYPE_OFFSET + 1;
    this.SEQUENCENUMBER_OFFSET = this.HEADERLENGTH_OFFSET + this.USHORT_LENGTH_CHAR;
    this.TIMESTAMP_OFFSET = this.SEQUENCENUMBER_OFFSET + this.LONG_LENGTH_CHAR;
    this.ID_OFFSET = this.TIMESTAMP_OFFSET + this.LONG_LENGTH_CHAR;
    this.ENCODING_OFFSET = this.ID_OFFSET + this.USHORT_LENGTH_CHAR;
    this.MIMETYPE_OFFSET = this.ENCODING_OFFSET + 1;
    this.PAYLOADLENGTH_OFFSET = this.MIMETYPE_OFFSET + 1;
    this.HEADER_LENGTH_CHAR = this.PAYLOADLENGTH_OFFSET + this.UINT_LENGTH_CHAR;
}();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/serialization/v1/codec.js","/lib/serialization/v1")
},{"_process":131,"buffer":121,"timers":152}],104:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */

(function () {
  var Byte,
      Client,
      Frame,
      Stomp,
      __hasProp = {}.hasOwnProperty,
      __slice = [].slice;

  Byte = {
    LF: '\x0A',
    NULL: '\x00'
  };

  Frame = function () {
    var unmarshallSingle;

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : '';
    }

    Frame.prototype.toString = function () {
      var lines, name, skipContentLength, value, _ref;
      lines = [this.command];
      skipContentLength = this.headers['content-length'] === false ? true : false;
      if (skipContentLength) {
        delete this.headers['content-length'];
      }
      _ref = this.headers;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        lines.push("" + name + ":" + value);
      }
      if (this.body && !skipContentLength) {
        lines.push("content-length:" + Frame.sizeOfUTF8(this.body));
      }
      lines.push(Byte.LF + this.body);
      return lines.join(Byte.LF);
    };

    Frame.sizeOfUTF8 = function (s) {
      if (s) {
        return encodeURI(s).match(/%..|./g).length;
      } else {
        return 0;
      }
    };

    unmarshallSingle = function unmarshallSingle(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;
      divider = data.search(RegExp("" + Byte.LF + Byte.LF));
      headerLines = data.substring(0, divider).split(Byte.LF);
      command = headerLines.shift();
      headers = {};
      trim = function trim(str) {
        return str.replace(/^\s+|\s+$/g, '');
      };
      _ref = headerLines.reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        idx = line.indexOf(':');
        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
      }
      body = '';
      start = divider + 2;
      if (headers['content-length']) {
        len = parseInt(headers['content-length']);
        body = ('' + data).substring(start, start + len);
      } else {
        chr = null;
        for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
          chr = data.charAt(i);
          if (chr === Byte.NULL) {
            break;
          }
          body += chr;
        }
      }
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function (datas) {
      var data;
      return function () {
        var _i, _len, _ref, _results;
        _ref = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          if ((data != null ? data.length : void 0) > 0) {
            _results.push(unmarshallSingle(data));
          }
        }
        return _results;
      }();
    };

    Frame.marshall = function (command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + Byte.NULL;
    };

    return Frame;
  }();

  Client = function () {
    var now;

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = "arraybuffer";
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.maxWebSocketFrameSize = 16 * 1024;
      this.subscriptions = {};
    }

    Client.prototype.debug = function (message) {
      var _ref;
      return typeof window !== "undefined" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;
    };

    now = function now() {
      if (Date.now) {
        return Date.now();
      } else {
        return new Date().valueOf;
      }
    };

    Client.prototype._transmit = function (command, headers, body) {
      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === "function") {
        this.debug(">>> " + out);
      }
      while (true) {
        if (out.length > this.maxWebSocketFrameSize) {
          this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
          out = out.substring(this.maxWebSocketFrameSize);
          if (typeof this.debug === "function") {
            this.debug("remaining = " + out.length);
          }
        } else {
          return this.ws.send(out);
        }
      }
    };

    Client.prototype._setupHeartbeat = function (headers) {
      var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1;
      if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
        return;
      }
      _ref1 = function () {
        var _i, _len, _ref1, _results;
        _ref1 = headers['heart-beat'].split(",");
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(parseInt(v));
        }
        return _results;
      }(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
        if (typeof this.debug === "function") {
          this.debug("send PING every " + ttl + "ms");
        }
        this.pinger = Stomp.setInterval(ttl, function (_this) {
          return function () {
            _this.ws.send(Byte.LF);
            return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
          };
        }(this));
      }
      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
        if (typeof this.debug === "function") {
          this.debug("check PONG every " + ttl + "ms");
        }
        return this.ponger = Stomp.setInterval(ttl, function (_this) {
          return function () {
            var delta;
            delta = now() - _this.serverActivity;
            if (delta > ttl * 2) {
              if (typeof _this.debug === "function") {
                _this.debug("did not receive server activity for the last " + delta + "ms");
              }
              return _this.ws.close();
            }
          };
        }(this));
      }
    };

    Client.prototype._parseConnect = function () {
      var args, connectCallback, errorCallback, headers;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      headers = {};
      switch (args.length) {
        case 2:
          headers = args[0], connectCallback = args[1];
          break;
        case 3:
          if (args[1] instanceof Function) {
            headers = args[0], connectCallback = args[1], errorCallback = args[2];
          } else {
            headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
          }
          break;
        case 4:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
          break;
        default:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
      }
      return [headers, connectCallback, errorCallback];
    };

    Client.prototype.connect = function () {
      var args, errorCallback, headers, out;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      out = this._parseConnect.apply(this, args);
      headers = out[0], this.connectCallback = out[1], errorCallback = out[2];
      if (typeof this.debug === "function") {
        this.debug("Opening Web Socket...");
      }
      this.ws.onmessage = function (_this) {
        return function (evt) {
          var arr, c, client, data, frame, messageID, onreceive, subscription, _i, _len, _ref, _results;
          data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, function () {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = arr.length; _i < _len; _i++) {
              c = arr[_i];
              _results.push(String.fromCharCode(c));
            }
            return _results;
          }().join('')) : evt.data;
          _this.serverActivity = now();
          if (data === Byte.LF) {
            if (typeof _this.debug === "function") {
              _this.debug("<<< PONG");
            }
            return;
          }
          if (typeof _this.debug === "function") {
            _this.debug("<<< " + data);
          }
          _ref = Frame.unmarshall(data);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            frame = _ref[_i];
            switch (frame.command) {
              case "CONNECTED":
                if (typeof _this.debug === "function") {
                  _this.debug("connected to server " + frame.headers.server);
                }
                _this.connected = true;
                _this._setupHeartbeat(frame.headers);
                _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
                break;
              case "MESSAGE":
                subscription = frame.headers.subscription;
                onreceive = _this.subscriptions[subscription] || _this.onreceive;
                if (onreceive) {
                  client = _this;
                  messageID = frame.headers["message-id"];
                  frame.ack = function (headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.ack(messageID, subscription, headers);
                  };
                  frame.nack = function (headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.nack(messageID, subscription, headers);
                  };
                  _results.push(onreceive(frame));
                } else {
                  _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled received MESSAGE: " + frame) : void 0);
                }
                break;
              case "RECEIPT":
                _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
                break;
              case "ERROR":
                _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
                break;
              default:
                _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
            }
          }
          return _results;
        };
      }(this);
      this.ws.onclose = function (_this) {
        return function () {
          var msg;
          msg = "Whoops! Lost connection to " + _this.ws.url;
          if (typeof _this.debug === "function") {
            _this.debug(msg);
          }
          _this._cleanUp();
          return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
        };
      }(this);
      return this.ws.onopen = function (_this) {
        return function () {
          if (typeof _this.debug === "function") {
            _this.debug('Web Socket Opened...');
          }
          headers["accept-version"] = Stomp.VERSIONS.supportedVersions();
          headers["heart-beat"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');
          return _this._transmit("CONNECT", headers);
        };
      }(this);
    };

    Client.prototype.disconnect = function (disconnectCallback, headers) {
      if (headers == null) {
        headers = {};
      }
      this._transmit("DISCONNECT", headers);
      this.ws.onclose = null;
      this.ws.close();
      this._cleanUp();
      return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
    };

    Client.prototype._cleanUp = function () {
      this.connected = false;
      if (this.pinger) {
        Stomp.clearInterval(this.pinger);
      }
      if (this.ponger) {
        return Stomp.clearInterval(this.ponger);
      }
    };

    Client.prototype.send = function (destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = '';
      }
      headers.destination = destination;
      return this._transmit("SEND", headers, body);
    };

    Client.prototype.subscribe = function (destination, callback, headers) {
      var client;
      if (headers == null) {
        headers = {};
      }
      if (!headers.id) {
        headers.id = "sub-" + this.counter++;
      }
      headers.destination = destination;
      this.subscriptions[headers.id] = callback;
      this._transmit("SUBSCRIBE", headers);
      client = this;
      return {
        id: headers.id,
        unsubscribe: function unsubscribe() {
          return client.unsubscribe(headers.id);
        }
      };
    };

    Client.prototype.unsubscribe = function (id) {
      delete this.subscriptions[id];
      return this._transmit("UNSUBSCRIBE", {
        id: id
      });
    };

    Client.prototype.begin = function (transaction) {
      var client, txid;
      txid = transaction || "tx-" + this.counter++;
      this._transmit("BEGIN", {
        transaction: txid
      });
      client = this;
      return {
        id: txid,
        commit: function commit() {
          return client.commit(txid);
        },
        abort: function abort() {
          return client.abort(txid);
        }
      };
    };

    Client.prototype.commit = function (transaction) {
      return this._transmit("COMMIT", {
        transaction: transaction
      });
    };

    Client.prototype.abort = function (transaction) {
      return this._transmit("ABORT", {
        transaction: transaction
      });
    };

    Client.prototype.ack = function (messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("ACK", headers);
    };

    Client.prototype.nack = function (messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("NACK", headers);
    };

    return Client;
  }();

  Stomp = {
    VERSIONS: {
      V1_0: '1.0',
      V1_1: '1.1',
      V1_2: '1.2',
      supportedVersions: function supportedVersions() {
        return '1.1,1.0';
      }
    },
    client: function client(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = ['v10.stomp', 'v11.stomp'];
      }
      klass = Stomp.WebSocketClass || WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function over(ws) {
      return new Client(ws);
    },
    Frame: Frame
  };

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Stomp = Stomp;
  }

  if (typeof window !== "undefined" && window !== null) {
    Stomp.setInterval = function (interval, f) {
      return window.setInterval(f, interval);
    };
    Stomp.clearInterval = function (id) {
      return window.clearInterval(id);
    };
    window.Stomp = Stomp;
  } else if (!exports) {
    self.Stomp = Stomp;
  }
}).call(undefined);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/stomp.js/lib/stomp.js","/lib/stomp.js/lib")
},{"_process":131,"buffer":121,"timers":152}],105:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _logging = require("../logging.js");

var _EventSupport = require("../EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

var _streamerEvents = require("../streamer-events.js");

var events = _interopRequireWildcard(_streamerEvents);

var _http = require("../http.js");

var _http2 = _interopRequireDefault(_http);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StompConnection = function () {
    function StompConnection(createTransmitter, openSocket, log) {
        var maxReconnectAttempts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;
        var pingUrl = arguments[4];

        _classCallCheck(this, StompConnection);

        this.openSocket = openSocket;
        this.createTransmitter = createTransmitter;
        this.log = (0, _logging.asLogger)(log);
        this.events = new _EventSupport2["default"](this);
        this.currentConn = '';
        //Max number of times that the client will try to reopen per loop
        this.maxReconnectAttempts = maxReconnectAttempts;
        //Max number of times client will be able to try to reopen in total. Once this is reached, client will close and no reconnect will be attempted.
        //probably means that an unhandled loop was reached
        this.maxReconnectsTotal = 3;
        this.isFirstConnection = true;
        this.pingUrl = pingUrl;
    }

    StompConnection.prototype.open = function open() {
        var _this = this;

        var socketProxy = { // Late binding for socket
            send: function send(message) {
                return _this.socket.send(message);
            }
        };

        //Check to avoid creating unnecessary events and objects
        if (this.isFirstConnection) {
            this.on("reopen", function (e) {
                var prevConn = _this.currentConn;
                _this.currentConn = e.connectionId;
                _this.events.fire("reconnect", events.event("Reconnection success", {
                    previousConnectionId: prevConn,
                    currentConnectionId: _this.currentConn
                }));
            });

            this.transmitter = this.createTransmitter(socketProxy);
            this.transmitter.on("message", function (message) {
                _this.events.fire("message", message);
            });
        }

        this.socket = this.openSocket(function (request) {
            _this.request = request;
            _this.reconnect = false;
            return {
                onOpen: function onOpen(response) {
                    if (response.command === "CONNECTED") {
                        _this.isConnectionUp = true;
                        var e = events.event("open", {
                            connectionId: response.headers['user-name']
                        });
                        _this.log.info(e);
                        _this.events.fire("open", e);
                        if (!_this.isFirstConnection) {
                            _this.maxReconnectsTotal--;
                            _this.events.fire("reopen", e);
                        }
                        _this.currentConn = response.headers['user-name'];
                    }
                },
                onError: function onError(response) {
                    _this.isConnectionUp = false;
                    _this.isServerUp(function (err, result) {
                        if (err !== null) {
                            _this.reconnect = false;
                            _this.log.warn("Connection lost, Streamer Server isn't Up");
                        } else {
                            _this.reconnect = true;
                            _this.log.warn('Connection lost, Streamer Server is Up');
                        }
                    });
                },
                onClose: function onClose() {
                    _this.isConnectionUp = false;
                },
                onMessage: function onMessage(response) {
                    var responseBody = JSON.parse(response.body);
                    if (responseBody.code !== undefined) {
                        if (responseBody.code == 401 || responseBody.code == 403) {
                            _this.log.info("Unable to reconnect with code: " + responseBody.code + ", reason: " + responseBody.reason);
                            _this.reconnect = false;
                            _this.isConnectionUp = false;
                        }
                    }
                    _this.transmitter.onMessage(response.body);
                }
            };
        }, this.currentConn);
    };

    StompConnection.prototype.close = function close() {
        if (this.socket) {
            try {
                this.socket.close();
                this.socket = null;
                if (this.reconnect) {
                    this.tryReopen();
                }
            } catch (err) {
                this.events.fire("error", events.error("Error closing", {
                    reason: err.message,
                    cause: err,
                    code: -3
                }));
            }
        }
    };

    StompConnection.prototype.tryReopen = function tryReopen() {
        var _this2 = this;

        if (this.isConnectionUp || this.maxReconnectsTotal <= 0) {
            this.log.error("Connection is already open or max reconnects was reached, won't try to reconnect");
            return;
        }
        this.isFirstConnection = false;
        var currentAttempts = this.maxReconnectAttempts;
        var reconnect = function reconnect() {
            if (currentAttempts <= 0) {
                _this2.reconnect = false;
                _this2.log.error("Error while reconnecting. No attempts left.");
                //if maxattempts was reached and no connection was open, exit.
                _this2.maxReconnectAttempts = 0;
                return;
            }
            if (_this2.isConnectionUp || !_this2.reconnect) {
                return;
            }
            _this2.log.info("Attempting reconnect. Attempts left: " + currentAttempts);
            _this2.reopen(currentAttempts);
            currentAttempts--;

            setTimeout(reconnect, 500);
        };
        setTimeout(reconnect, 500);
    };

    StompConnection.prototype.reopen = function reopen(attempt) {
        try {
            this.open();
        } catch (exception) {
            this.log.warn("There was an error while reopening attempt #" + attempt);
            this.events.fire("error", exception);
        }
    };

    StompConnection.prototype.send = function send(message) {
        try {
            this.transmitter.send(message);
        } catch (err) {
            this.events.fire("error", events.error("Error sending message", {
                reason: err.message,
                cause: err,
                code: -4
            }));
        }
    };

    StompConnection.prototype.isReconnect = function isReconnect() {
        return this.request['x-Stream-isReconnect'];
    };

    StompConnection.prototype.setReconnect = function setReconnect(doReconnect) {
        this.reconnect = doReconnect;
    };

    StompConnection.prototype.setServer = function setServer(server) {
        this.request['X-Stream-Instance'] = server;
    };

    StompConnection.prototype.isClosed = function isClosed() {
        return this.socket == null;
    };

    StompConnection.prototype.isServerUp = function isServerUp(callback) {
        (0, _http2["default"])({
            url: this.pingUrl,
            success: function success(result) {
                return callback(null, result);
            },
            type: "GET",
            failure: callback
        });
    };

    StompConnection.prototype.setConnectionUp = function setConnectionUp(isConnectionUp) {
        this.isConnectionUp = isConnectionUp;
    };

    StompConnection.prototype.on = function on(event, callback) {
        return this.events.on(event, callback);
    };

    return StompConnection;
}();

exports["default"] = StompConnection;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/stomp/StompConnection.js","/lib/stomp")
},{"../EventSupport.js":2,"../http.js":14,"../logging.js":16,"../streamer-events.js":109,"_process":131,"buffer":121,"timers":152}],106:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

require("../polyfills.js");

var _streamerApi = require("../streamer-api.js");

var _streamerUtils = require("../streamer-utils.js");

var _logging = require("../logging.js");

var _utils = require("../utils.js");

var _UShortId = require("../UShortId.js");

var _UShortId2 = _interopRequireDefault(_UShortId);

var _EventSupport = require("../EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

var _formatting = require("../formatting.js");

var _streamerEvents = require("../streamer-events.js");

var events = _interopRequireWildcard(_streamerEvents);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CONSOLIDATED_SYMBOL_ENTITLEMENTS_COEFFICIENT = 14;
var CONSOLIDATED_SYMBOL_SUFFIX = ":CC";

var StompStream = function () {
    function StompStream(streamingService, format, log) {
        var _this = this;

        _classCallCheck(this, StompStream);

        this.events = new _EventSupport2["default"]();
        this.streamingService = streamingService;
        this.format = format;
        this.log = (0, _logging.asLogger)(log);

        this.conn = streamingService.createStompConnection();

        this.conn.on("message", function (msg) {
            _this._handlejsonmsg(msg);
        }).on("close", function (msg) {
            _this.doClose(msg);
        }).on("error", function (err) {
            if (_this.pendingConnection) {
                _this.pendingConnection(err);
            }
            _this.events.fire("error", err);
        }).on("reconnect", function (msg) {
            _this.reconnectSuccess(msg);
        });

        this.requestid = new _UShortId2["default"]();

        this.pendingsubscriptions = {};
        this.pendingUnsubscriptions = {};
        this.pendingExchangeSubscriptions = {};
        this.pendingExchangeUnsubscriptions = {};
        this.pendingNewsSubscriptions = {};
        this.pendingNewsUnsubscriptions = {};
        this.pendingAlertSubscription = {};
        this.pendingTradeSubscription = {};
        this.pendingTradeUnsubscription = {};

        this.on("error", function (err) {
            _this.log.warn(err);
        });
    }

    StompStream.prototype.openStomp = function openStomp(callback) {
        try {
            this.pendingConnection = callback;
            this.conn.open();
        } catch (err) {
            if (callback) {
                callback(err);
            }
        }
    };

    StompStream.prototype.reconnectSuccess = function reconnectSuccess(msg) {
        this.events.fire("reconnectSuccess", msg);
        this.log.info("Successfull reconnection. Previous Id: " + msg.previousConnectionId + " Current Id = " + msg.currentConnectionId);
    };

    StompStream.prototype.on = function on(event, listener) {
        return this.events.on(event, listener);
    };

    StompStream.prototype.subscribe = function subscribe(symbols, types, optsOrCallback, callbackOrNothing) {
        var _this2 = this;

        symbols = (Array.isArray(symbols) ? symbols : [symbols]).map(function (s) {
            return s.toUpperCase();
        });
        types = Array.isArray(types) ? types : [types].map(function (s) {
            return s.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var subscription = {
            ids: [],
            types: types,
            mimetype: this.format,
            callback: callback,
            result: {
                subscribed: [],
                rejected: [],
                unentitled: [],
                invalidSymbols: []
            }
        };

        if (symbols.length === 0 || types.length === 0) {
            callback(null, subscription.result);
            return;
        }

        var requests = this._prepareSubscriptionRequests(symbols, subscription, _streamerApi.messages.control.Action.SUBSCRIBE, opts);
        requests.forEach(function (request) {
            var id = _this2.requestid.next();
            subscription.ids.push(id);
            _this2.pendingsubscriptions[id] = subscription;
            request.id = id;

            _this2.send(request);
        });
    };

    StompStream.prototype.subscribeExchange = function subscribeExchange(exchanges, optsOrCallback, callbackOrNothing) {
        var _this3 = this;

        exchanges = (Array.isArray(exchanges) ? exchanges : [exchanges]).map(function (e) {
            return e.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var exchangeSub = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                subscribed: [],
                rejected: []
            }
        };
        //check for empty string
        if (exchanges.length === 0) {
            callback(null, exchangeSub.result);
        }

        var requests = this.prepareExchangeSubscriptionRequest(exchanges, exchangeSub, _streamerApi.messages.control.Action.SUBSCRIBE, opts);

        requests.forEach(function (request) {
            var id = _this3.requestid.next();
            exchangeSub.id.push(id);
            exchangeSub.exchange = request.exchange;
            exchangeSub.conflation = request.conflation;
            _this3.pendingExchangeSubscriptions[id] = exchangeSub;
            request.id = id;
            _this3.send(request);
        });
    };

    StompStream.prototype.subscribeNews = function subscribeNews(newsFilters, optsOrCallback, callbackOrNothing) {

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var newsSub = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                newsFilters: [],
                rejectedNewsFilters: [],
                unentitledNewsFilters: []
            }
        };
        //check for empty filters
        if (newsFilters.length === 0) {
            callback(null, newsSub.result);
        }
        var request = this.buildNewsSubscribeRequest(newsFilters, newsSub, _streamerApi.messages.control.Action.SUBSCRIBE, opts);

        var id = this.requestid.next();
        this.pendingNewsSubscriptions[id] = newsSub;

        request.id = id;

        this.send(request);
    };

    StompStream.prototype.subUnsubAlerts = function subUnsubAlerts(operation, optsOrCallback, callbackOrNothing) {

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }

        var subscription = {
            id: [],
            mimetype: this.format,
            callback: callback,
            result: {
                operation: ""
            }
        };

        var request = this.buildAlertsSubUnsubRequest(operation, subscription);
        var id = this.requestid.next();
        subscription.id.push(id);
        this.pendingAlertSubscription[id] = subscription;
        request.id = id;

        this.send(request);
    };

    StompStream.prototype.subscribeTrade = function subscribeTrade(notificationType, optsOrCallback, callbackOrNothing) {
        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }

        var tradeSub = {
            id: [],
            mimetype: this.format,
            callback: callback,
            result: {
                notificationType: ""
            }
        };

        var request = this.buildTradeSubscribeRequest(notificationType, tradeSub, _streamerApi.messages.control.Action.SUBSCRIBE);
        var id = this.requestid.next();
        tradeSub.id.push(id);
        this.pendingTradeSubscription[id] = tradeSub;
        request.id = id;

        this.send(request);
    };

    StompStream.prototype.getSessionStats = function getSessionStats() {
        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }
        var msg = new _streamerApi.messages.control.StatsMessage();
        this.send(msg);
    };

    StompStream.prototype.cmdFilterRefreshNews = function cmdFilterRefreshNews(callbackOrNothing) {
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var newsCmdFilterRefresh = {
            callback: callback,
            mimetype: this.format
        };

        var request = this.buildNewsCommandRequest(newsCmdFilterRefresh, 'NEWSCMDFILTERREFRESH');
        this.send(request);
    };

    StompStream.prototype.cmdFilterNews = function cmdFilterNews(callbackOrNothing) {
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var newsCmdFilter = {
            callback: callback,
            mimetype: this.format
        };

        var request = this.buildNewsCommandRequest(newsCmdFilter, 'NEWSCMDFILTER');
        this.send(request);
    };

    StompStream.prototype.unsubscribe = function unsubscribe(symbols, types, optsOrCallback, callbackOrNothing) {
        var _this4 = this;

        symbols = (Array.isArray(symbols) ? symbols : [symbols]).map(function (s) {
            return s.toUpperCase();
        });
        types = Array.isArray(types) ? types : [types].map(function (s) {
            return s.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var unsubscription = {
            ids: [],
            types: types,
            mimetype: this.format,
            callback: callback,
            result: {
                unsubscribed: []
            }
        };

        if (symbols.length === 0 || types.length === 0) {
            if (callback) {
                callback(null, unsubscription.result);
            }
        }

        var requests = this._prepareSubscriptionRequests(symbols, unsubscription, _streamerApi.messages.control.Action.UNSUBSCRIBE, opts);
        requests.forEach(function (request) {
            var id = _this4.requestid.next();
            unsubscription.ids.push(id);
            _this4.pendingUnsubscriptions[id] = unsubscription;
            request.id = id;

            _this4.send(request);
        });
    };

    StompStream.prototype.unsubscribeExchange = function unsubscribeExchange(exchanges, optsOrCallback, callbackOrNothing) {
        var _this5 = this;

        exchanges = (Array.isArray(exchanges) ? exchanges : [exchanges]).map(function (e) {
            return e.toUpperCase();
        });

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var exchangeSub = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                subscribed: [],
                rejected: []
            }
        };
        //check for empty string
        if (exchanges.length === 0) {
            callback(null, exchangeSub.result);
        }

        var requests = this.prepareExchangeSubscriptionRequest(exchanges, exchangeSub, _streamerApi.messages.control.Action.UNSUBSCRIBE, opts);

        requests.forEach(function (request) {
            var id = _this5.requestid.next();
            exchangeSub.id.push(id);
            exchangeSub.exchange = request.exchange;
            exchangeSub.conflation = request.conflation;
            _this5.pendingExchangeUnsubscriptions[id] = exchangeSub;
            request.id = id;
            _this5.send(request);
        });
    };

    StompStream.prototype.unsubscribeNews = function unsubscribeNews(newsFilters, optsOrCallback, callbackOrNothing) {
        newsFilters = Array.isArray(newsFilters) ? newsFilters : [newsFilters];

        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        var unsubscription = {
            callback: callback,
            mimetype: this.format,
            id: [],
            result: {
                unsubscribed: []
            }
        };

        if (newsFilters.length === 0) {
            if (callback) {
                callback(null, unsubscription.result);
            }
        }

        var request = this.buildNewsSubscribeRequest(newsFilters, unsubscription, _streamerApi.messages.control.Action.UNSUBSCRIBE, opts);

        var id = this.requestid.next();
        unsubscription.id.push(id);
        this.pendingNewsUnsubscriptions[id] = unsubscription;
        request.id = id;

        this.send(request);
    };

    StompStream.prototype.unsubscribeTrade = function unsubscribeTrade(notificationType, optsOrCallback, callbackOrNothing) {
        var opts = optsOrCallback && typeof optsOrCallback !== "function" ? optsOrCallback : null;
        var callback = callbackOrNothing ? callbackOrNothing : optsOrCallback && typeof optsOrCallback === "function" ? optsOrCallback : null;

        if (this.isClosed()) {
            var event = events.error("Stream is disconnected", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", event);
            return;
        }

        var tradeSub = {
            id: [],
            mimetype: this.format,
            callback: callback,
            result: {
                notificationType: ""
            }
        };

        var request = this.buildTradeSubscribeRequest(notificationType, tradeSub, _streamerApi.messages.control.Action.UNSUBSCRIBE);
        var id = this.requestid.next();
        tradeSub.id.push(id);
        this.pendingTradeUnsubscription[id] = tradeSub;
        request.id = id;

        this.send(request);
    };

    StompStream.prototype._handlejsonmsg = function _handlejsonmsg(msg) {
        if ((0, _streamerUtils.iscontrolmessage)(msg)) {
            this.handlectrlmsg(msg);
        } else if ((0, _streamerUtils.isdatamessage)(msg)) {
            this._handledatamsg(msg);
        } else {
            this.events.fire("error", msg);
        }
    };

    StompStream.prototype._prepareSubscriptionRequests = function _prepareSubscriptionRequests(symbols, subscription, action, opts) {
        var currentApproximateNumberOfEntitlements = 0;
        var lastAddedSymbolIndex = -1;
        var numberOfSymbols = symbols.length;
        var isOrderbookSubscription = subscription.types.includes("ORDERBOOK");
        var requests = [];
        for (var i = 0; i < numberOfSymbols; i++) {
            currentApproximateNumberOfEntitlements = this._getUpdatedNumberOfEntitlements(subscription.types.length, currentApproximateNumberOfEntitlements, symbols[i], isOrderbookSubscription);
            if (currentApproximateNumberOfEntitlements >= this.maxEntitlementsPerSubscription || i === numberOfSymbols - 1) {
                requests.push(this._buildRequest(symbols.slice(lastAddedSymbolIndex + 1, i + 1), subscription, action, opts));
                lastAddedSymbolIndex = i;
                currentApproximateNumberOfEntitlements = 0;
            }
        }
        return requests;
    };

    StompStream.prototype._buildRequest = function _buildRequest(symbols, sub, action, opts) {
        var msg = new _streamerApi.messages.control.SubscribeMessage();
        msg.action = action;
        msg.symbols = symbols;
        msg.types = sub.types;
        msg.mimetype = sub.mimetype;
        if (opts && opts.skipHeavyInitialLoad) {
            msg.skipHeavyInitialLoad = true;
        }
        if (opts) {
            msg.conflation = opts.conflation;
        }
        return msg;
    };

    StompStream.prototype.prepareExchangeSubscriptionRequest = function prepareExchangeSubscriptionRequest(exchanges, exchangeSub, action, opts) {
        var requests = [];
        var numberOfExchanges = exchanges.length;
        for (var i = 0; i < numberOfExchanges; i++) {
            requests.push(this.buildExchangeRequest(exchanges[i], exchangeSub, action, opts));
        }
        return requests;
    };

    StompStream.prototype.buildExchangeRequest = function buildExchangeRequest(exchange, sub, action, opts) {
        var msg = new _streamerApi.messages.control.ExchangeSubscribeMessage();
        msg.action = action;
        msg.exchange = exchange;
        msg.mimetype = sub.mimetype;
        if (opts) {
            msg.conflation = opts.conflation;
        }
        return msg;
    };

    StompStream.prototype.buildNewsSubscribeRequest = function buildNewsSubscribeRequest(newsFilters, sub, action, opts) {
        var msg = new _streamerApi.messages.control.NewsSubscribeMessage();
        msg.action = action;
        msg.newsFilters = newsFilters;
        msg.mimetype = sub.mimetype;
        if (opts && opts.skipHeavyInitialLoad) {
            msg.skipHeavyInitialLoad = opts.skipHeavyInitialLoad;
        }
        return msg;
    };

    StompStream.prototype.buildAlertsSubUnsubRequest = function buildAlertsSubUnsubRequest(opr, subscription) {
        var msg = new _streamerApi.messages.control.AlertsSubUnsubMessage();
        msg.operation = opr;
        msg.mimetype = subscription.mimetype;
        return msg;
    };

    StompStream.prototype.buildTradeSubscribeRequest = function buildTradeSubscribeRequest(notificationType, sub, action) {
        var msg = new _streamerApi.messages.control.TradeSubscribeMessage();
        msg.action = action;
        msg.notificationType = notificationType;
        msg.mimetype = sub.mimetype;
        return msg;
    };

    StompStream.prototype.buildNewsCommandRequest = function buildNewsCommandRequest(sub, newsAction) {
        var msg = new _streamerApi.messages.control.NewsCommandMessage();
        msg.newsAction = newsAction;
        msg.mimetype = sub.mimetype;
        return msg;
    };

    StompStream.prototype._getUpdatedNumberOfEntitlements = function _getUpdatedNumberOfEntitlements(numberOfSubscriptionTypes, currentApproximateNumberOfEntitlements, symbol, isSubscribeToOrderbook) {
        var result = currentApproximateNumberOfEntitlements;
        if (isSubscribeToOrderbook && symbol.endsWith(CONSOLIDATED_SYMBOL_SUFFIX)) {
            result += CONSOLIDATED_SYMBOL_ENTITLEMENTS_COEFFICIENT * numberOfSubscriptionTypes;
        } else {
            result += numberOfSubscriptionTypes;
        }
        return result;
    };

    StompStream.prototype.handlectrlmsg = function handlectrlmsg(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        var _type = (0, _streamerUtils.messagetype)(msg);
        switch (_type) {
            case _streamerApi.messages.MessageTypeNames.ctrl.HEARTBEAT:
                this.onHeartbeat(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.SUBSCRIBE_RESPONSE:
                this.onSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_RESPONSE:
                this.onExchangeSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_SUBSCRIBE_RESPONSE:
                this.onNewsSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.ALERTS_SUBUNSUB_RESPONSE:
                this.onAlertsSubUnsubResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.TRADE_SUBSCRIBE_RESPONSE:
                this.onTradeSubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.UNSUBSCRIBE_RESPONSE:
                this.onUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.EXCHANGE_UNSUBSCRIBE_RESPONSE:
                this.onExchangeUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_UNSUBSCRIBE_RESPONSE:
                this.onNewsUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_CMD_FILTER_REFRESH_RESPONSE:
                this.onNewsCmdFilterRefreshResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.NEWS_CMD_FILTER_RESPONSE:
                this.onNewsCmdFilterResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.TRADE_UNSUBSCRIBE_RESPONSE:
                this.onTradeUnsubscribeResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.CONNECT_RESPONSE:
                this.onConnectResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.CONNECTION_CLOSE:
                this.onConnectionClose(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.SLOW_CONNECTION:
                this.onSlowConnection(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.STATS_RESPONSE:
                this.onStatsResponse(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.INITIAL_DATA_SENT:
                this.onInitialDataSent(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.RESUBSCRIBE_MESSAGE:
                this.onResubscribeMessage(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.OPEN_FLOW:
                this.onOpenFlow(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.RECONNECT_RESPONSE:
                this.onReconnectMessage(msg);
                break;
            case _streamerApi.messages.MessageTypeNames.ctrl.MISSED_DATA_SENT:
                this.onMissedDataSent(msg);
                break;
        }
    };

    StompStream.prototype.onHeartbeat = function onHeartbeat(msg) {};

    StompStream.prototype.onSubscribeResponse = function onSubscribeResponse(msg) {
        var subscription = this.pendingsubscriptions[msg.__id];
        var callback = subscription.callback;

        (0, _utils.removeFromArray)(subscription.ids, msg.__id);
        delete this.pendingsubscriptions[msg.__id];

        if (msg.code != 200 && !subscription.failed) {
            subscription.failed = true;
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                subscription.callback(event);
            }
            return;
        }

        var result = subscription.result;

        if (msg.entitlements) {
            for (var _iterator = msg.entitlements, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var key = _ref;
                var _key = key,
                    symbol = _key.symbol,
                    marketdatatype = _key.marketdatatype,
                    entitlement = _key.entitlement;

                key = { symbol: symbol, type: marketdatatype };
                if (entitlement !== 'NA') {
                    this.log.debug('SUBSCRIBED <' + symbol + ', ' + marketdatatype + '>');
                    key.entitlement = entitlement;
                    result.subscribed.push(key);
                } else {
                    this.log.warn('NOT ENTITLED <' + symbol + ',' + marketdatatype + '>');
                    result.unentitled.push(key);
                }
            }
        }
        if (msg.rejectedSymbols) {
            for (var _iterator2 = msg.rejectedSymbols, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                var symbol = _ref2;

                this.log.warn('REJECTED ' + symbol);
                result.rejected.push(symbol);
            }
        }
        if (msg.invalidSymbols) {
            for (var _iterator3 = msg.invalidSymbols, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                var _result$invalidSymbol;

                var _ref3;

                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref3 = _i3.value;
                }

                var _symbol2 = _ref3;

                this.log.warn('INVALID SYMBOL ' + _symbol2);
                (_result$invalidSymbol = result.invalidSymbols).push.apply(_result$invalidSymbol, msg.invalidSymbols);
            }
        }

        if (subscription.ids.length === 0 && !subscription.failed) {
            if (callback) {
                callback(null, subscription.result);
            }
        }
    };

    StompStream.prototype.onExchangeSubscribeResponse = function onExchangeSubscribeResponse(msg) {
        var exchangeSub = this.pendingExchangeSubscriptions[msg.__id];
        var callback = exchangeSub.callback;

        (0, _utils.removeFromArray)(exchangeSub.id, msg.__id);
        delete this.pendingExchangeSubscriptions[msg.__id];

        console.log(msg);
        if (msg.code != 200) {
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                exchangeSub.callback(event);
            }
            return;
        }
        if (exchangeSub.id.length === 0) {
            if (callback) {
                callback(null, exchangeSub);
            }
        }
    };

    StompStream.prototype.onNewsSubscribeResponse = function onNewsSubscribeResponse(msg) {
        var newsSub = this.pendingNewsSubscriptions[msg.__id];
        var callback = newsSub.callback;

        (0, _utils.removeFromArray)(newsSub.id, msg.__id);
        delete this.pendingNewsSubscriptions[msg.__id];

        var result = newsSub.result;

        console.log(msg);
        if (msg.code != 200) {
            var event = events.error("Error subscribing to news", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                newsSub.callback(event);
            }
            return;
        }
        if (msg.newsFilters) {
            for (var _iterator4 = msg.newsFilters, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                var _ref4;

                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done) break;
                    _ref4 = _i4.value;
                }

                var newsFilter = _ref4;

                result.newsFilters.push(newsFilter);
            }
        }
        if (msg.rejectedNewsFilters) {
            for (var _iterator5 = msg.rejectedNewsFilters, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                var _ref5;

                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    _i5 = _iterator5.next();
                    if (_i5.done) break;
                    _ref5 = _i5.value;
                }

                var rejectedFilter = _ref5;

                result.rejectedNewsFilters.push(rejectedFilter);
            }
        }
        if (msg.unentitledNewsFilters) {
            for (var _iterator6 = msg.unentitledNewsFilters, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                var _ref6;

                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    _i6 = _iterator6.next();
                    if (_i6.done) break;
                    _ref6 = _i6.value;
                }

                var unentitledFilter = _ref6;

                result.unentitledNewsFilters.push(unentitledFilter);
            }
        }

        if (newsSub.id.length === 0) {
            if (callback) {
                callback(null, newsSub.result);
            }
        }
    };

    StompStream.prototype.onAlertsSubUnsubResponse = function onAlertsSubUnsubResponse(msg) {
        var alertsSub = this.pendingAlertSubscription[msg.__id];
        var callback = alertsSub.callback;

        (0, _utils.removeFromArray)(alertsSub.id, msg.__id);
        delete this.pendingAlertSubscription[msg.__id];

        console.log(msg);
        if (msg.code != 200 && !alertsSub.failed) {
            alertsSub.failed = true;
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                alertsSub.callback(event);
            }
            return;
        }

        var result = alertsSub.result;

        if (msg.operation) {
            this.log.debug('Alerts ' + msg.operation);
            result.operation = msg.operation;
        }

        if (alertsSub.id.length === 0) {
            if (callback) {
                callback(null, alertsSub.result);
            }
        }
    };

    StompStream.prototype.onTradeSubscribeResponse = function onTradeSubscribeResponse(msg) {
        var tradeSub = this.pendingTradeSubscription[msg.__id];
        var callback = tradeSub.callback;

        (0, _utils.removeFromArray)(tradeSub.id, msg.__id);
        delete this.pendingTradeSubscription[msg.__id];

        console.log(msg);
        if (msg.code != 200 && !tradeSub.failed) {
            tradeSub.failed = true;
            var event = events.error("Error subscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                tradeSub.callback(event);
            }
            return;
        }

        var result = tradeSub.result;

        if (msg.notificationType) {
            this.log.debug('Trade ' + msg.notificationType);
            result.notificationType = msg.notificationType;
        }

        if (tradeSub.id.length === 0) {
            if (callback) {
                callback(null, tradeSub.result);
            }
        }
    };

    StompStream.prototype.onNewsUnsubscribeResponse = function onNewsUnsubscribeResponse(msg) {
        var newsUnsub = this.pendingNewsUnsubscriptions[msg.__id];
        var callback = newsUnsub.callback;

        (0, _utils.removeFromArray)(newsUnsub.id, msg.__id);
        delete this.pendingNewsUnsubscriptions[msg.__id];

        console.log("msg", msg);
        var result = newsUnsub.result;

        if (msg.code != 200 && !newsUnsub.failed) {
            newsUnsub.failed = true;
            var event = events.error("Error unsubscribing to news", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                newsUnsub.callback(event);
            }
            return;
        }

        if (msg.newsFilters) {
            for (var _iterator7 = msg.newsFilters, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
                var _ref7;

                if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    _i7 = _iterator7.next();
                    if (_i7.done) break;
                    _ref7 = _i7.value;
                }

                var newsFilter = _ref7;

                result.unsubscribed.push(newsFilter);
            }
        }

        if (newsUnsub.id.length === 0) {
            if (callback) {
                callback(null, newsUnsub.result);
            }
        }
    };

    StompStream.prototype.onTradeUnsubscribeResponse = function onTradeUnsubscribeResponse(msg) {
        var tradeSub = this.pendingTradeUnsubscription[msg.__id];
        var callback = tradeSub.callback;

        (0, _utils.removeFromArray)(tradeSub.id, msg.__id);
        delete this.pendingTradeUnsubscription[msg.__id];

        console.log(msg);
        if (msg.code != 200 && !tradeSub.failed) {
            tradeSub.failed = true;
            var event = events.error("Error unsubscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                tradeSub.callback(event);
            }
            return;
        }

        var result = tradeSub.result;

        if (msg.notificationType) {
            this.log.debug('Trade ' + msg.notificationType);
            result.notificationType = msg.notificationType;
        }

        if (tradeSub.id.length === 0) {
            if (callback) {
                callback(null, tradeSub.result);
            }
        }
    };

    StompStream.prototype.onNewsCmdFilterRefreshResponse = function onNewsCmdFilterRefreshResponse(msg) {
        console.log("msg", msg);
        if (msg.code != 200) {
            var event = events.error("Error Refreshing News Filters", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            return;
        }

        this.events.fire("msg", msg);
    };

    StompStream.prototype.onNewsCmdFilterResponse = function onNewsCmdFilterResponse(msg) {
        console.log("msg", msg);
        if (msg.code != 200) {
            var event = events.error("Error Getting News Filters Status", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            return;
        }

        this.events.fire("filter status", msg);
    };

    StompStream.prototype.onUnsubscribeResponse = function onUnsubscribeResponse(msg) {
        var unsubscription = this.pendingUnsubscriptions[msg.__id];
        var callback = unsubscription.callback;

        (0, _utils.removeFromArray)(unsubscription.ids, msg.__id);
        delete this.pendingUnsubscriptions[msg.__id];

        if (msg.code != 200 && !unsubscription.failed) {
            unsubscription.failed = true;
            var event = events.error("Error unsubscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                callback(event);
            }
            return;
        }

        for (var index = 0; index < msg.unsubscribed.length; ++index) {
            var result = unsubscription.result;

            var unsubscribe = msg.unsubscribed[index];
            var _symbol = unsubscribe.symbol;
            var _datatype = unsubscribe.marketdatatype;
            this.log.debug('UNSUBSCRIBED <' + _symbol + ', ' + _datatype + '>');
            result.unsubscribed.push({ symbol: _symbol, type: _datatype });
        }

        if (unsubscription.ids.length === 0 && !unsubscription.failed) {
            if (callback) {
                callback(null, unsubscription.result);
            }
        }
    };

    StompStream.prototype.onExchangeUnsubscribeResponse = function onExchangeUnsubscribeResponse(msg) {
        var exchangeSub = this.pendingExchangeUnsubscriptions[msg.__id];
        var callback = exchangeSub.callback;

        (0, _utils.removeFromArray)(exchangeSub.id, msg.__id);
        delete this.pendingExchangeUnsubscriptions[msg.__id];

        console.log(msg);
        if (msg.code != 200) {
            var event = events.error("Error unsubscribing", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (callback) {
                exchangeSub.callback(event);
            }
            return;
        }
        if (exchangeSub.id.length === 0) {
            if (callback) {
                callback(null, exchangeSub);
            }
        }
    };

    StompStream.prototype.onReconnectMessage = function onReconnectMessage(msg) {
        if (msg.code === 450) {
            this.events.fire("slow", "Reconnection recieved a slow code: " + msg.code);
            this._isSlowConnection = true;
            this.conn.setReconnect = false;
        }
        this.events.fire("reconnectMessage", msg);
        console.log(msg);
    };

    StompStream.prototype.onConnectResponse = function onConnectResponse(msg) {
        if (msg.code !== 200) {
            var event = events.error("Connection failed", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            if (this.pendingConnection) {
                this.pendingConnection(event);
            }
            this.doClose(event);
            return;
        }

        this._serverversion = msg.version;
        this.maxEntitlementsPerSubscription = msg.maxEntitlementsPerSubscription;
        if (this.isClosed()) {
            var _event = events.error("Connection was already closed", {
                code: -1,
                reason: "Already disconnected"
            });
            this.events.fire("error", _event);
            if (this.pendingConnection) {
                this.pendingConnection(_event);
            }
            return;
        }
        this.conn.setServer(msg.serverInstance);
        if (this.pendingConnection) {
            this.pendingConnection(null, this);
        }
    };

    StompStream.prototype.onConnectionClose = function onConnectionClose(msg) {
        this.doClose(events.close({
            reason: msg.reason,
            code: msg.code
        }));
    };

    StompStream.prototype.onSlowConnection = function onSlowConnection(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("slow", msg);
    };

    StompStream.prototype.onStatsResponse = function onStatsResponse(msg) {
        if (msg.code != 200) {
            var event = events.error("Error getting stats", {
                code: msg.code,
                reason: msg.reason
            });
            this.events.fire("error", event);
            return;
        }
        ;
        this.events.fire("stats", msg);
    };

    StompStream.prototype.onInitialDataSent = function onInitialDataSent(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("initialDataSent", msg);
    };

    StompStream.prototype.onResubscribeMessage = function onResubscribeMessage(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("resubscribeMessage", msg);
    };

    StompStream.prototype.onMissedDataSent = function onMissedDataSent(msg) {
        this.log.debug(_formatting.msgfmt.fmt(msg));
        this.events.fire("missedDataSent", msg);
    };

    StompStream.prototype.onOpenFlow = function onOpenFlow(msg) {
        this.conn.send(msg);
    };

    StompStream.prototype._handledatamsg = function _handledatamsg(msg) {
        this.events.fire("message", msg);
    };

    StompStream.prototype.send = function send(msg) {
        if (this.conn) {
            this.conn.send(msg);
        }
    };

    StompStream.prototype.doClose = function doClose(msg) {
        if (!this.isClosed()) {
            var conn = this.conn;
            this.conn = null;
            conn.close();
            this.events.fire("close", msg);
            if (conn.isReconnect()) {
                //Will need to reset the events since they duplicate each time it reconnects.
                this.events = new _EventSupport2["default"]();
                this.conn = conn;
            }
        }
    };

    StompStream.prototype.performReconnect = function performReconnect(callback) {
        if (this.conn != null && this.conn.isReconnect()) {
            if (this.conn.isConnectionUp) {
                this.log.warn("Connection is not closed and won't try reconnect.");
                return;
            }
            this.conn.setReconnect(true);
            this.conn.tryReopen();
            if (callback) {
                callback();
            }
        } else {
            this.log.warn("Reconnect flag is set to false");
        }
    };

    StompStream.prototype.close = function close(callback) {
        this.doClose(events.close({
            reason: "Manually closed",
            code: 200
        }));
        if (callback) {
            callback();
        }
    };

    StompStream.prototype.isClosed = function isClosed() {
        return this.conn == null;
    };

    return StompStream;
}();

exports["default"] = StompStream;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/stomp/StompStream.js","/lib/stomp")
},{"../EventSupport.js":2,"../UShortId.js":9,"../formatting.js":13,"../logging.js":16,"../polyfills.js":18,"../streamer-api.js":108,"../streamer-events.js":109,"../streamer-utils.js":110,"../utils.js":115,"_process":131,"buffer":121,"timers":152}],107:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

require("../polyfills.js");

var _logging = require("../logging.js");

var _streamerApi = require("../streamer-api.js");

var _message = require("../message.js");

var _JsonStompTransmitter = require("../transmission/JsonStompTransmitter.js");

var _JsonStompTransmitter2 = _interopRequireDefault(_JsonStompTransmitter);

var _StompConnection = require("./StompConnection.js");

var _StompConnection2 = _interopRequireDefault(_StompConnection);

var _StompStream = require("./StompStream.js");

var _StompStream2 = _interopRequireDefault(_StompStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var STREAMURLS = {
    "ping": "/ping/v1",
    "version": "/version/v1",
    "streamStomp": "/stream/connect"
};

var HEADERPARAMS = '';

var StompStreamingService = function () {
    function StompStreamingService(http, stompJs, log, config) {
        var _this = this;

        _classCallCheck(this, StompStreamingService);

        this.http = http;
        this.stompJs = stompJs;
        this.log = (0, _logging.asLogger)(log);
        this.config = config || {};
        this.maxReconnectAttempts = this.config.maxReconnectAttempts;

        this.format = this.config.format;
        if (this.config.format === 'application/json') {
            this.createTransmitter = function (socket) {
                return new _JsonStompTransmitter2["default"](socket, _this.log);
            };
        }
    }

    StompStreamingService.prototype.openStompSocket = function openStompSocket(handlers, connectionId) {
        HEADERPARAMS = '';
        var headers = {
            'X-Stream-Version': _streamerApi.VERSION,
            'X-Stream-Lib': _streamerApi.LIBRARY_NAME
        };
        this.addToHeaderParams('X-Stream-Version', _streamerApi.VERSION);
        this.addToHeaderParams('X-Stream-Lib', _streamerApi.LIBRARY_NAME);

        var _conflation = this.config.conflation;
        if (_conflation != null && _conflation !== '') {
            headers['X-Stream-Conflation'] = _conflation;
            this.addToHeaderParams('X-Stream-Conflation', _conflation);
        }

        if (connectionId != null && connectionId !== '') {
            headers['X-Stream-Previous-Connection-Id'] = connectionId;
            this.addToHeaderParams('X-Stream-Previous-Connection-Id', connectionId);
        }

        var _rejectExcessiveConnection = this.config.rejectExcessiveConnection;
        if (_rejectExcessiveConnection != null && _rejectExcessiveConnection !== '') {
            headers['X-Stream-Reject'] = _rejectExcessiveConnection;
            this.addToHeaderParams('X-Stream-Reject', _rejectExcessiveConnection);
        }

        if (this.config.format === 'application/json' || this.config.format === _message.MimeTypes.QITCH) {
            headers['X-Stream-Format'] = this.format;
            this.addToHeaderParams('X-Stream-Format', this.format);
        }

        if (this.config.updatesOnly === 'true') {
            headers['X-Stream-UpdatesOnly'] = true;
            this.addToHeaderParams('X-Stream-UpdatesOnly', true);
        }

        var _isReconnect = this.config.isReconnect;
        if (_isReconnect != null && _isReconnect !== '') {
            headers['x-Stream-isReconnect'] = _isReconnect;
            this.addToHeaderParams('x-Stream-isReconnect', _isReconnect);
        }

        var _alwaysReconnect = this.config.alwaysReconnect;
        if (_alwaysReconnect != null && _alwaysReconnect !== '') {
            headers['x-Stream-isAlwaysReopen'] = _alwaysReconnect;
            this.addToHeaderParams('x-Stream-isAlwaysReopen', _alwaysReconnect);
        }

        if (this.config.isMissedData === 'ALL') {
            headers['X-Stream-isReceiveAllMissedData'] = true;
            this.addToHeaderParams('X-Stream-isReceiveAllMissedData', true);
        } else if (this.config.isMissedData === 'LATEST') {
            headers['X-Stream-isReceiveLatestMissedData'] = true;
            this.addToHeaderParams('X-Stream-isReceiveLatestMissedData', true);
        }

        var _stompWmid = this.config.stompWmid;
        if (_stompWmid != null) {
            headers['wmid'] = _stompWmid;
            this.addToHeaderParams('wmid', _stompWmid);
        }

        Object.assign(headers, this.config.credentials.getHeaders());

        var url = this.config.url + STREAMURLS.streamStomp + HEADERPARAMS;
        var stompClient = this.stompJs.Stomp.client(url);

        var authMessage = new _streamerApi.messages.control.AuthenticationMessage();
        if (this.config.credentials.sid !== undefined) {
            authMessage.authenticationMethod = "sid";
            authMessage.authorization = this.config.credentials.sid;
        } else if (this.config.credentials.wmid !== undefined && this.config.credentials.token !== undefined) {
            authMessage.authenticationMethod = "enterprise";
            authMessage.wmid = this.config.credentials.wmid;
            authMessage.authorization = this.config.credentials.token;
        } else if (this.config.credentials.wmid !== undefined) {
            authMessage.authenticationMethod = "wmid";
            authMessage.authorization = this.config.credentials.wmid;
        } else if (this.config.credentials.data_token !== undefined) {
            authMessage.authenticationMethod = "datatool";
            authMessage.authorization = this.config.credentials.data_token;
        }

        if (this.config.conflation != null && this.config.conflation !== "") {
            authMessage.conflation = this.config.conflation;
        }

        if (this.config.rejectExcessiveConnection != null && this.config.rejectExcessiveConnection !== "") {
            authMessage.rejectExcessiveConnection = this.config.rejectExcessiveConnection;
        }

        stompClient.connect(headers, function (frame) {
            stompClient.subscribe('/user/queue/messages', function (responseMessage) {
                handlers(headers).onMessage(responseMessage);
            });

            handlers(headers).onOpen(frame);
            stompClient.send("/stream/message", headers, JSON.stringify(authMessage));
        }, function (frame) {
            handlers(headers).onError(frame);
        });

        return {
            send: function send(msg) {
                stompClient.send("/stream/message", headers, msg);
            },
            close: function close() {
                stompClient.disconnect(function () {
                    handlers(headers).onClose();
                });
            }
        };
    };

    StompStreamingService.prototype.createStompConnection = function createStompConnection() {
        var _this2 = this;

        return new _StompConnection2["default"](function (socket) {
            return _this2.createTransmitter(socket);
        }, function (handlers, connectionId) {
            return _this2.openStompSocket(handlers, connectionId);
        }, this.log, this.maxReconnectAttempts, this.config.host + STREAMURLS.ping);
    };

    StompStreamingService.prototype.openStompStream = function openStompStream(callback) {
        var stompStream = new _StompStream2["default"](this, this.format, this.log);
        stompStream.openStomp(callback);
    };

    StompStreamingService.prototype.ping = function ping(callback) {
        this.http({
            url: this.config.host + STREAMURLS.ping,
            success: function success(result) {
                return callback(null, result);
            },
            type: "GET",
            failure: callback
        });
    };

    StompStreamingService.prototype.getVersion = function getVersion(callback) {
        this.http({
            url: this.config.host + STREAMURLS.version,
            success: function success(result) {
                return callback(null, result);
            },
            type: "GET",
            failure: callback
        });
    };

    StompStreamingService.prototype.addToHeaderParams = function addToHeaderParams(header, val) {
        if (HEADERPARAMS === '') {
            HEADERPARAMS = HEADERPARAMS + '?' + header + '=' + val;
        } else {
            HEADERPARAMS = HEADERPARAMS + '&' + header + '=' + val;
        }
    };

    return StompStreamingService;
}();

exports["default"] = StompStreamingService;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/stomp/StompStreamingService.js","/lib/stomp")
},{"../logging.js":16,"../message.js":17,"../polyfills.js":18,"../streamer-api.js":108,"../transmission/JsonStompTransmitter.js":111,"./StompConnection.js":105,"./StompStream.js":106,"_process":131,"buffer":121,"timers":152}],108:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
/* @see http://usejsdoc.org */

/**
 * Streamer api namespace.
 * @namespace
 */

var LIBRARY_NAME = exports.LIBRARY_NAME = "JavaScript";
var VERSION = exports.VERSION = "2.38.0";

/**
 * Streamer message api namespace.
 * @namespace
 */
var messages = exports.messages = {};

/**
 * Streamer control message namespace. * @namespace
 */
messages.control = {};

/**
 * Streamer market data message namespace.
 * @namespace
 */
messages.market = {};

/* ****************************************************************************************************************** */

/**
 *
 * @type {string}
 */
messages.JSON_TYPE_PROPERTY = '@T';

/**
 * Message type identifiers.<br>
 * Ensure identifiers are unique within this name space.
 * @namespace
 */
messages.MessageTypeNames = {
  /**
   * Name space for control message type identifiers.
   *  @namespace
   */
  ctrl: {
    HEARTBEAT: 'C1',
    SUBSCRIBE: 'C2',
    SUBSCRIBE_RESPONSE: 'C3',
    UNSUBSCRIBE_RESPONSE: 'C4',
    CONNECT_RESPONSE: 'C5',
    CONNECTION_CLOSE: 'C6',
    FLOW: 'C7',
    SLOW_CONNECTION: 'C8',
    INITIAL_DATA_SENT: 'C9',
    RESUBSCRIBE_MESSAGE: 'C10',
    STATS: 'C12',
    STATS_RESPONSE: 'C13',
    EXCHANGE_SUBSCRIBE: 'C14',
    EXCHANGE_RESPONSE: 'C15',
    EXCHANGE_UNSUBSCRIBE_RESPONSE: 'C16',
    NEWS_SUBSCRIBE: 'C17',
    NEWS_SUBSCRIBE_RESPONSE: 'C18',
    ALERTS_SUBUNSUB: 'C19',
    ALERTS_SUBUNSUB_RESPONSE: 'C20',
    TRADE_SUBSCRIBE: 'C21',
    TRADE_SUBSCRIBE_RESPONSE: 'C22',
    NEWS_UNSUBSCRIBE_RESPONSE: 'C23',
    NEWS_COMMAND: 'C24',
    NEWS_CMD_FILTER_REFRESH_RESPONSE: 'C25',
    NEWS_CMD_FILTER_RESPONSE: 'C26',
    AUTHENTICATION: 'C27',
    OPEN_FLOW: 'C28',
    RECONNECT_RESPONSE: 'C29',
    TRADE_UNSUBSCRIBE_RESPONSE: 'C30',
    MISSED_DATA_SENT: 'C31'
  },
  /**
   * Name space for data message type identifiers.<br>
   * Prefix with 'D'.
   *  @namespace
   */
  data: {
    QUOTE: 'D1',
    PRICEDATA: 'D2',
    TRADE: 'D3',
    BOOKORDER: 'D4',
    BOOKDELETE: 'D5',
    PURGEBOOK: 'D6',
    MMQUOTE: 'D7',
    INTERVAL: 'D8',
    NETHOUSEPOSITION: 'D9',
    SYMBOLINFO: 'D10',
    SYMBOLSTATUS: 'D11',
    DERIVATIVEINFO: 'D12',
    LASTSALE: 'D13',
    LIMITUPLIMITDOWN: 'D14',
    IVGREEKS: 'D15',
    IMBALANCESTATUS: 'D16',
    ALERT: 'D17',
    NEWS: 'D18',
    TRADENOTIFICATION: 'D19',
    NEWSCMDFILTER: 'D20',
    NEWSERROR: 'D21',
    DIVIDEND: 'D22'
  }
};

/**
 * Super type of all exports.
 * @abstract
 * @constructor
 */
messages.Message = function () {};

messages.Message.prototype.init = function (typeid) {
  this[messages.JSON_TYPE_PROPERTY] = typeid;
};

/* ****************************************************************************************************************** */

/**
 * Creates a control message base object.
 * @abstract
 * @constructor
 */
messages.control.CtrlMessage = function () {};
messages.control.CtrlMessage.prototype = new messages.Message();

/**
 * Creates a heartbeat message.
 * @constructor
 */
messages.control.Heartbeat = function () {
  this.init(messages.MessageTypeNames.ctrl.HEARTBEAT);

  /**
   * Timestamp when heartbeat was generated.
   * @type {number|JSBI} for connections with JSON format timestamp will be decoded as number,
   * for connections with QITCH format - {@link JSBI.BigInt}
   */
  this.timestamp = null;
};
messages.control.Heartbeat.prototype = new messages.control.CtrlMessage();
/**
 * Creates a stats message.
 * @constructor
 */
messages.control.StatsMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.STATS);
};
messages.control.StatsMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates a subscribe message.
 * @constructor
 */
messages.control.SubscribeMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.SUBSCRIBE);

  /**
   * The action the server will taken when receiving this message.
   * @type {string}
   * @see exports.messages.control.Action
   */
  this.action = null;

  /**
   * List of ticker symbols to subscribe/un-subscribe for.
   * @type {Array.<string>}
   */
  this.symbols = [];

  /**
   * List of streaming message types to subscribe each ticker symbol for.
   * @type {Array.<string>}
   * @see exports.messages.control.MarketdataType
   */
  this.types = [];

  /**
   * Requested message mime-type format.
   * @type {string}
   * @see exports.messages.MimeTypes
   */
  this.mimetype = null;

  /**
   * Requested conflation. Null indicates using the default conflation.
   * @type {int}
   */
  this.conflation = null;
};
messages.control.SubscribeMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates an exchange subscribe message.
 * @constructor
 */
messages.control.ExchangeSubscribeMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.EXCHANGE_SUBSCRIBE);

  /**
   * The action the server will taken when receiving this message.
   * @type {string}
   * @see exports.messages.control.Action
   */
  this.action = null;

  /**
   * The Exchange to subscribe/un-subscribe for.
   * @type {Array.<string>}
   */
  this.exchange = null;

  /**
   * Requested message mime-type format.
   * @type {string}
   * @see exports.messages.MimeTypes
   */
  this.mimetype = null;

  /**
   * Requested conflation. Null indicates using the default conflation.
   * @type {int}
   */
  this.conflation = null;
};
messages.control.ExchangeSubscribeMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates an news subscribe message.
 * @constructor
 */
messages.control.NewsSubscribeMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.NEWS_SUBSCRIBE);

  /**
   * The action the server will taken when receiving this message.
   * @type {string}
   * @see exports.messages.control.Action
   */
  this.action = null;

  /**
   * The news filters to subscribe for.
   * @type {Array.<string>}
   */
  this.newsFilters = null;

  /**
   * Requested message mime-type format.
   * @type {string}
   * @see exports.messages.MimeTypes
   */
  this.mimetype = null;
};
messages.control.NewsSubscribeMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates an news reset message.
 * @constructor
 */
messages.control.NewsCommandMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.NEWS_COMMAND);

  /**
   * The action the server will taken when receiving this message.
   * @type {string}
   * @see exports.messages.control.Action
   */
  this.newsAction = null;

  /**
   * Requested message mime-type format.
   * @type {string}
   * @see exports.messages.MimeTypes
   */
  this.mimetype = null;
};
messages.control.NewsCommandMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates an news subscribe message.
 * @constructor
 */
messages.control.AlertsSubUnsubMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.ALERTS_SUBUNSUB);

  /**
   * sub/unsub for alerts.
   * @type {string}
   */
  this.operation = null;

  /**
   * Requested message mime-type format.
   * @type {string}
   * @see exports.messages.MimeTypes
   */
  this.mimetype = null;
};
messages.control.AlertsSubUnsubMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates Trade notification subscribe message.
 * @constructor
 */

messages.control.TradeSubscribeMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.TRADE_SUBSCRIBE);

  /**
   * The action the server will taken when receiving this message.
   * @type {string}
   * @see exports.messages.control.Action
   */
  this.action = null;

  /**
   * The subscribe/un-subscribe for trade notifications.
   * @type {Array.<string>}
   */
  this.notificationType = null;

  /**
   * Requested message mime-type format.
   * @type {string}
   * @see exports.messages.MimeTypes
   */
  this.mimetype = null;
};
messages.control.TradeSubscribeMessage.prototype = new messages.control.CtrlMessage();

/**
 * Base class for response exports.
 * @abstract
 */
messages.control.BaseResponse = function () {
  /**
   * The response code.
   * @type {number}
   * @see {@link messages.control.ResponseCodes}
   */
  this.code = null;

  /**
   * The response reason.
   * @type {string}
   * @see {@link messages.control.ResponseCodes}
   */
  this.reason = null;
};
messages.control.BaseResponse.prototype = new messages.control.CtrlMessage();

/**
 * Creates a subscribe response message.
 * @constructor
 */
messages.control.SubscribeResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.SUBSCRIBE_RESPONSE);

  /**
   *
   * @type {Array.<messages.control.StreamEntitlement>}
   */
  this.entitlements = null;

  /**
   *
   * @type {Array.<string>}
   */
  this.invalidsymbols = null;

  /**
   *
   * @type {Array.<string>}
   */
  this.rejectedsymbols = null;
};
messages.control.SubscribeResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates an exchange subscribe response message.
 * @constructor
 */
messages.control.ExchangeSubscribeResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.EXCHANGE_RESPONSE);
};

messages.control.ExchangeSubscribeResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates an Alert un-subscribe response message.
 * @constructor
 */
messages.control.AlertSubUnsubResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.ALERTS_SUBUNSUB_RESPONSE);
};
messages.control.AlertSubUnsubResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates Trade notification subscribe response message.
 * @constructor
 */
messages.control.TradeSubscribeResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.TRADE_SUBSCRIBE_RESPONSE);
};

messages.control.TradeSubscribeResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates an un-subscribe response message.
 * @constructor
 */
messages.control.UnsubscribeResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.UNSUBSCRIBE_RESPONSE);

  /**
   *
   * @type {Array.<messages.control.StreamEntitlement>}
   */
  this.unsubscribed = null;
};
messages.control.UnsubscribeResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates an exchange unsubscribe response message.
 * @constructor
 */
messages.control.ExchangeUnsubscribeResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.EXCHANGE_UNSUBSCRIBE_RESPONSE);
};

messages.control.ExchangeUnsubscribeResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates an news un-subscribe response message.
 * @constructor
 */
messages.control.NewsUnsubscribeResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.NEWS_UNSUBSCRIBE_RESPONSE);

  /**
   *
   * @type {Array.<messages.control.StreamEntitlement>}
   */
  this.unsubscribed = null;
};
messages.control.NewsUnsubscribeResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates Trade notification subscribe response message.
 * @constructor
 */
messages.control.TradeUnsubscribeResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.TRADE_UNSUBSCRIBE_RESPONSE);
};

messages.control.TradeUnsubscribeResponse.prototype = new messages.control.BaseResponse();
/**
 * Creates a stream entitlement info.
 * @constructor
 */
messages.control.StreamEntitlement = function () {
  /**
   * The symbol the entitlement is for.
   * @type {string}
   */
  this.symbol = null;

  /**
   * The market data type the entitlement is for.
   * @type {string}
   * @see messages.control.MarketdataType
   */
  this.marketdatatype = null;

  /**
   *
   * @type {string}
   * @see messages.control.StreamEntitlementType
   */
  this.entitlement = null;
};

/**
 * Creates a new connect response message.
 * @constructor
 */
messages.control.ConnectResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.CONNECT_RESPONSE);

  /**
   * The server version.
   * @type {string}
   */
  this.version = null;

  /**
   * The flow control check interval.
   * @type {number}
   */
  this.flowControlCheckInterval = null;

  /**
   * The server instance connected to.
   * @type {string}
   */
  this.serverInstance = null;

  /**
   * The conflation rate in milliseconds.
   * @type {number}
   */
  this.conflationMs = null;
};
messages.control.ConnectResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates a new reconnect response message
 * @constructor
 */
messages.control.ReconnectResponse = function () {
  undefined.init(messages.MessageTypeNames.ctrl.RECONNECT_RESPONSE);

  /**
  * The server version.
  * @type {string}
  */
  undefined.version = null;

  /**
   * The flow control check interval.
   * @type {number}
   */
  undefined.flowControlCheckInterval = null;

  /**
   * The server instance connected to.
   * @type {string}
   */
  undefined.serverInstance = null;

  /**
   * The conflation rate in milliseconds.
   * @type {number}
   */
  undefined.conflationMs = null;

  /**
  * The previous subscriptions
  * @type {Array.<messages.control.StreamEntitlement>}
  */
  undefined.previousSubscriptions = null;
};

/**
 * Creates a connection response message.
 * @constructor
 */
messages.control.ConnectionClose = function () {
  this.init(messages.MessageTypeNames.ctrl.CONNECTION_CLOSE);

  /**
   * The connection close reason code.
   * @type {number}
   * @see {@link messages.control.ResponseCodes}
   */
  this.code = null;

  /**
   * The connection close reason message.
   * @type {string}
   * @see {@link messages.control.ResponseCodes}
   */
  this.reason = null;
};
messages.control.ConnectionClose.prototype = new messages.control.CtrlMessage();

/**
 * Creates a slow connection response message.
 * @constructor
 */
messages.control.SlowConnection = function () {
  this.init(messages.MessageTypeNames.ctrl.SLOW_CONNECTION);

  /**
   * The number of times that the connection has exceeded already.
   * @type {number}
   */
  this.timesExceeded = null;

  /**
   * The max number allowed. The connection may close after reaching this number.
   * @type {number}
   */
  this.maxExceed = null;
};
messages.control.SlowConnection.prototype = new messages.control.CtrlMessage();

/**
 * Creates a flow control message.
 * @constructor
 */
messages.control.FlowMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.FLOW);

  /**
   * Last received sequence number.
   * @type {number}
   * @see {@link messages.LongSequence}
   */
  this.sequence = null;
};
messages.control.FlowMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates an Auth message for Stomp connection Auth verification.
 * @constructor
 */
messages.control.AuthenticationMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.AUTHENTICATION);

  /**
   * Auth method.
   * @type {String}
   */
  this.authenticationMethod = null;

  /**
   * Auth WMID if using enterprise token auth method we need to have both wmid and authorization.
   * @type {String}
   */
  this.wmid = null;

  /**
   * Auth token.
   * @type {String}
   */
  this.authorization = null;

  /**
   * Requested conflation. Null indicates using the default conflation.
   * @type {number}
   */
  this.conflation = 150;

  /**
   *
   * @type {Boolean}
   */
  this.rejectExcessiveConnection = false;
};
messages.control.AuthenticationMessage.prototype = new messages.control.CtrlMessage();

/**
 * Creates a stats response message.
 * @constructor
 */
messages.control.StatsResponse = function () {
  this.init(messages.MessageTypeNames.ctrl.STATS_RESPONSE);

  /**
   *
   * @type {number}
   */
  this.numberOfSubscribedSymbolsL1 = null;
  /**
   *
   * @type {number}
   */
  this.numberOfAvailableSymbolsL1 = null;
  /**
   *
   * @type {number}
   */
  this.numberOfSubscribedSymbolsL2 = null;
  /**
   *
   * @type {number}
   */
  this.numberOfAvailableSymbolsL2 = null;
  /**
   *
   * @type {number}
   */
  this.numberOfOpenedConnections = null;
  /**
   *
   * @type {number}
   */
  this.numberOfAvailableConnections = null;
  /**
   *
   * @type {number}
   */
  this.numberOfSubscribedExchanges = null;
  /**
   *
   * @type {number}
   */
  this.numberOfSubscribedTrades = null;
};
messages.control.StatsResponse.prototype = new messages.control.BaseResponse();

/**
 * Creates a Initial Data Sent response message.
 * @constructor
 */
messages.control.InitialDataSent = function () {
  this.init(messages.MessageTypeNames.ctrl.INITIAL_DATA_SENT);

  /**
   * The timestamp of message creation.
   * @type {number|JSBI} for connections with JSON format timestamp will be decoded as number,
   * for connections with QITCH format - {@link JSBI.BigInt}
   */
  this.timestamp = null;
};
messages.control.InitialDataSent.prototype = new messages.control.CtrlMessage();

/**
 * Creates a Resubscribe message.
 * @constructor
 */
messages.control.ResubscribeMessage = function () {
  this.init(messages.MessageTypeNames.ctrl.RESUBSCRIBE_MESSAGE);

  /**
   * The timestamp of message creation.
   * @type {number|JSBI} for connections with JSON format timestamp will be decoded as number,
   * for connections with QITCH format - {@link JSBI.BigInt}
   */
  this.timestamp = null;
};
messages.control.ResubscribeMessage.prototype = new messages.control.CtrlMessage();

/**
* Creates a Missed Data Sent response message.
* @constructor
*/
messages.control.MissedDataSent = function () {
  this.init(messages.MessageTypeNames.ctrl.MISSED_DATA_SENT);

  /**
   * The timestamp of message creation.
   * @type {number|JSBI} for connections with JSON format timestamp will be decoded as number,
   * for connections with QITCH format - {@link JSBI.BigInt}
   */
  this.timestamp = null;
};
messages.control.MissedDataSent.prototype = new messages.control.CtrlMessage();

/**
 * Stream entitlement types.
 * @enum
 * @readonly
 */
messages.control.StreamEntitlementType = {
  RT: "Realtime",
  RTO: "Realtime CBOE ONE",
  RTN: "Realtime NASDAQ",
  RTB: "Realtime BATS",
  DL: "Delayed",
  DLO: "Delayed CBOE One",
  DLN: "Delayed NASDAQ",
  NA: "Not Entitled"
};

/**
 * Enumeration for subscription actions.
 * @enum
 * @readonly
 */
messages.control.Action = {
  SUBSCRIBE: "SUBSCRIBE",
  UNSUBSCRIBE: "UNSUBSCRIBE"
};

/**
 * Enumeration for associations.
 * @enum
 * @readonly
 */
messages.control.Association = {
  AND: "AND",
  OR: "OR",
  NOT: "NOT"
};

/**
 * Enumeration for streaming message types.
 * @enum
 * @readonly
 * @deprecated Use the messages.market.SubscriptionTypes along with messages.market.MarketDataResponseTypes
 */
messages.control.MarketdataType = {
  QUOTE: "QUOTE",
  PRICEDATA: "PRICEDATA",
  TRADE: "TRADE",
  MMQUOTE: "MMQUOTE",
  ORDERBOOK: "ORDERBOOK",
  INTERVAL: "INTERVAL",
  NETHOUSEPOSITION: "NETHOUSEPOSITION",
  LASTSALE: "LASTSALE",
  BOOKORDER: "BOOKORDER",
  BOOKDELETE: "BOOKDELETE",
  PURGEBOOK: "PURGEBOOK",
  LIMITUPLIMITDOWN: "LIMITUPLIMITDOWN",
  IVGREEKS: "IVGREEKS",
  IMBALANCESTATUS: "IMBALANCESTATUS"
};

/**
 * Enum for the allowed subscription types
 * @enum
 * @readonly
 */
messages.market.SubscriptionTypes = {
  QUOTE: "QUOTE",
  PRICEDATA: "PRICEDATA",
  TRADE: "TRADE",
  MMQUOTE: "MMQUOTE",
  ORDERBOOK: "ORDERBOOK",
  INTERVAL: "INTERVAL",
  NETHOUSEPOSITION: "NETHOUSEPOSITION",
  LASTSALE: "LASTSALE",
  LIMITUPLIMITDOWN: "LIMITUPLIMITDOWN",
  IVGREEKS: "IVGREEKS",
  IMBALANCESTATUS: "IMBALANCESTATUS"

  /**
   * Enum for streamer responses from server
   * @enum
   * @readonly
   */
};messages.market.MarketDataResponseTypes = {
  QUOTE: "QUOTE",
  PRICEDATA: "PRICEDATA",
  TRADE: "TRADE",
  INTERVAL: "INTERVAL",
  NETHOUSEPOSITION: "NETHOUSEPOSITION",
  MMQUOTE: "MMQUOTE",
  BOOKORDER: "BOOKORDER",
  PURGEBOOK: "PURGEBOOK",
  BOOKDELETE: "BOOKDELETE",
  SYMBOLINFO: "SYMBOLINFO",
  SYMBOLSTATUS: "SYMBOLSTATUS",
  DERIVATIVEINFO: "DERIVATIVEINFO",
  LASTSALE: "LASTSALE",
  LIMITUPLIMITDOWN: "LIMITUPLIMITDOWN",
  IVGREEKS: "IVGREEKS",
  IMBALANCESTATUS: "IMBALANCESTATUS",
  ALERT: "ALERT",
  NEWS: "NEWS",
  TRADENOTIFICATION: "TRADENOTIFICATION",
  NEWSCMDFILTER: "NEWSCMDFILTER",
  NEWSERROR: "NEWSERROR",
  DIVIDEND: "DIVIDEND"

  /**
   * Response codes and reasons.
   * @enum
   * @readonly
   */
};messages.control.ResponseCodes = {
  OK_CODE: 200,
  OK_REASON: "OK",

  BADREQUEST_CODE: 400,
  BADREQUEST_REASON: "Bad Request",

  UNAUTHORIZED_CODE: 401,
  UNAUTHORIZED_REASON: "Unauthorized",

  TOOSLOW_CODE: 450,
  TOOSLOW_REASON: "Too slow",

  DATA_SOURCE_RESET: 454,
  DATA_SOURCE_RESET_REASON: "Data Source Was Reset",

  CONNECTION_LIMIT_EXCEEDED_CODE: 452,
  CONNECTION_LIMIT_EXCEEDED_REASON: "Connection Limit Exceeded",

  INTERNALSERVERERROR_CODE: 500,
  INTERNALSERVERERROR_REASON: "Internal Server Error"
};

/* ****************************************************************************************************************** */

/**
 * Base type for all market data exports.
 * @constructor
 * @abstract
 */
messages.market.DataMessage = function () {
  /**
   * The message type.
   * @type {number}
   * @see messages.MessageTypeNames_0.data
   */
  this.messageType = null;
};
messages.market.DataMessage.prototype = new messages.Message();

/**
 *
 * @constructor
 */
messages.market.Quote = function () {
  this.init(messages.MessageTypeNames.data.QUOTE);

  // TODO properties
};
messages.market.Quote.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.PriceData = function () {
  this.init(messages.MessageTypeNames.data.PRICEDATA);

  // TODO properties
};
messages.market.PriceData.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.Trade = function () {
  this.init(messages.MessageTypeNames.data.TRADE);

  // TODO properties
};
messages.market.Trade.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.MMQuote = function () {
  this.init(messages.MessageTypeNames.data.MMQUOTE);

  // TODO properties
};
messages.market.MMQuote.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.PurgeBook = function () {
  this.init(messages.MessageTypeNames.data.PURGEBOOK);

  // TODO properties
};
messages.market.PurgeBook.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.BookOrder = function () {
  this.init(messages.MessageTypeNames.data.BOOKORDER);

  // TODO properties
};
messages.market.BookOrder.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.BookDelete = function () {
  this.init(messages.MessageTypeNames.data.BOOKDELETE);

  // TODO properties
};
messages.market.BookDelete.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.Interval = function () {
  this.init(messages.MessageTypeNames.data.INTERVAL);

  // TODO properties
};
messages.market.Interval.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.NethousePosition = function () {
  this.init(messages.MessageTypeNames.data.NETHOUSEPOSITION);

  // TODO properties
};
messages.market.NethousePosition.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.SymbolInfo = function () {
  this.init(messages.MessageTypeNames.data.SYMBOLINFO);

  // TODO properties
};
messages.market.SymbolInfo.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.SymbolStatus = function () {
  this.init(messages.MessageTypeNames.data.SYMBOLSTATUS);

  // TODO properties
};
messages.market.SymbolStatus.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.DerivativeInfo = function () {
  this.init(messages.MessageTypeNames.data.DERIVATIVEINFO);

  // TODO properties
};
messages.market.DerivativeInfo.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.IVGreeks = function () {
  this.init(messages.MessageTypeNames.data.IVGREEKS);

  // TODO properties
};
messages.market.IVGreeks.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.LastSale = function () {
  this.init(messages.MessageTypeNames.data.LASTSALE);

  // TODO properties
};
messages.market.LastSale.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.LimitUpLimitDown = function () {
  this.init(messages.MessageTypeNames.data.LIMITUPLIMITDOWN);

  // TODO properties
};
messages.market.LimitUpLimitDown.prototype = new messages.market.DataMessage();

/**
 *
 * @constructor
 */
messages.market.ImbalanceStatus = function () {
  this.init(messages.MessageTypeNames.data.IMBALANCESTATUS);

  // TODO properties
};
messages.market.ImbalanceStatus.prototype = new messages.market.DataMessage();

messages.market.Alert = function () {
  this.init(messages.MessageTypeNames.data.ALERT);

  // TODO properties
};
messages.market.Alert.prototype = new messages.market.DataMessage();

/**
 * Enumeration for instrument types.
 * @enum
 * @readonly
 */
messages.market.InstrumentType = {
  1: "CASH",
  2: "BOND",
  3: "COMPOSITE",
  4: "FUTURE",
  5: "FUTURE_OPTION",
  6: "FOREX",
  7: "INDEX",
  8: "MUTUAL_FUND",
  9: "MONEY_MARKET_FUND",
  10: "MARKET_STAT",
  11: "EQUITY",
  12: "EQUITY_OPTION",
  13: "GOVT_BOND",
  14: "MUNI_BOND",
  15: "CORP_BOND",
  16: "ETF",
  17: "FUTURE_SPREAD",
  97: "OPTION_ROOT",
  98: "UNKNOWN",
  99: "RATE"
};

/**
 * Enumeration vor order side.
 * @enum
 * @readonly
 */
messages.market.OrderSide = {
  BUYSIDE: 'B',
  SELLSIDE: 'S'
};

/**
 * Enumeration for imbalance types.
 * @enum
 * @readonly
 */
messages.market.ImbalanceType = {
  0: "NONE",
  1: "MARKET",
  2: "MOC",
  3: "REGULATORY_IMBALANCE",
  4: "OPENING_IMBALANCE",
  5: "CLOSING_IMBALANCE",
  6: "IPO_IMBALANCE",
  7: "HALT_IMBALANCE",
  8: "EQUILIBRIUM"
};

/**
 * Enumeration for book order change types.
 * @enum
 * @readonly
 */
messages.market.OrderChangeType = {
  'A': "ADD",
  'M': "MODIFY",
  'C': "CANCEL",
  'E': "EXECUTE"
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/streamer-api.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],109:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

require("./polyfills");

var Event = function () {
    function Event(props) {
        _classCallCheck(this, Event);

        Object.assign(this, props);
    }

    Event.prototype.toString = function toString() {
        var result = this.type + "{";
        var isFirst = true;
        for (var key in this) {
            if (key === 'type' || typeof this[key] === 'function') {
                continue;
            }

            if (!isFirst) {
                result += ", ";
            }
            result += key + ": " + JSON.stringify(this[key]);
            isFirst = false;
        }
        result += "}";
        return result;
    };

    return Event;
}();

var event = exports.event = function event(type, moreArgs) {
    return new Event(Object.assign({
        type: type
    }, moreArgs));
};

var error = exports.error = function error(description, moreArgs) {
    return event("error", Object.assign({
        description: description
    }, moreArgs));
};

var close = exports.close = function close(moreArgs) {
    return event("close", moreArgs);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/streamer-events.js","/lib")
},{"./polyfills":18,"_process":131,"buffer":121,"timers":152}],110:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

exports.__esModule = true;
exports.getMessageName = exports.entitlement = exports.isvalid = exports.iscontrolmessage = exports.isdatamessage = exports.messagetype = undefined;

var _streamerApi = require('./streamer-api.js');

/**
 * Returns the type identifier for msg.
 * @param msg message to get type identifier for
 * @returns {string} the type identifier
 */
var messagetype = exports.messagetype = function messagetype(msg) {
    if (msg === null) {
        return null;
    }
    return msg[_streamerApi.messages.JSON_TYPE_PROPERTY];
};

/**
 * @static
 * Determines if msg is a data message.
 * @param msg the message to check
 * @returns {boolean} true if msg is a data message, false otherwise
 */
var isdatamessage = exports.isdatamessage = function isdatamessage(msg) {
    if (msg === null) {
        return false;
    }
    var _type = exports.messagetype(msg);
    if (_type === null) {
        return false;
    }
    return _type.startsWith('D');
};

/**
 * @static
 * Determines if msg is a control message.
 * @param msg the message to check
 * @returns {boolean} true if msg is a control message, false otherwise
 */
var iscontrolmessage = exports.iscontrolmessage = function iscontrolmessage(msg) {
    if (msg === null) {
        return false;
    }
    var _type = exports.messagetype(msg);
    if (_type === null) {
        return false;
    }
    return _type.startsWith('C');
};

/**
 * Checks if the symbol is valid according to the subscription response.
 * @param {string} symbol to check for validity.
 * @param {exports.messages.control.SubscribeResponse} response to check against.
 * @returns {boolean} <code>true</code> if symbol is valid, <code>false</code> otherwise.
 */
var isvalid = exports.isvalid = function isvalid(symbol, response) {
    var _invalidsymbols = response.invalidSymbols;
    if (_invalidsymbols == null) {
        return true;
    }
    for (var i = 0; i < _invalidsymbols.length; i++) {
        var _invalidsymbol = _invalidsymbols[i];
        if (_invalidsymbol === symbol) {
            return false;
        }
    }
    return true;
};

/**
 * Get entitlement for symbol datatype, according to subscription response.
 * @param {string} symbol to check entitlement for.
 * @param {string} datatype to check entitlemetn for.
 * @param {exports.messages.control.SubscribeResponse} response to check against.
 * @returns {string} entitlement type or null if not entitled.
 * @see exports.messages.control.StreamEntitlementType
 */
var entitlement = exports.entitlement = function entitlement(symbol, datatype, response) {
    var _entitlements = response.entitlements;
    if (_entitlements != null) {
        for (var i = 0; i < _entitlements.length; i++) {
            var _entitlement = _entitlements[i];
            if (_entitlement.symbol === symbol && _entitlement.marketdatatype === datatype) {
                return _entitlement.entitlement;
            }
        }
    }

    return null;
};

var getMessageName = exports.getMessageName = function () {
    var messageNameLookups = {};
    return function (msg) {
        var type = msg[_streamerApi.messages.JSON_TYPE_PROPERTY];
        if (!messageNameLookups[type]) {
            var ctrl = _streamerApi.messages.MessageTypeNames.ctrl;
            for (var message in ctrl) {
                if (ctrl[message] === type) {
                    messageNameLookups[type] = message;
                    return message;
                }
            }

            var data = _streamerApi.messages.MessageTypeNames.data;
            for (var _message in data) {
                if (data[_message] === type) {
                    messageNameLookups[type] = _message;
                    return _message;
                }
            }

            messageNameLookups[type] = type;
            return type;
        }
        return messageNameLookups[type];
    };
}();
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/streamer-utils.js","/lib")
},{"./streamer-api.js":108,"_process":131,"buffer":121,"timers":152}],111:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _EventSupport = require("../EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var JsonStompTransmitter = function () {
    function JsonStompTransmitter(socket, log) {
        _classCallCheck(this, JsonStompTransmitter);

        this.socket = socket;
        this.log = log;
        this.events = new _EventSupport2["default"](this);
    }

    JsonStompTransmitter.prototype.send = function send(msg, id) {
        this.socket.send(JSON.stringify(msg));
    };

    JsonStompTransmitter.prototype.onMessage = function onMessage(msg) {
        var _jsonblock = null;
        try {
            _jsonblock = JSON.parse(msg);
        } catch (e) {
            this.log.error(e);
            return;
        }

        var _jsonmsg = _jsonblock;
        _jsonmsg.__id = _jsonmsg['requestId'];
        this.events.fire("message", _jsonmsg);
    };

    JsonStompTransmitter.prototype.on = function on(event, callback) {
        return this.events.on(event, callback);
    };

    return JsonStompTransmitter;
}();

exports["default"] = JsonStompTransmitter;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/transmission/JsonStompTransmitter.js","/lib/transmission")
},{"../EventSupport.js":2,"_process":131,"buffer":121,"timers":152}],112:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _message = require("../message.js");

var _EventSupport = require("../EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var JsonTransmitter = function () {
    function JsonTransmitter(socket, log) {
        _classCallCheck(this, JsonTransmitter);

        this.socket = socket;
        this.log = log;
        this.events = new _EventSupport2["default"](this);
    }

    JsonTransmitter.prototype.send = function send(msg, id) {
        // id is part of msg
        this.socket.push({
            trackMessageLength: true,
            data: JSON.stringify(msg)
        });
    };

    JsonTransmitter.prototype.onMessage = function onMessage(msg) {
        var _jsonblock = null;
        try {
            _jsonblock = JSON.parse(msg);
        } catch (e) {
            this.log.error(e);
            return;
        }
        this.events.fire("sequence", _jsonblock.seq); // Flow control at block level
        var _nummessages = _jsonblock.data.length;
        for (var i = 0; i < _nummessages; i++) {
            var _jsonmsg = _jsonblock.data[i];
            _jsonmsg.__id = _jsonmsg['requestId'];
            this.events.fire("message", _jsonmsg);
        }
    };

    JsonTransmitter.prototype.on = function on(event, callback) {
        return this.events.on(event, callback);
    };

    return JsonTransmitter;
}();

exports["default"] = JsonTransmitter;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/transmission/JsonTransmitter.js","/lib/transmission")
},{"../EventSupport.js":2,"../message.js":17,"_process":131,"buffer":121,"timers":152}],113:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _EventSupport = require("../EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

var _SMessage = require("../SMessage");

var _SMessage2 = _interopRequireDefault(_SMessage);

var _QitchDecoder = require("../qitch/decoder/QitchDecoder");

var _QitchDecoder2 = _interopRequireDefault(_QitchDecoder);

var _QitchEncoder = require("../qitch/encoder/QitchEncoder");

var _QitchEncoder2 = _interopRequireDefault(_QitchEncoder);

var _UShortId = require("../UShortId.js");

var _UShortId2 = _interopRequireDefault(_UShortId);

var _message = require("../message.js");

var _LocateCodeInjector = require("../qitch/LocateCodeInjector");

var _LocateCodeInjector2 = _interopRequireDefault(_LocateCodeInjector);

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 Note: QITCH is currently in a Beta phase and can potentially cause performance degradation
 */
var QitchTransmitter = function () {
    function QitchTransmitter(socket, encoder, log) {
        _classCallCheck(this, QitchTransmitter);

        this.socket = socket;
        if (!(encoder instanceof _QitchEncoder2["default"])) {
            throw "Wrong encoder";
        }
        this.encoder = encoder;
        this.log = log;
        this.events = new _EventSupport2["default"](this);
        this.decoder = new _QitchDecoder2["default"](QitchTransmitter.prototype.DEFAULT_BUFFERSIZE);
        this.locateCodeInjector = new _LocateCodeInjector2["default"]();
    }

    QitchTransmitter.prototype.send = function send(msg, id) {
        var _msg = new _SMessage2["default"]();
        _msg.sequencenumber = msg.sequenceNumber;
        _msg.timestamp = new Date().getTime();
        _msg.id = id != null ? id : _UShortId2["default"].NULL;
        _msg.encoding = _message.Encodings.NONE_CHAR;
        _msg.mimetype = _message.MimeTypes.QITCH_CHAR;
        _msg.payload = msg;

        var encoded = this.encoder.encode(_msg, 0);

        var req = {
            trackMessageLength: false,
            data: encoded
        };

        this.socket.push(req);
    };

    QitchTransmitter.prototype.onMessage = function onMessage(msg) {
        var arrayBuffer = void 0;
        if (msg instanceof ArrayBuffer) {
            arrayBuffer = msg;
        } else {
            arrayBuffer = (0, _utils.asciiStringToArrayBuffer)(msg);
        }
        var messages = null;
        try {
            messages = this.decoder.decode(new Int8Array(arrayBuffer));
        } catch (e) {
            this.log.error(e);
            return;
        }

        if (messages == null) {
            this.log.debug("Couldn't decode message. Ignoring unsupported message");
            return;
        }
        for (var i = 0; i < messages.length; i++) {
            if (messages[i] instanceof _QitchDecoder.MessageBlock) {
                for (var j = 0; j < messages[i].messages.length; j++) {
                    this._processMessage(messages[i].messages[j]);
                }
            } else {
                this._processMessage(messages[i]);
            }
        }
    };

    QitchTransmitter.prototype.on = function on(event, callback) {
        return this.events.on(event, callback);
    };

    QitchTransmitter.prototype._processMessage = function _processMessage(message) {
        this.locateCodeInjector.injectLocateCode(message.decodedPayload);

        this.events.fire("sequence", message.sequencenumber);
        message.decodedPayload.__id = message.id;
        this.events.fire("message", message.decodedPayload);
    };

    return QitchTransmitter;
}();

QitchTransmitter.prototype.DEFAULT_BUFFERSIZE = 4096;

exports["default"] = QitchTransmitter;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/transmission/QitchTransmitter.js","/lib/transmission")
},{"../EventSupport.js":2,"../SMessage":5,"../UShortId.js":9,"../message.js":17,"../qitch/LocateCodeInjector":23,"../qitch/decoder/QitchDecoder":46,"../qitch/encoder/QitchEncoder":76,"../utils":115,"_process":131,"buffer":121,"timers":152}],114:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;

var _message = require("../message.js");

var _SMessage = require("../SMessage.js");

var _SMessage2 = _interopRequireDefault(_SMessage);

var _UShortId = require("../UShortId.js");

var _UShortId2 = _interopRequireDefault(_UShortId);

var _EventSupport = require("../EventSupport.js");

var _EventSupport2 = _interopRequireDefault(_EventSupport);

var _formatting = require("../formatting.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SMessageTransmitter = function () {
    function SMessageTransmitter(socket, encoder, decoder, log) {
        _classCallCheck(this, SMessageTransmitter);

        this.socket = socket;
        this.encoder = encoder;
        this.decoder = decoder;
        this.log = log;
        this.events = new _EventSupport2["default"](this);
    }

    SMessageTransmitter.prototype.send = function send(msg, id) {
        var _msg = new _SMessage2["default"]();
        _msg.sequencenumber = msg.sequenceNumber;
        _msg.timestamp = new Date().getTime();
        _msg.id = id != null ? id : _UShortId2["default"].NULL;
        _msg.encoding = _message.Encodings.NONE_CHAR;
        _msg.mimetype = _message.MimeTypes.JSON_CHAR;
        _msg.payload = JSON.stringify(msg);

        var encoded = this.encoder.encode(_msg);

        var req = {
            trackMessageLength: true,
            data: encoded
        };

        this.socket.push(req);
    };

    SMessageTransmitter.prototype.onMessage = function onMessage(msg) {
        var _smessage = this.decoder.decode(msg);

        this.events.fire("sequence", _smessage.sequencenumber);

        // TODO create PayloadDecoder using map instead of if else
        if (_smessage.encoding === _message.Encodings.NONE_CHAR) {
            if (_smessage.mimetype === _message.MimeTypes.JSON_CHAR) {
                var _jsonmsg = null;
                try {
                    _jsonmsg = JSON.parse(_smessage.payload);
                } catch (e) {
                    this.log.error(e);
                    return;
                }
                _jsonmsg.__id = _smessage.id;
                this.events.fire("message", _jsonmsg);
            } else {
                this.log.debug("Unhandled mimetype: " + _smessage.mimeType + " - " + _smessage.payload); // TODO support
            }
        } else {
            this.log.debug("Unhandled encoding: " + _smessage.encoding + " - " + _smessage.payload); // TODO support
        }
    };

    SMessageTransmitter.prototype.on = function on(event, callback) {
        return this.events.on(event, callback);
    };

    return SMessageTransmitter;
}();

exports["default"] = SMessageTransmitter;
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/transmission/SMessageTransmitter.js","/lib/transmission")
},{"../EventSupport.js":2,"../SMessage.js":5,"../UShortId.js":9,"../formatting.js":13,"../message.js":17,"_process":131,"buffer":121,"timers":152}],115:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
"use strict";

exports.__esModule = true;
var forEachPartition = exports.forEachPartition = function forEachPartition(xs, partitionSize, callback) {
    if (!xs) {
        return;
    }

    for (var i = 0; i < xs.length; i += partitionSize) {
        var partition = xs.slice(i, i + partitionSize);
        callback(partition);
    }
};

var indexOf = exports.indexOf = function indexOf(xs, val) {
    var length = xs.length;

    for (var i = 0; i < length; ++i) {
        if (val === xs[i]) {
            return i;
        }
    }
    return -1;
};

var removeFromArray = exports.removeFromArray = function removeFromArray(arr) {
    var what,
        L = arguments.length <= 1 ? 0 : arguments.length - 1,
        ax;
    while (L > 0 && arr.length) {
        var _ref;

        what = (_ref = --L + 1, arguments.length <= _ref ? undefined : arguments[_ref]);
        while ((ax = indexOf(arr, what)) !== -1) {
            arr.splice(ax, 1);
        }
    }
    return arr;
};

var asciiStringToArrayBuffer = exports.asciiStringToArrayBuffer = function asciiStringToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/lib/utils.js","/lib")
},{"_process":131,"buffer":121,"timers":152}],116:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){

module.exports = function equal(arr1, arr2) {
  var length = arr1.length
  if (length !== arr2.length) return false
  for (var i = 0; i < length; i++)
    if (arr1[i] !== arr2[i])
      return false
  return true
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/array-equal/index.js","/node_modules/array-equal")
},{"_process":131,"buffer":121,"timers":152}],117:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/base64-js/index.js","/node_modules/base64-js")
},{"_process":131,"buffer":121,"timers":152}],118:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.0
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if only one character,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '1e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/bignumber.js/bignumber.js","/node_modules/bignumber.js")
},{"_process":131,"buffer":121,"timers":152}],119:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/browser-resolve/empty.js","/node_modules/browser-resolve")
},{"_process":131,"buffer":121,"timers":152}],120:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/browserify/lib/_empty.js","/node_modules/browserify/lib")
},{"_process":131,"buffer":121,"timers":152}],121:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/buffer/index.js","/node_modules/buffer")
},{"_process":131,"base64-js":117,"buffer":121,"ieee754":126,"timers":152}],122:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/builtin-status-codes/browser.js","/node_modules/builtin-status-codes")
},{"_process":131,"buffer":121,"timers":152}],123:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/core-util-is/lib/util.js","/node_modules/core-util-is/lib")
},{"_process":131,"buffer":121,"timers":152}],124:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/events/events.js","/node_modules/events")
},{"_process":131,"buffer":121,"timers":152}],125:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/https-browserify/index.js","/node_modules/https-browserify")
},{"_process":131,"buffer":121,"http":137,"timers":152,"url":154}],126:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/ieee754/index.js","/node_modules/ieee754")
},{"_process":131,"buffer":121,"timers":152}],127:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/inherits/inherits_browser.js","/node_modules/inherits")
},{"_process":131,"buffer":121,"timers":152}],128:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self,e.JSBI=t())})(this,function(){'use strict';function e(t){return e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e(t)}function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){for(var _,n=0;n<t.length;n++)_=t[n],_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}function _(e,t,_){return t&&i(e.prototype,t),_&&i(e,_),e}function n(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&l(e,t)}function g(e){return g=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},g(e)}function l(e,t){return l=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},l(e,t)}function o(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}function a(){return a=o()?Reflect.construct:function(e,t,i){var _=[null];_.push.apply(_,t);var n=Function.bind.apply(e,_),g=new n;return i&&l(g,i.prototype),g},a.apply(null,arguments)}function s(e){return-1!==Function.toString.call(e).indexOf("[native code]")}function u(e){var t="function"==typeof Map?new Map:void 0;return u=function(e){function i(){return a(e,arguments,g(this).constructor)}if(null===e||!s(e))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if("undefined"!=typeof t){if(t.has(e))return t.get(e);t.set(e,i)}return i.prototype=Object.create(e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),l(i,e)},u(e)}function r(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function d(e,t){return t&&("object"==typeof t||"function"==typeof t)?t:r(e)}var h=function(i){var o=Math.abs,a=Math.max,s=Math.imul,u=Math.clz32;function l(e,i){var _;if(t(this,l),e>l.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded");return _=d(this,g(l).call(this,e)),_.sign=i,_}return n(l,i),_(l,[{key:"toDebugString",value:function(){var e=["BigInt["],t=!0,i=!1,_=void 0;try{for(var n,g,l=this[Symbol.iterator]();!(t=(n=l.next()).done);t=!0)g=n.value,e.push((g?(g>>>0).toString(16):g)+", ")}catch(e){i=!0,_=e}finally{try{t||null==l["return"]||l["return"]()}finally{if(i)throw _}}return e.push("]"),e.join("")}},{key:"toString",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:10;if(2>e||36<e)throw new RangeError("toString() radix argument must be between 2 and 36");return 0===this.length?"0":0==(e&e-1)?l.__toStringBasePowerOfTwo(this,e):l.__toStringGeneric(this,e,!1)}},{key:"__copy",value:function(){for(var e=new l(this.length,this.sign),t=0;t<this.length;t++)e[t]=this[t];return e}},{key:"__trim",value:function(){for(var e=this.length,t=this[e-1];0===t;)e--,t=this[e-1],this.pop();return 0===e&&(this.sign=!1),this}},{key:"__initializeDigits",value:function(){for(var e=0;e<this.length;e++)this[e]=0}},{key:"__clzmsd",value:function(){return u(this[this.length-1])}},{key:"__inplaceMultiplyAdd",value:function(e,t,_){_>this.length&&(_=this.length);for(var n=65535&e,g=e>>>16,l=0,o=65535&t,a=t>>>16,u=0;u<_;u++){var r=this.__digit(u),d=65535&r,h=r>>>16,b=s(d,n),m=s(d,g),c=s(h,n),v=s(h,g),y=o+(65535&b),f=a+l+(y>>>16)+(b>>>16)+(65535&m)+(65535&c);o=(m>>>16)+(c>>>16)+(65535&v)+(f>>>16),l=o>>>16,o&=65535,a=v>>>16;this.__setDigit(u,65535&y|f<<16)}if(0!==l||0!==o||0!==a)throw new Error("implementation bug")}},{key:"__inplaceAdd",value:function(e,t,_){for(var n,g=0,l=0;l<_;l++)n=this.__halfDigit(t+l)+e.__halfDigit(l)+g,g=n>>>16,this.__setHalfDigit(t+l,n);return g}},{key:"__inplaceSub",value:function(e,t,_){var n=0;if(1&t){t>>=1;for(var g=this.__digit(t),l=65535&g,o=0;o<_-1>>>1;o++){var a=e.__digit(o),s=(g>>>16)-(65535&a)-n;n=1&s>>>16,this.__setDigit(t+o,s<<16|65535&l),g=this.__digit(t+o+1),l=(65535&g)-(a>>>16)-n,n=1&l>>>16}var u=e.__digit(o),r=(g>>>16)-(65535&u)-n;n=1&r>>>16,this.__setDigit(t+o,r<<16|65535&l);if(t+o+1>=this.length)throw new RangeError("out of bounds");0==(1&_)&&(g=this.__digit(t+o+1),l=(65535&g)-(u>>>16)-n,n=1&l>>>16,this.__setDigit(t+e.length,4294901760&g|65535&l))}else{t>>=1;for(var d=0;d<e.length-1;d++){var h=this.__digit(t+d),b=e.__digit(d),m=(65535&h)-(65535&b)-n;n=1&m>>>16;var c=(h>>>16)-(b>>>16)-n;n=1&c>>>16,this.__setDigit(t+d,c<<16|65535&m)}var v=this.__digit(t+d),y=e.__digit(d),f=(65535&v)-(65535&y)-n;n=1&f>>>16;var k=0;0==(1&_)&&(k=(v>>>16)-(y>>>16)-n,n=1&k>>>16),this.__setDigit(t+d,k<<16|65535&f)}return n}},{key:"__inplaceRightShift",value:function(e){if(0!==e){for(var t,_=this.__digit(0)>>>e,n=this.length-1,g=0;g<n;g++)t=this.__digit(g+1),this.__setDigit(g,t<<32-e|_),_=t>>>e;this.__setDigit(n,_)}}},{key:"__digit",value:function(e){return this[e]}},{key:"__unsignedDigit",value:function(e){return this[e]>>>0}},{key:"__setDigit",value:function(e,t){this[e]=0|t}},{key:"__setDigitGrow",value:function(e,t){this[e]=0|t}},{key:"__halfDigitLength",value:function(){var e=this.length;return 65535>=this.__unsignedDigit(e-1)?2*e-1:2*e}},{key:"__halfDigit",value:function(e){return 65535&this[e>>>1]>>>((1&e)<<4)}},{key:"__setHalfDigit",value:function(e,t){var i=e>>>1,_=this.__digit(i),n=1&e?65535&_|t<<16:4294901760&_|65535&t;this.__setDigit(i,n)}}],[{key:"BigInt",value:function(t){var i=Math.floor,_=Number.isFinite;if("number"==typeof t){if(0===t)return l.__zero();if((0|t)===t)return 0>t?l.__oneDigit(-t,!0):l.__oneDigit(t,!1);if(!_(t)||i(t)!==t)throw new RangeError("The number "+t+" cannot be converted to BigInt because it is not an integer");return l.__fromDouble(t)}if("string"==typeof t){var n=l.__fromString(t);if(null===n)throw new SyntaxError("Cannot convert "+t+" to a BigInt");return n}if("boolean"==typeof t)return!0===t?l.__oneDigit(1,!1):l.__zero();if("object"===e(t)){if(t.constructor===l)return t;var g=l.__toPrimitive(t);return l.BigInt(g)}throw new TypeError("Cannot convert "+t+" to a BigInt")}},{key:"toNumber",value:function(e){var t=e.length;if(0===t)return 0;if(1===t){var i=e.__unsignedDigit(0);return e.sign?-i:i}var _=e.__digit(t-1),n=u(_),g=32*t-n;if(1024<g)return e.sign?-Infinity:1/0;var o=g-1,a=_,s=t-1,r=n+1,d=32===r?0:a<<r;d>>>=12;var h=r-12,b=12<=r?0:a<<20+r,m=20+r;0<h&&0<s&&(s--,a=e.__digit(s),d|=a>>>32-h,b=a<<h,m=h),0<m&&0<s&&(s--,a=e.__digit(s),b|=a>>>32-m,m-=32);var c=l.__decideRounding(e,m,s,a);if((1===c||0===c&&1==(1&b))&&(b=b+1>>>0,0===b&&(d++,0!=d>>>20&&(d=0,o++,1023<o))))return e.sign?-Infinity:1/0;var v=e.sign?-2147483648:0;return o=o+1023<<20,l.__kBitConversionInts[1]=v|o|d,l.__kBitConversionInts[0]=b,l.__kBitConversionDouble[0]}},{key:"unaryMinus",value:function(e){if(0===e.length)return e;var t=e.__copy();return t.sign=!e.sign,t}},{key:"bitwiseNot",value:function(e){return e.sign?l.__absoluteSubOne(e).__trim():l.__absoluteAddOne(e,!0)}},{key:"exponentiate",value:function(e,t){if(t.sign)throw new RangeError("Exponent must be positive");if(0===t.length)return l.__oneDigit(1,!1);if(0===e.length)return e;if(1===e.length&&1===e.__digit(0))return e.sign&&0==(1&t.__digit(0))?l.unaryMinus(e):e;if(1<t.length)throw new RangeError("BigInt too big");var i=t.__unsignedDigit(0);if(1===i)return e;if(i>=l.__kMaxLengthBits)throw new RangeError("BigInt too big");if(1===e.length&&2===e.__digit(0)){var _=1+(i>>>5),n=e.sign&&0!=(1&i),g=new l(_,n);g.__initializeDigits();var o=1<<(31&i);return g.__setDigit(_-1,o),g}var a=null,s=e;for(0!=(1&i)&&(a=e),i>>=1;0!==i;i>>=1)s=l.multiply(s,s),0!=(1&i)&&(null===a?a=s:a=l.multiply(a,s));return a}},{key:"multiply",value:function(e,t){if(0===e.length)return e;if(0===t.length)return t;var _=e.length+t.length;32<=e.__clzmsd()+t.__clzmsd()&&_--;var n=new l(_,e.sign!==t.sign);n.__initializeDigits();for(var g=0;g<e.length;g++)l.__multiplyAccumulate(t,e.__digit(g),n,g);return n.__trim()}},{key:"divide",value:function(e,t){if(0===t.length)throw new RangeError("Division by zero");if(0>l.__absoluteCompare(e,t))return l.__zero();var i,_=e.sign!==t.sign,n=t.__unsignedDigit(0);if(1===t.length&&65535>=n){if(1===n)return _===e.sign?e:l.unaryMinus(e);i=l.__absoluteDivSmall(e,n,null)}else i=l.__absoluteDivLarge(e,t,!0,!1);return i.sign=_,i.__trim()}},{key:"remainder",value:function e(t,i){if(0===i.length)throw new RangeError("Division by zero");if(0>l.__absoluteCompare(t,i))return t;var _=i.__unsignedDigit(0);if(1===i.length&&65535>=_){if(1===_)return l.__zero();var n=l.__absoluteModSmall(t,_);return 0===n?l.__zero():l.__oneDigit(n,t.sign)}var e=l.__absoluteDivLarge(t,i,!1,!0);return e.sign=t.sign,e.__trim()}},{key:"add",value:function(e,t){var i=e.sign;return i===t.sign?l.__absoluteAdd(e,t,i):0<=l.__absoluteCompare(e,t)?l.__absoluteSub(e,t,i):l.__absoluteSub(t,e,!i)}},{key:"subtract",value:function(e,t){var i=e.sign;return i===t.sign?0<=l.__absoluteCompare(e,t)?l.__absoluteSub(e,t,i):l.__absoluteSub(t,e,!i):l.__absoluteAdd(e,t,i)}},{key:"leftShift",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?l.__rightShiftByAbsolute(e,t):l.__leftShiftByAbsolute(e,t)}},{key:"signedRightShift",value:function(e,t){return 0===t.length||0===e.length?e:t.sign?l.__leftShiftByAbsolute(e,t):l.__rightShiftByAbsolute(e,t)}},{key:"unsignedRightShift",value:function(){throw new TypeError("BigInts have no unsigned right shift; use >> instead")}},{key:"lessThan",value:function(e,t){return 0>l.__compareToBigInt(e,t)}},{key:"lessThanOrEqual",value:function(e,t){return 0>=l.__compareToBigInt(e,t)}},{key:"greaterThan",value:function(e,t){return 0<l.__compareToBigInt(e,t)}},{key:"greaterThanOrEqual",value:function(e,t){return 0<=l.__compareToBigInt(e,t)}},{key:"equal",value:function(e,t){if(e.sign!==t.sign)return!1;if(e.length!==t.length)return!1;for(var _=0;_<e.length;_++)if(e.__digit(_)!==t.__digit(_))return!1;return!0}},{key:"notEqual",value:function(e,t){return!l.equal(e,t)}},{key:"bitwiseAnd",value:function(e,t){if(!e.sign&&!t.sign)return l.__absoluteAnd(e,t).__trim();if(e.sign&&t.sign){var i=a(e.length,t.length)+1,_=l.__absoluteSubOne(e,i),n=l.__absoluteSubOne(t);return _=l.__absoluteOr(_,n,_),l.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}return l.__absoluteAndNot(e,l.__absoluteSubOne(t)).__trim()}},{key:"bitwiseXor",value:function(e,t){if(!e.sign&&!t.sign)return l.__absoluteXor(e,t).__trim();if(e.sign&&t.sign){var i=a(e.length,t.length),_=l.__absoluteSubOne(e,i),n=l.__absoluteSubOne(t);return l.__absoluteXor(_,n,_).__trim()}var g=a(e.length,t.length)+1;if(e.sign){var o=[t,e];e=o[0],t=o[1]}var s=l.__absoluteSubOne(t,g);return s=l.__absoluteXor(s,e,s),l.__absoluteAddOne(s,!0,s).__trim()}},{key:"bitwiseOr",value:function(e,t){var i=a(e.length,t.length);if(!e.sign&&!t.sign)return l.__absoluteOr(e,t).__trim();if(e.sign&&t.sign){var _=l.__absoluteSubOne(e,i),n=l.__absoluteSubOne(t);return _=l.__absoluteAnd(_,n,_),l.__absoluteAddOne(_,!0,_).__trim()}if(e.sign){var g=[t,e];e=g[0],t=g[1]}var o=l.__absoluteSubOne(t,i);return o=l.__absoluteAndNot(o,e,o),l.__absoluteAddOne(o,!0,o).__trim()}},{key:"asIntN",value:function(e,t){if(0===t.length)return t;if(0===e)return l.__zero();if(e>=l.__kMaxLengthBits)return t;var _=e+31>>>5;if(t.length<_)return t;var n=t.__unsignedDigit(_-1),g=1<<(31&e-1);if(t.length===_&&n<g)return t;if(!((n&g)===g))return l.__truncateToNBits(e,t);if(!t.sign)return l.__truncateAndSubFromPowerOfTwo(e,t,!0);if(0==(n&g-1)){for(var o=_-2;0<=o;o--)if(0!==t.__digit(o))return l.__truncateAndSubFromPowerOfTwo(e,t,!1);return t.length===_&&n===g?t:l.__truncateToNBits(e,t)}return l.__truncateAndSubFromPowerOfTwo(e,t,!1)}},{key:"asUintN",value:function(e,t){if(0===t.length)return t;if(0===e)return l.__zero();if(t.sign){if(e>l.__kMaxLengthBits)throw new RangeError("BigInt too big");return l.__truncateAndSubFromPowerOfTwo(e,t,!1)}if(e>=l.__kMaxLengthBits)return t;var i=e+31>>>5;if(t.length<i)return t;var _=31&e;if(t.length==i){if(0==_)return t;var n=t.__digit(i-1);if(0==n>>>_)return t}return l.__truncateToNBits(e,t)}},{key:"ADD",value:function(e,t){if(e=l.__toPrimitive(e),t=l.__toPrimitive(t),"string"==typeof e)return"string"!=typeof t&&(t=t.toString()),e+t;if("string"==typeof t)return e.toString()+t;if(e=l.__toNumeric(e),t=l.__toNumeric(t),l.__isBigInt(e)&&l.__isBigInt(t))return l.add(e,t);if("number"==typeof e&&"number"==typeof t)return e+t;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions")}},{key:"LT",value:function(e,t){return l.__compare(e,t,0)}},{key:"LE",value:function(e,t){return l.__compare(e,t,1)}},{key:"GT",value:function(e,t){return l.__compare(e,t,2)}},{key:"GE",value:function(e,t){return l.__compare(e,t,3)}},{key:"EQ",value:function(t,i){for(;;){if(l.__isBigInt(t))return l.__isBigInt(i)?l.equal(t,i):l.EQ(i,t);if("number"==typeof t){if(l.__isBigInt(i))return l.__equalToNumber(i,t);if("object"!==e(i))return t==i;i=l.__toPrimitive(i)}else if("string"==typeof t){if(l.__isBigInt(i))return t=l.__fromString(t),null!==t&&l.equal(t,i);if("object"!==e(i))return t==i;i=l.__toPrimitive(i)}else if("boolean"==typeof t){if(l.__isBigInt(i))return l.__equalToNumber(i,+t);if("object"!==e(i))return t==i;i=l.__toPrimitive(i)}else if("symbol"===e(t)){if(l.__isBigInt(i))return!1;if("object"!==e(i))return t==i;i=l.__toPrimitive(i)}else if("object"===e(t)){if("object"===e(i)&&i.constructor!==l)return t==i;t=l.__toPrimitive(t)}else return t==i}}},{key:"NE",value:function(e,t){return!l.EQ(e,t)}},{key:"__zero",value:function(){return new l(0,!1)}},{key:"__oneDigit",value:function(e,t){var i=new l(1,t);return i.__setDigit(0,e),i}},{key:"__decideRounding",value:function(e,t,i,_){if(0<t)return-1;var n;if(0>t)n=-t-1;else{if(0===i)return-1;i--,_=e.__digit(i),n=31}var g=1<<n;if(0==(_&g))return-1;if(g-=1,0!=(_&g))return 1;for(;0<i;)if(i--,0!==e.__digit(i))return 1;return 0}},{key:"__fromDouble",value:function(e){l.__kBitConversionDouble[0]=e;var t,i=2047&l.__kBitConversionInts[1]>>>20,_=i-1023,n=(_>>>5)+1,g=new l(n,0>e),o=1048575&l.__kBitConversionInts[1]|1048576,a=l.__kBitConversionInts[0],s=20,u=31&_,r=0;if(u<s){var d=s-u;r=d+32,t=o>>>d,o=o<<32-d|a>>>d,a<<=32-d}else if(u===s)r=32,t=o,o=a;else{var h=u-s;r=32-h,t=o<<h|a>>>32-h,o=a<<h}g.__setDigit(n-1,t);for(var b=n-2;0<=b;b--)0<r?(r-=32,t=o,o=a):t=0,g.__setDigit(b,t);return g.__trim()}},{key:"__isWhitespace",value:function(e){return!!(13>=e&&9<=e)||(159>=e?32==e:131071>=e?160==e||5760==e:196607>=e?(e&=131071,10>=e||40==e||41==e||47==e||95==e||4096==e):65279==e)}},{key:"__fromString",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,i=0,_=e.length,n=0;if(n===_)return l.__zero();for(var g=e.charCodeAt(n);l.__isWhitespace(g);){if(++n===_)return l.__zero();g=e.charCodeAt(n)}if(43===g){if(++n===_)return null;g=e.charCodeAt(n),i=1}else if(45===g){if(++n===_)return null;g=e.charCodeAt(n),i=-1}if(0===t){if(t=10,48===g){if(++n===_)return l.__zero();if(g=e.charCodeAt(n),88===g||120===g){if(t=16,++n===_)return null;g=e.charCodeAt(n)}else if(79===g||111===g){if(t=8,++n===_)return null;g=e.charCodeAt(n)}else if(66===g||98===g){if(t=2,++n===_)return null;g=e.charCodeAt(n)}}}else if(16===t&&48===g){if(++n===_)return l.__zero();if(g=e.charCodeAt(n),88===g||120===g){if(++n===_)return null;g=e.charCodeAt(n)}}for(;48===g;){if(++n===_)return l.__zero();g=e.charCodeAt(n)}var o=_-n,a=l.__kMaxBitsPerChar[t],s=l.__kBitsPerCharTableMultiplier-1;if(o>1073741824/a)return null;var u=a*o+s>>>l.__kBitsPerCharTableShift,r=new l(u+31>>>5,!1),h=10>t?t:10,b=10<t?t-10:0;if(0==(t&t-1)){a>>=l.__kBitsPerCharTableShift;var c=[],v=[],y=!1;do{for(var f,k=0,D=0;;){if(f=void 0,g-48>>>0<h)f=g-48;else if((32|g)-97>>>0<b)f=(32|g)-87;else{y=!0;break}if(D+=a,k=k<<a|f,++n===_){y=!0;break}if(g=e.charCodeAt(n),32<D+a)break}c.push(k),v.push(D)}while(!y);l.__fillFromParts(r,c,v)}else{r.__initializeDigits();var p=!1,B=0;do{for(var S,C=0,A=1;;){if(S=void 0,g-48>>>0<h)S=g-48;else if((32|g)-97>>>0<b)S=(32|g)-87;else{p=!0;break}var T=A*t;if(4294967295<T)break;if(A=T,C=C*t+S,B++,++n===_){p=!0;break}g=e.charCodeAt(n)}s=32*l.__kBitsPerCharTableMultiplier-1;var m=a*B+s>>>l.__kBitsPerCharTableShift+5;r.__inplaceMultiplyAdd(A,C,m)}while(!p)}for(;n!==_;){if(!l.__isWhitespace(g))return null;g=e.charCodeAt(n++)}return 0!==i&&10!==t?null:(r.sign=-1===i,r.__trim())}},{key:"__fillFromParts",value:function(e,t,_){for(var n=0,g=0,l=0,o=t.length-1;0<=o;o--){var a=t[o],s=_[o];g|=a<<l,l+=s,32===l?(e.__setDigit(n++,g),l=0,g=0):32<l&&(e.__setDigit(n++,g),l-=32,g=a>>>s-l)}if(0!==g){if(n>=e.length)throw new Error("implementation bug");e.__setDigit(n++,g)}for(;n<e.length;n++)e.__setDigit(n,0)}},{key:"__toStringBasePowerOfTwo",value:function(e,t){var _=e.length,n=t-1;n=(85&n>>>1)+(85&n),n=(51&n>>>2)+(51&n),n=(15&n>>>4)+(15&n);var g=n,o=t-1,a=e.__digit(_-1),s=u(a),r=0|(32*_-s+g-1)/g;if(e.sign&&r++,268435456<r)throw new Error("string too long");for(var d=Array(r),h=r-1,b=0,m=0,c=0;c<_-1;c++){var v=e.__digit(c),y=(b|v<<m)&o;d[h--]=l.__kConversionChars[y];var f=g-m;for(b=v>>>f,m=32-f;m>=g;)d[h--]=l.__kConversionChars[b&o],b>>>=g,m-=g}var k=(b|a<<m)&o;for(d[h--]=l.__kConversionChars[k],b=a>>>g-m;0!==b;)d[h--]=l.__kConversionChars[b&o],b>>>=g;if(e.sign&&(d[h--]="-"),-1!==h)throw new Error("implementation bug");return d.join("")}},{key:"__toStringGeneric",value:function(e,t,_){var n=e.length;if(0===n)return"";if(1===n){var g=e.__unsignedDigit(0).toString(t);return!1===_&&e.sign&&(g="-"+g),g}var o=32*n-u(e.__digit(n-1)),a=l.__kMaxBitsPerChar[t],s=a-1,r=o*l.__kBitsPerCharTableMultiplier;r+=s-1,r=0|r/s;var d,h,b=r+1>>1,m=l.exponentiate(l.__oneDigit(t,!1),l.__oneDigit(b,!1)),c=m.__unsignedDigit(0);if(1===m.length&&65535>=c){d=new l(e.length,!1),d.__initializeDigits();for(var v,y=0,f=2*e.length-1;0<=f;f--)v=y<<16|e.__halfDigit(f),d.__setHalfDigit(f,0|v/c),y=0|v%c;h=y.toString(t)}else{var k=l.__absoluteDivLarge(e,m,!0,!0);d=k.quotient;var D=k.remainder.__trim();h=l.__toStringGeneric(D,t,!0)}d.__trim();for(var p=l.__toStringGeneric(d,t,!0);h.length<b;)h="0"+h;return!1===_&&e.sign&&(p="-"+p),p+h}},{key:"__unequalSign",value:function(e){return e?-1:1}},{key:"__absoluteGreater",value:function(e){return e?-1:1}},{key:"__absoluteLess",value:function(e){return e?1:-1}},{key:"__compareToBigInt",value:function(e,t){var i=e.sign;if(i!==t.sign)return l.__unequalSign(i);var _=l.__absoluteCompare(e,t);return 0<_?l.__absoluteGreater(i):0>_?l.__absoluteLess(i):0}},{key:"__compareToNumber",value:function(e,t){if(!0|t){var i=e.sign,_=0>t;if(i!==_)return l.__unequalSign(i);if(0===e.length){if(_)throw new Error("implementation bug");return 0===t?0:-1}if(1<e.length)return l.__absoluteGreater(i);var n=o(t),g=e.__unsignedDigit(0);return g>n?l.__absoluteGreater(i):g<n?l.__absoluteLess(i):0}return l.__compareToDouble(e,t)}},{key:"__compareToDouble",value:function(e,t){if(t!==t)return t;if(t===1/0)return-1;if(t===-Infinity)return 1;var i=e.sign;if(i!==0>t)return l.__unequalSign(i);if(0===t)throw new Error("implementation bug: should be handled elsewhere");if(0===e.length)return-1;l.__kBitConversionDouble[0]=t;var _=2047&l.__kBitConversionInts[1]>>>20;if(2047==_)throw new Error("implementation bug: handled elsewhere");var n=_-1023;if(0>n)return l.__absoluteGreater(i);var g=e.length,o=e.__digit(g-1),a=u(o),s=32*g-a,r=n+1;if(s<r)return l.__absoluteLess(i);if(s>r)return l.__absoluteGreater(i);var d=1048576|1048575&l.__kBitConversionInts[1],h=l.__kBitConversionInts[0],b=20,m=31-a;if(m!==(s-1)%31)throw new Error("implementation bug");var c,v=0;if(m<b){var y=b-m;v=y+32,c=d>>>y,d=d<<32-y|h>>>y,h<<=32-y}else if(m===b)v=32,c=d,d=h;else{var f=m-b;v=32-f,c=d<<f|h>>>32-f,d=h<<f}if(o>>>=0,c>>>=0,o>c)return l.__absoluteGreater(i);if(o<c)return l.__absoluteLess(i);for(var k=g-2;0<=k;k--){0<v?(v-=32,c=d>>>0,d=h,h=0):c=0;var D=e.__unsignedDigit(k);if(D>c)return l.__absoluteGreater(i);if(D<c)return l.__absoluteLess(i)}if(0!==d||0!==h){if(0===v)throw new Error("implementation bug");return l.__absoluteLess(i)}return 0}},{key:"__equalToNumber",value:function(e,t){return t|0===t?0===t?0===e.length:1===e.length&&e.sign===0>t&&e.__unsignedDigit(0)===o(t):0===l.__compareToDouble(e,t)}},{key:"__comparisonResultToBool",value:function(e,t){switch(t){case 0:return 0>e;case 1:return 0>=e;case 2:return 0<e;case 3:return 0<=e;}throw new Error("unreachable")}},{key:"__compare",value:function(e,t,i){if(e=l.__toPrimitive(e),t=l.__toPrimitive(t),"string"==typeof e&&"string"==typeof t)switch(i){case 0:return e<t;case 1:return e<=t;case 2:return e>t;case 3:return e>=t;}if(l.__isBigInt(e)&&"string"==typeof t)return t=l.__fromString(t),null!==t&&l.__comparisonResultToBool(l.__compareToBigInt(e,t),i);if("string"==typeof e&&l.__isBigInt(t))return e=l.__fromString(e),null!==e&&l.__comparisonResultToBool(l.__compareToBigInt(e,t),i);if(e=l.__toNumeric(e),t=l.__toNumeric(t),l.__isBigInt(e)){if(l.__isBigInt(t))return l.__comparisonResultToBool(l.__compareToBigInt(e,t),i);if("number"!=typeof t)throw new Error("implementation bug");return l.__comparisonResultToBool(l.__compareToNumber(e,t),i)}if("number"!=typeof e)throw new Error("implementation bug");if(l.__isBigInt(t))return l.__comparisonResultToBool(l.__compareToNumber(t,e),2^i);if("number"!=typeof t)throw new Error("implementation bug");return 0===i?e<t:1===i?e<=t:2===i?e>t:3===i?e>=t:void 0}},{key:"__absoluteAdd",value:function(e,t,_){if(e.length<t.length)return l.__absoluteAdd(t,e,_);if(0===e.length)return e;if(0===t.length)return e.sign===_?e:l.unaryMinus(e);var n=e.length;(0===e.__clzmsd()||t.length===e.length&&0===t.__clzmsd())&&n++;for(var g=new l(n,_),o=0,a=0;a<t.length;a++){var s=t.__digit(a),u=e.__digit(a),r=(65535&u)+(65535&s)+o,d=(u>>>16)+(s>>>16)+(r>>>16);o=d>>>16,g.__setDigit(a,65535&r|d<<16)}for(;a<e.length;a++){var h=e.__digit(a),b=(65535&h)+o,m=(h>>>16)+(b>>>16);o=m>>>16,g.__setDigit(a,65535&b|m<<16)}return a<g.length&&g.__setDigit(a,o),g.__trim()}},{key:"__absoluteSub",value:function(e,t,_){if(0===e.length)return e;if(0===t.length)return e.sign===_?e:l.unaryMinus(e);for(var n=new l(e.length,_),g=0,o=0;o<t.length;o++){var a=e.__digit(o),s=t.__digit(o),u=(65535&a)-(65535&s)-g;g=1&u>>>16;var r=(a>>>16)-(s>>>16)-g;g=1&r>>>16,n.__setDigit(o,65535&u|r<<16)}for(;o<e.length;o++){var d=e.__digit(o),h=(65535&d)-g;g=1&h>>>16;var b=(d>>>16)-g;g=1&b>>>16,n.__setDigit(o,65535&h|b<<16)}return n.__trim()}},{key:"__absoluteAddOne",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length;null===_?_=new l(n,t):_.sign=t;for(var g=!0,o=0;o<n;o++){var a=e.__digit(o),s=-1===a;g&&(a=0|a+1),g=s,_.__setDigit(o,a)}return g&&_.__setDigitGrow(n,1),_}},{key:"__absoluteSubOne",value:function(e,t){var _=e.length;t=t||_;for(var n=new l(t,!1),g=!0,o=0;o<_;o++){var a=e.__digit(o),s=0===a;g&&(a=0|a-1),g=s,n.__setDigit(o,a)}for(var u=_;u<t;u++)n.__setDigit(u,0);return n}},{key:"__absoluteAnd",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,g=t.length,o=g;if(n<g){o=n;var a=e,s=n;e=t,n=g,t=a,g=s}var u=o;null===_?_=new l(u,!1):u=_.length;for(var r=0;r<o;r++)_.__setDigit(r,e.__digit(r)&t.__digit(r));for(;r<u;r++)_.__setDigit(r,0);return _}},{key:"__absoluteAndNot",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,g=t.length,o=g;n<g&&(o=n);var a=n;null===_?_=new l(a,!1):a=_.length;for(var s=0;s<o;s++)_.__setDigit(s,e.__digit(s)&~t.__digit(s));for(;s<n;s++)_.__setDigit(s,e.__digit(s));for(;s<a;s++)_.__setDigit(s,0);return _}},{key:"__absoluteOr",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,g=t.length,o=g;if(n<g){o=n;var a=e,s=n;e=t,n=g,t=a,g=s}var u=n;null===_?_=new l(u,!1):u=_.length;for(var r=0;r<o;r++)_.__setDigit(r,e.__digit(r)|t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<u;r++)_.__setDigit(r,0);return _}},{key:"__absoluteXor",value:function(e,t){var _=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,n=e.length,g=t.length,o=g;if(n<g){o=n;var a=e,s=n;e=t,n=g,t=a,g=s}var u=n;null===_?_=new l(u,!1):u=_.length;for(var r=0;r<o;r++)_.__setDigit(r,e.__digit(r)^t.__digit(r));for(;r<n;r++)_.__setDigit(r,e.__digit(r));for(;r<u;r++)_.__setDigit(r,0);return _}},{key:"__absoluteCompare",value:function(e,t){var _=e.length-t.length;if(0!=_)return _;for(var n=e.length-1;0<=n&&e.__digit(n)===t.__digit(n);)n--;return 0>n?0:e.__unsignedDigit(n)>t.__unsignedDigit(n)?1:-1}},{key:"__multiplyAccumulate",value:function(e,t,_,n){if(0!==t){for(var g=65535&t,l=t>>>16,o=0,a=0,u=0,r=0;r<e.length;r++,n++){var d=_.__digit(n),h=65535&d,b=d>>>16,m=e.__digit(r),c=65535&m,v=m>>>16,y=s(c,g),f=s(c,l),k=s(v,g),D=s(v,l);h+=a+(65535&y),b+=u+o+(h>>>16)+(y>>>16)+(65535&f)+(65535&k),o=b>>>16,a=(f>>>16)+(k>>>16)+(65535&D)+o,o=a>>>16,a&=65535,u=D>>>16,d=65535&h|b<<16,_.__setDigit(n,d)}for(;0!==o||0!==a||0!==u;n++){var p=_.__digit(n),B=(65535&p)+a,S=(p>>>16)+(B>>>16)+u+o;a=0,u=0,o=S>>>16,p=65535&B|S<<16,_.__setDigit(n,p)}}}},{key:"__internalMultiplyAdd",value:function(e,t,_,g,l){for(var o=_,a=0,u=0;u<g;u++){var r=e.__digit(u),d=s(65535&r,t),h=(65535&d)+a+o;o=h>>>16;var b=s(r>>>16,t),m=(65535&b)+(d>>>16)+o;o=m>>>16,a=b>>>16,l.__setDigit(u,m<<16|65535&h)}if(l.length>g)for(l.__setDigit(g++,o+a);g<l.length;)l.__setDigit(g++,0);else if(0!==o+a)throw new Error("implementation bug")}},{key:"__absoluteDivSmall",value:function(e,t,_){null===_&&(_=new l(e.length,!1));for(var n=0,g=2*e.length-1;0<=g;g-=2){var o=(n<<16|e.__halfDigit(g))>>>0,a=0|o/t;n=0|o%t,o=(n<<16|e.__halfDigit(g-1))>>>0;var s=0|o/t;n=0|o%t,_.__setDigit(g>>>1,a<<16|s)}return _}},{key:"__absoluteModSmall",value:function(e,t){for(var _,n=0,g=2*e.length-1;0<=g;g--)_=(n<<16|e.__halfDigit(g))>>>0,n=0|_%t;return n}},{key:"__absoluteDivLarge",value:function(e,t,i,_){var g=t.__halfDigitLength(),n=t.length,o=e.__halfDigitLength()-g,a=null;i&&(a=new l(o+2>>>1,!1),a.__initializeDigits());var r=new l(g+2>>>1,!1);r.__initializeDigits();var d=l.__clz16(t.__halfDigit(g-1));0<d&&(t=l.__specialLeftShift(t,d,0));for(var h=l.__specialLeftShift(e,d,1),u=t.__halfDigit(g-1),b=0,m=o;0<=m;m--){var v=65535,y=h.__halfDigit(m+g);if(y!==u){var f=(y<<16|h.__halfDigit(m+g-1))>>>0;v=0|f/u;for(var k=0|f%u,D=t.__halfDigit(g-2),p=h.__halfDigit(m+g-2);s(v,D)>>>0>(k<<16|p)>>>0&&(v--,k+=u,!(65535<k)););}l.__internalMultiplyAdd(t,v,0,n,r);var B=h.__inplaceSub(r,m,g+1);0!==B&&(B=h.__inplaceAdd(t,m,g),h.__setHalfDigit(m+g,h.__halfDigit(m+g)+B),v--),i&&(1&m?b=v<<16:a.__setDigit(m>>>1,b|v))}return _?(h.__inplaceRightShift(d),i?{quotient:a,remainder:h}:h):i?a:void 0}},{key:"__clz16",value:function(e){return u(e)-16}},{key:"__specialLeftShift",value:function(e,t,_){var g=e.length,n=new l(g+_,!1);if(0===t){for(var o=0;o<g;o++)n.__setDigit(o,e.__digit(o));return 0<_&&n.__setDigit(g,0),n}for(var a,s=0,u=0;u<g;u++)a=e.__digit(u),n.__setDigit(u,a<<t|s),s=a>>>32-t;return 0<_&&n.__setDigit(g,s),n}},{key:"__leftShiftByAbsolute",value:function(e,t){var _=l.__toShiftAmount(t);if(0>_)throw new RangeError("BigInt too big");var n=_>>>5,g=31&_,o=e.length,a=0!==g&&0!=e.__digit(o-1)>>>32-g,s=o+n+(a?1:0),u=new l(s,e.sign);if(0===g){for(var r=0;r<n;r++)u.__setDigit(r,0);for(;r<s;r++)u.__setDigit(r,e.__digit(r-n))}else{for(var h=0,b=0;b<n;b++)u.__setDigit(b,0);for(var m,c=0;c<o;c++)m=e.__digit(c),u.__setDigit(c+n,m<<g|h),h=m>>>32-g;if(a)u.__setDigit(o+n,h);else if(0!==h)throw new Error("implementation bug")}return u.__trim()}},{key:"__rightShiftByAbsolute",value:function(e,t){var _=e.length,n=e.sign,g=l.__toShiftAmount(t);if(0>g)return l.__rightShiftByMaximum(n);var o=g>>>5,a=31&g,s=_-o;if(0>=s)return l.__rightShiftByMaximum(n);var u=!1;if(n){if(0!=(e.__digit(o)&(1<<a)-1))u=!0;else for(var r=0;r<o;r++)if(0!==e.__digit(r)){u=!0;break}}if(u&&0===a){var h=e.__digit(_-1);0==~h&&s++}var b=new l(s,n);if(0===a)for(var m=o;m<_;m++)b.__setDigit(m-o,e.__digit(m));else{for(var c,v=e.__digit(o)>>>a,y=_-o-1,f=0;f<y;f++)c=e.__digit(f+o+1),b.__setDigit(f,c<<32-a|v),v=c>>>a;b.__setDigit(y,v)}return u&&(b=l.__absoluteAddOne(b,!0,b)),b.__trim()}},{key:"__rightShiftByMaximum",value:function(e){return e?l.__oneDigit(1,!0):l.__zero()}},{key:"__toShiftAmount",value:function(e){if(1<e.length)return-1;var t=e.__unsignedDigit(0);return t>l.__kMaxLengthBits?-1:t}},{key:"__toPrimitive",value:function(t){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"default";if("object"!==e(t))return t;if(t.constructor===l)return t;var _=t[Symbol.toPrimitive];if(_){var n=_(i);if("object"!==e(n))return n;throw new TypeError("Cannot convert object to primitive value")}var g=t.valueOf;if(g){var o=g.call(t);if("object"!==e(o))return o}var a=t.toString;if(a){var s=a.call(t);if("object"!==e(s))return s}throw new TypeError("Cannot convert object to primitive value")}},{key:"__toNumeric",value:function(e){return l.__isBigInt(e)?e:+e}},{key:"__isBigInt",value:function(t){return"object"===e(t)&&t.constructor===l}},{key:"__truncateToNBits",value:function(e,t){for(var _=e+31>>>5,n=new l(_,t.sign),g=_-1,o=0;o<g;o++)n.__setDigit(o,t.__digit(o));var a=t.__digit(g);if(0!=(31&e)){var s=32-(31&e);a=a<<s>>>s}return n.__setDigit(g,a),n.__trim()}},{key:"__truncateAndSubFromPowerOfTwo",value:function(e,t,_){for(var n=Math.min,g=e+31>>>5,o=new l(g,_),a=0,s=g-1,u=0,r=n(s,t.length);a<r;a++){var d=t.__digit(a),h=0-(65535&d)-u;u=1&h>>>16;var b=0-(d>>>16)-u;u=1&b>>>16,o.__setDigit(a,65535&h|b<<16)}for(;a<s;a++)o.__setDigit(a,0|-u);var m,c=s<t.length?t.__digit(s):0,v=31&e;if(0===v){var y=0-(65535&c)-u;u=1&y>>>16;var f=0-(c>>>16)-u;m=65535&y|f<<16}else{var k=32-v;c=c<<k>>>k;var D=1<<32-k,p=(65535&D)-(65535&c)-u;u=1&p>>>16;var B=(D>>>16)-(c>>>16)-u;m=65535&p|B<<16,m&=D-1}return o.__setDigit(s,m),o.__trim()}},{key:"__digitPow",value:function(e,t){for(var i=1;0<t;)1&t&&(i*=e),t>>>=1,e*=e;return i}}]),l}(u(Array));return h.__kMaxLength=33554432,h.__kMaxLengthBits=h.__kMaxLength<<5,h.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],h.__kBitsPerCharTableShift=5,h.__kBitsPerCharTableMultiplier=1<<h.__kBitsPerCharTableShift,h.__kConversionChars=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],h.__kBitConversionBuffer=new ArrayBuffer(8),h.__kBitConversionDouble=new Float64Array(h.__kBitConversionBuffer),h.__kBitConversionInts=new Int32Array(h.__kBitConversionBuffer),h});

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/jsbi/dist/jsbi-umd.js","/node_modules/jsbi/dist")
},{"_process":131,"buffer":121,"timers":152}],129:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/json3/lib/json3.js","/node_modules/json3/lib")
},{"_process":131,"buffer":121,"timers":152}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/process-nextick-args/index.js","/node_modules/process-nextick-args")
},{"_process":131,"buffer":121,"timers":152}],131:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/process/browser.js","/node_modules/process")
},{"_process":131,"buffer":121,"timers":152}],132:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/punycode/punycode.js","/node_modules/punycode")
},{"_process":131,"buffer":121,"timers":152}],133:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/querystring-es3/decode.js","/node_modules/querystring-es3")
},{"_process":131,"buffer":121,"timers":152}],134:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/querystring-es3/encode.js","/node_modules/querystring-es3")
},{"_process":131,"buffer":121,"timers":152}],135:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/querystring-es3/index.js","/node_modules/querystring-es3")
},{"./decode":133,"./encode":134,"_process":131,"buffer":121,"timers":152}],136:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/safe-buffer/index.js","/node_modules/safe-buffer")
},{"_process":131,"buffer":121,"timers":152}],137:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/index.js","/node_modules/stream-http")
},{"./lib/request":139,"./lib/response":140,"_process":131,"buffer":121,"builtin-status-codes":122,"timers":152,"url":154,"xtend":158}],138:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/lib/capability.js","/node_modules/stream-http/lib")
},{"_process":131,"buffer":121,"timers":152}],139:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/lib/request.js","/node_modules/stream-http/lib")
},{"./capability":138,"./response":140,"_process":131,"buffer":121,"inherits":127,"readable-stream":150,"timers":152,"to-arraybuffer":153}],140:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable)["catch"](function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			})["catch"](function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/lib/response.js","/node_modules/stream-http/lib")
},{"./capability":138,"_process":131,"buffer":121,"inherits":127,"readable-stream":150,"timers":152}],141:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/isarray/index.js","/node_modules/stream-http/node_modules/isarray")
},{"_process":131,"buffer":121,"timers":152}],142:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/_stream_duplex.js","/node_modules/stream-http/node_modules/readable-stream/lib")
},{"./_stream_readable":144,"./_stream_writable":146,"_process":131,"buffer":121,"core-util-is":123,"inherits":127,"process-nextick-args":130,"timers":152}],143:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/_stream_passthrough.js","/node_modules/stream-http/node_modules/readable-stream/lib")
},{"./_stream_transform":145,"_process":131,"buffer":121,"core-util-is":123,"inherits":127,"timers":152}],144:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/_stream_readable.js","/node_modules/stream-http/node_modules/readable-stream/lib")
},{"./_stream_duplex":142,"./internal/streams/BufferList":147,"./internal/streams/destroy":148,"./internal/streams/stream":149,"_process":131,"buffer":121,"core-util-is":123,"events":124,"inherits":127,"isarray":141,"process-nextick-args":130,"safe-buffer":136,"string_decoder/":151,"timers":152,"util":119}],145:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/_stream_transform.js","/node_modules/stream-http/node_modules/readable-stream/lib")
},{"./_stream_duplex":142,"_process":131,"buffer":121,"core-util-is":123,"inherits":127,"timers":152}],146:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options["final"] === 'function') this._final = options["final"];
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/_stream_writable.js","/node_modules/stream-http/node_modules/readable-stream/lib")
},{"./_stream_duplex":142,"./internal/streams/destroy":148,"./internal/streams/stream":149,"_process":131,"buffer":121,"core-util-is":123,"inherits":127,"process-nextick-args":130,"safe-buffer":136,"timers":152,"util-deprecate":156}],147:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/BufferList.js","/node_modules/stream-http/node_modules/readable-stream/lib/internal/streams")
},{"_process":131,"buffer":121,"safe-buffer":136,"timers":152,"util":119}],148:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/destroy.js","/node_modules/stream-http/node_modules/readable-stream/lib/internal/streams")
},{"_process":131,"buffer":121,"process-nextick-args":130,"timers":152}],149:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
module.exports = require('events').EventEmitter;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/stream-browser.js","/node_modules/stream-http/node_modules/readable-stream/lib/internal/streams")
},{"_process":131,"buffer":121,"events":124,"timers":152}],150:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/readable-stream/readable-browser.js","/node_modules/stream-http/node_modules/readable-stream")
},{"./lib/_stream_duplex.js":142,"./lib/_stream_passthrough.js":143,"./lib/_stream_readable.js":144,"./lib/_stream_transform.js":145,"./lib/_stream_writable.js":146,"_process":131,"buffer":121,"timers":152}],151:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/stream-http/node_modules/string_decoder/lib/string_decoder.js","/node_modules/stream-http/node_modules/string_decoder/lib")
},{"_process":131,"buffer":121,"safe-buffer":136,"timers":152}],152:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/timers-browserify/main.js","/node_modules/timers-browserify")
},{"_process":131,"buffer":121,"process/browser.js":131,"timers":152}],153:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/to-arraybuffer/index.js","/node_modules/to-arraybuffer")
},{"_process":131,"buffer":121,"timers":152}],154:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/url/url.js","/node_modules/url")
},{"./util":155,"_process":131,"buffer":121,"punycode":132,"querystring":135,"timers":152}],155:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/url/util.js","/node_modules/url")
},{"_process":131,"buffer":121,"timers":152}],156:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/util-deprecate/browser.js","/node_modules/util-deprecate")
},{"_process":131,"buffer":121,"timers":152}],157:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var Url = require("url");
var spawn = require("child_process").spawn;
var fs = require("fs");

exports.XMLHttpRequest = function() {
  "use strict";

  /**
   * Private variables
   */
  var self = this;
  var http = require("http");
  var https = require("https");

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*"
  };

  var headers = {};
  var headersCase = {};

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;
  
  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw new Error("SecurityError: Request method not allowed");
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn("Refused to set unsafe header \"" + header + "\"");
      return;
    }
    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send flag is true");
    }
    header = headersCase[header.toLowerCase()] || header;
    headersCase[header.toLowerCase()] = header;
    headers[header] = headers[header] ? headers[header] + ', ' + value : value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response
      && response.headers
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    if (typeof name === "string" && headersCase[name.toLowerCase()]) {
      return headers[headersCase[name.toLowerCase()]];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
    }

    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send has already been called");
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case "https:":
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case "http:":
        host = url.hostname;
        break;

      case "file:":
        local = true;
        break;

      case undefined:
      case null:
      case "":
        host = "localhost";
        break;

      default:
        throw new Error("Protocol not supported.");
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw new Error("XMLHttpRequest: Only GET method is supported");
      }

      if (settings.async) {
        fs.readFile(url.pathname, "utf8", function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, "utf8");
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : "");

    // Set the defaults if they haven't been set
    for (var name in defaultHeaders) {
      if (!headersCase[name.toLowerCase()]) {
        headers[name] = defaultHeaders[name];
      }
    }

    // Set the Host header or the server may reject the request
    headers.Host = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers.Host += ":" + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password === "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers.Authorization = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      var responseHandler = function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? "GET" : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on("error", errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on("data", function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on("end", function() {
          if (sendFlag) {
            // Discard the end event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on("error", function(error) {
          self.handleError(error);
        });
      };

      // Error handler for the request
      var errorHandler = function errorHandler(error) {
        self.handleError(error);
      };

      // Create the request
      request = doRequest(options, responseHandler).on("error", errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + JSON.stringify(data).slice(1,-1).replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);

      if (resp.err) {
        self.handleError(resp.err);
      } else {
        response = resp.data;
        self.status = resp.data.statusCode;
        self.responseText = resp.data.text;
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 0;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
    this.dispatchEvent('error');
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.status = 0;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
    this.dispatchEvent('abort');
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (state == self.LOADING || self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/xmlhttprequest/lib/XMLHttpRequest.js","/node_modules/xmlhttprequest/lib")
},{"_process":131,"buffer":121,"child_process":120,"fs":120,"http":137,"https":125,"timers":152,"url":154}],158:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate,clearImmediate,__filename,__dirname){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate,require("timers").clearImmediate,"/node_modules/xtend/immutable.js","/node_modules/xtend")
},{"_process":131,"buffer":121,"timers":152}]},{},[15])(15)
});
